"""Update triggers

Revision ID: a02492c47a31
Revises: 536766be2107
Create Date: 2026-01-05 18:23:46.915297

"""

from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from alembic_utils.pg_extension import PGExtension
from sqlalchemy import text as sql_text
from alembic_utils.pg_function import PGFunction
from sqlalchemy import text as sql_text
from alembic_utils.pg_trigger import PGTrigger
from sqlalchemy import text as sql_text

from sqlalchemy import Text
import app.db.types

# revision identifiers, used by Alembic.
revision: str = "a02492c47a31"
down_revision: Union[str, None] = "536766be2107"
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    public_hstore = PGExtension(schema="public", signature="hstore")
    op.create_entity(public_hstore)

    public_transaction_temp_table_generator = PGFunction(
        schema="public",
        signature="transaction_temp_table_generator()",
        definition="RETURNS TRIGGER AS $$\nBEGIN\n    \nCREATE TEMP TABLE IF NOT EXISTS temporary_transaction\n(id BIGINT, PRIMARY KEY(id))\nON COMMIT DELETE ROWS;\n\n    INSERT INTO temporary_transaction (id) VALUES (NEW.id);\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql",
    )
    op.create_entity(public_transaction_temp_table_generator)

    public_me_type_density_audit = PGFunction(
        schema="public",
        signature="me_type_density_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE me_type_density_version\n    SET operation_type = 1, "id" = NEW."id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector", "brain_region_id" = NEW."brain_region_id", "species_id" = NEW."species_id", "strain_id" = NEW."strain_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO me_type_density_version\n(transaction_id, operation_type, "id", "name", "description", "description_vector", "brain_region_id", "species_id", "strain_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."name", NEW."description", NEW."description_vector", NEW."brain_region_id", NEW."species_id", NEW."strain_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE me_type_density_version\n    SET operation_type = 1, "id" = NEW."id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector", "brain_region_id" = NEW."brain_region_id", "species_id" = NEW."species_id", "strain_id" = NEW."strain_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO me_type_density_version\n(transaction_id, operation_type, "id", "name", "description", "description_vector", "brain_region_id", "species_id", "strain_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."name", NEW."description", NEW."description_vector", NEW."brain_region_id", NEW."species_id", NEW."strain_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE me_type_density_version\n    SET "id" = OLD."id", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector", "brain_region_id" = OLD."brain_region_id", "species_id" = OLD."species_id", "strain_id" = OLD."strain_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO me_type_density_version\n(transaction_id, operation_type, "id", "name", "description", "description_vector", "brain_region_id", "species_id", "strain_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."name", OLD."description", OLD."description_vector", OLD."brain_region_id", OLD."species_id", OLD."strain_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_me_type_density_audit)

    public_experimental_synapses_per_connection_audit = PGFunction(
        schema="public",
        signature="experimental_synapses_per_connection_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE experimental_synapses_per_connection_version\n    SET operation_type = 1, "id" = NEW."id", "pre_mtype_id" = NEW."pre_mtype_id", "post_mtype_id" = NEW."post_mtype_id", "pre_region_id" = NEW."pre_region_id", "post_region_id" = NEW."post_region_id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector", "subject_id" = NEW."subject_id", "brain_region_id" = NEW."brain_region_id", "license_id" = NEW."license_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO experimental_synapses_per_connection_version\n(transaction_id, operation_type, "id", "pre_mtype_id", "post_mtype_id", "pre_region_id", "post_region_id", "name", "description", "description_vector", "subject_id", "brain_region_id", "license_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."pre_mtype_id", NEW."post_mtype_id", NEW."pre_region_id", NEW."post_region_id", NEW."name", NEW."description", NEW."description_vector", NEW."subject_id", NEW."brain_region_id", NEW."license_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE experimental_synapses_per_connection_version\n    SET operation_type = 1, "id" = NEW."id", "pre_mtype_id" = NEW."pre_mtype_id", "post_mtype_id" = NEW."post_mtype_id", "pre_region_id" = NEW."pre_region_id", "post_region_id" = NEW."post_region_id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector", "subject_id" = NEW."subject_id", "brain_region_id" = NEW."brain_region_id", "license_id" = NEW."license_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO experimental_synapses_per_connection_version\n(transaction_id, operation_type, "id", "pre_mtype_id", "post_mtype_id", "pre_region_id", "post_region_id", "name", "description", "description_vector", "subject_id", "brain_region_id", "license_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."pre_mtype_id", NEW."post_mtype_id", NEW."pre_region_id", NEW."post_region_id", NEW."name", NEW."description", NEW."description_vector", NEW."subject_id", NEW."brain_region_id", NEW."license_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE experimental_synapses_per_connection_version\n    SET "id" = OLD."id", "pre_mtype_id" = OLD."pre_mtype_id", "post_mtype_id" = OLD."post_mtype_id", "pre_region_id" = OLD."pre_region_id", "post_region_id" = OLD."post_region_id", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector", "subject_id" = OLD."subject_id", "brain_region_id" = OLD."brain_region_id", "license_id" = OLD."license_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO experimental_synapses_per_connection_version\n(transaction_id, operation_type, "id", "pre_mtype_id", "post_mtype_id", "pre_region_id", "post_region_id", "name", "description", "description_vector", "subject_id", "brain_region_id", "license_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."pre_mtype_id", OLD."post_mtype_id", OLD."pre_region_id", OLD."post_region_id", OLD."name", OLD."description", OLD."description_vector", OLD."subject_id", OLD."brain_region_id", OLD."license_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_experimental_synapses_per_connection_audit)

    public_skeletonization_config_generation_audit = PGFunction(
        schema="public",
        signature="skeletonization_config_generation_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE skeletonization_config_generation_version\n    SET operation_type = 1, "id" = NEW."id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO skeletonization_config_generation_version\n(transaction_id, operation_type, "id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE skeletonization_config_generation_version\n    SET operation_type = 1, "id" = NEW."id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO skeletonization_config_generation_version\n(transaction_id, operation_type, "id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE skeletonization_config_generation_version\n    SET "id" = OLD."id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO skeletonization_config_generation_version\n(transaction_id, operation_type, "id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_skeletonization_config_generation_audit)

    public_etype_classification_audit = PGFunction(
        schema="public",
        signature="etype_classification_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE etype_classification_version\n    SET operation_type = 1, "authorized_project_id" = NEW."authorized_project_id", "authorized_public" = NEW."authorized_public", "etype_class_id" = NEW."etype_class_id", "entity_id" = NEW."entity_id", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO etype_classification_version\n(transaction_id, operation_type, "authorized_project_id", "authorized_public", "etype_class_id", "entity_id", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."authorized_project_id", NEW."authorized_public", NEW."etype_class_id", NEW."entity_id", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE etype_classification_version\n    SET operation_type = 1, "authorized_project_id" = NEW."authorized_project_id", "authorized_public" = NEW."authorized_public", "etype_class_id" = NEW."etype_class_id", "entity_id" = NEW."entity_id", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO etype_classification_version\n(transaction_id, operation_type, "authorized_project_id", "authorized_public", "etype_class_id", "entity_id", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."authorized_project_id", NEW."authorized_public", NEW."etype_class_id", NEW."entity_id", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE etype_classification_version\n    SET "authorized_project_id" = OLD."authorized_project_id", "authorized_public" = OLD."authorized_public", "etype_class_id" = OLD."etype_class_id", "entity_id" = OLD."entity_id", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO etype_classification_version\n(transaction_id, operation_type, "authorized_project_id", "authorized_public", "etype_class_id", "entity_id", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."authorized_project_id", OLD."authorized_public", OLD."etype_class_id", OLD."entity_id", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_etype_classification_audit)

    public_skeletonization_execution_audit = PGFunction(
        schema="public",
        signature="skeletonization_execution_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE skeletonization_execution_version\n    SET operation_type = 1, "id" = NEW."id", "status" = NEW."status", "executor" = NEW."executor", "execution_id" = NEW."execution_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO skeletonization_execution_version\n(transaction_id, operation_type, "id", "status", "executor", "execution_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."status", NEW."executor", NEW."execution_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE skeletonization_execution_version\n    SET operation_type = 1, "id" = NEW."id", "status" = NEW."status", "executor" = NEW."executor", "execution_id" = NEW."execution_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO skeletonization_execution_version\n(transaction_id, operation_type, "id", "status", "executor", "execution_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."status", NEW."executor", NEW."execution_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE skeletonization_execution_version\n    SET "id" = OLD."id", "status" = OLD."status", "executor" = OLD."executor", "execution_id" = OLD."execution_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO skeletonization_execution_version\n(transaction_id, operation_type, "id", "status", "executor", "execution_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."status", OLD."executor", OLD."execution_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_skeletonization_execution_audit)

    public_experimental_neuron_density_audit = PGFunction(
        schema="public",
        signature="experimental_neuron_density_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE experimental_neuron_density_version\n    SET operation_type = 1, "id" = NEW."id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector", "brain_region_id" = NEW."brain_region_id", "subject_id" = NEW."subject_id", "license_id" = NEW."license_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO experimental_neuron_density_version\n(transaction_id, operation_type, "id", "name", "description", "description_vector", "brain_region_id", "subject_id", "license_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."name", NEW."description", NEW."description_vector", NEW."brain_region_id", NEW."subject_id", NEW."license_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE experimental_neuron_density_version\n    SET operation_type = 1, "id" = NEW."id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector", "brain_region_id" = NEW."brain_region_id", "subject_id" = NEW."subject_id", "license_id" = NEW."license_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO experimental_neuron_density_version\n(transaction_id, operation_type, "id", "name", "description", "description_vector", "brain_region_id", "subject_id", "license_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."name", NEW."description", NEW."description_vector", NEW."brain_region_id", NEW."subject_id", NEW."license_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE experimental_neuron_density_version\n    SET "id" = OLD."id", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector", "brain_region_id" = OLD."brain_region_id", "subject_id" = OLD."subject_id", "license_id" = OLD."license_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO experimental_neuron_density_version\n(transaction_id, operation_type, "id", "name", "description", "description_vector", "brain_region_id", "subject_id", "license_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."name", OLD."description", OLD."description_vector", OLD."brain_region_id", OLD."subject_id", OLD."license_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_experimental_neuron_density_audit)

    public_asset_audit = PGFunction(
        schema="public",
        signature="asset_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE asset_version\n    SET operation_type = 1, "status" = NEW."status", "path" = NEW."path", "full_path" = NEW."full_path", "is_directory" = NEW."is_directory", "content_type" = NEW."content_type", "size" = NEW."size", "sha256_digest" = NEW."sha256_digest", "meta" = NEW."meta", "label" = NEW."label", "entity_id" = NEW."entity_id", "storage_type" = NEW."storage_type", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO asset_version\n(transaction_id, operation_type, "status", "path", "full_path", "is_directory", "content_type", "size", "sha256_digest", "meta", "label", "entity_id", "storage_type", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."status", NEW."path", NEW."full_path", NEW."is_directory", NEW."content_type", NEW."size", NEW."sha256_digest", NEW."meta", NEW."label", NEW."entity_id", NEW."storage_type", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE asset_version\n    SET operation_type = 1, "status" = NEW."status", "path" = NEW."path", "full_path" = NEW."full_path", "is_directory" = NEW."is_directory", "content_type" = NEW."content_type", "size" = NEW."size", "sha256_digest" = NEW."sha256_digest", "meta" = NEW."meta", "label" = NEW."label", "entity_id" = NEW."entity_id", "storage_type" = NEW."storage_type", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO asset_version\n(transaction_id, operation_type, "status", "path", "full_path", "is_directory", "content_type", "size", "sha256_digest", "meta", "label", "entity_id", "storage_type", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."status", NEW."path", NEW."full_path", NEW."is_directory", NEW."content_type", NEW."size", NEW."sha256_digest", NEW."meta", NEW."label", NEW."entity_id", NEW."storage_type", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE asset_version\n    SET "status" = OLD."status", "path" = OLD."path", "full_path" = OLD."full_path", "is_directory" = OLD."is_directory", "content_type" = OLD."content_type", "size" = OLD."size", "sha256_digest" = OLD."sha256_digest", "meta" = OLD."meta", "label" = OLD."label", "entity_id" = OLD."entity_id", "storage_type" = OLD."storage_type", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO asset_version\n(transaction_id, operation_type, "status", "path", "full_path", "is_directory", "content_type", "size", "sha256_digest", "meta", "label", "entity_id", "storage_type", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."status", OLD."path", OLD."full_path", OLD."is_directory", OLD."content_type", OLD."size", OLD."sha256_digest", OLD."meta", OLD."label", OLD."entity_id", OLD."storage_type", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_asset_audit)

    public_simulation_generation_audit = PGFunction(
        schema="public",
        signature="simulation_generation_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE simulation_generation_version\n    SET operation_type = 1, "id" = NEW."id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO simulation_generation_version\n(transaction_id, operation_type, "id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE simulation_generation_version\n    SET operation_type = 1, "id" = NEW."id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO simulation_generation_version\n(transaction_id, operation_type, "id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE simulation_generation_version\n    SET "id" = OLD."id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO simulation_generation_version\n(transaction_id, operation_type, "id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_simulation_generation_audit)

    public_agent_audit = PGFunction(
        schema="public",
        signature="agent_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE agent_version\n    SET operation_type = 1, "type" = NEW."type", "pref_label" = NEW."pref_label", "legacy_id" = NEW."legacy_id", "legacy_self" = NEW."legacy_self", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO agent_version\n(transaction_id, operation_type, "type", "pref_label", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."type", NEW."pref_label", NEW."legacy_id", NEW."legacy_self", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE agent_version\n    SET operation_type = 1, "type" = NEW."type", "pref_label" = NEW."pref_label", "legacy_id" = NEW."legacy_id", "legacy_self" = NEW."legacy_self", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO agent_version\n(transaction_id, operation_type, "type", "pref_label", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."type", NEW."pref_label", NEW."legacy_id", NEW."legacy_self", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE agent_version\n    SET "type" = OLD."type", "pref_label" = OLD."pref_label", "legacy_id" = OLD."legacy_id", "legacy_self" = OLD."legacy_self", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO agent_version\n(transaction_id, operation_type, "type", "pref_label", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."type", OLD."pref_label", OLD."legacy_id", OLD."legacy_self", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_agent_audit)

    public_license_audit = PGFunction(
        schema="public",
        signature="license_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE license_version\n    SET operation_type = 1, "name" = NEW."name", "label" = NEW."label", "legacy_id" = NEW."legacy_id", "legacy_self" = NEW."legacy_self", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO license_version\n(transaction_id, operation_type, "name", "label", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."name", NEW."label", NEW."legacy_id", NEW."legacy_self", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE license_version\n    SET operation_type = 1, "name" = NEW."name", "label" = NEW."label", "legacy_id" = NEW."legacy_id", "legacy_self" = NEW."legacy_self", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO license_version\n(transaction_id, operation_type, "name", "label", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."name", NEW."label", NEW."legacy_id", NEW."legacy_self", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE license_version\n    SET "name" = OLD."name", "label" = OLD."label", "legacy_id" = OLD."legacy_id", "legacy_self" = OLD."legacy_self", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO license_version\n(transaction_id, operation_type, "name", "label", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."name", OLD."label", OLD."legacy_id", OLD."legacy_self", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_license_audit)

    public_simulation_audit = PGFunction(
        schema="public",
        signature="simulation_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE simulation_version\n    SET operation_type = 1, "id" = NEW."id", "simulation_campaign_id" = NEW."simulation_campaign_id", "entity_id" = NEW."entity_id", "scan_parameters" = NEW."scan_parameters", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO simulation_version\n(transaction_id, operation_type, "id", "simulation_campaign_id", "entity_id", "scan_parameters", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."simulation_campaign_id", NEW."entity_id", NEW."scan_parameters", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE simulation_version\n    SET operation_type = 1, "id" = NEW."id", "simulation_campaign_id" = NEW."simulation_campaign_id", "entity_id" = NEW."entity_id", "scan_parameters" = NEW."scan_parameters", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO simulation_version\n(transaction_id, operation_type, "id", "simulation_campaign_id", "entity_id", "scan_parameters", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."simulation_campaign_id", NEW."entity_id", NEW."scan_parameters", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE simulation_version\n    SET "id" = OLD."id", "simulation_campaign_id" = OLD."simulation_campaign_id", "entity_id" = OLD."entity_id", "scan_parameters" = OLD."scan_parameters", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO simulation_version\n(transaction_id, operation_type, "id", "simulation_campaign_id", "entity_id", "scan_parameters", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."simulation_campaign_id", OLD."entity_id", OLD."scan_parameters", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_simulation_audit)

    public_external_url_audit = PGFunction(
        schema="public",
        signature="external_url_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE external_url_version\n    SET operation_type = 1, "source" = NEW."source", "url" = NEW."url", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO external_url_version\n(transaction_id, operation_type, "source", "url", "id", "created_by_id", "updated_by_id", "creation_date", "update_date", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."source", NEW."url", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE external_url_version\n    SET operation_type = 1, "source" = NEW."source", "url" = NEW."url", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO external_url_version\n(transaction_id, operation_type, "source", "url", "id", "created_by_id", "updated_by_id", "creation_date", "update_date", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."source", NEW."url", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE external_url_version\n    SET "source" = OLD."source", "url" = OLD."url", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO external_url_version\n(transaction_id, operation_type, "source", "url", "id", "created_by_id", "updated_by_id", "creation_date", "update_date", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."source", OLD."url", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_external_url_audit)

    public_generation_audit = PGFunction(
        schema="public",
        signature="generation_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE generation_version\n    SET operation_type = 1, "generation_entity_id" = NEW."generation_entity_id", "generation_activity_id" = NEW."generation_activity_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "generation_entity_id" = NEW."generation_entity_id" AND "generation_activity_id" = NEW."generation_activity_id"\n    RETURNING *\n)\nINSERT INTO generation_version\n(transaction_id, operation_type, "generation_entity_id", "generation_activity_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."generation_entity_id", NEW."generation_activity_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE generation_version\n    SET operation_type = 1, "generation_entity_id" = NEW."generation_entity_id", "generation_activity_id" = NEW."generation_activity_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "generation_entity_id" = NEW."generation_entity_id" AND "generation_activity_id" = NEW."generation_activity_id"\n    RETURNING *\n)\nINSERT INTO generation_version\n(transaction_id, operation_type, "generation_entity_id", "generation_activity_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."generation_entity_id", NEW."generation_activity_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE generation_version\n    SET "generation_entity_id" = OLD."generation_entity_id", "generation_activity_id" = OLD."generation_activity_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "generation_entity_id" = OLD."generation_entity_id" AND "generation_activity_id" = OLD."generation_activity_id"\n    RETURNING *\n)\nINSERT INTO generation_version\n(transaction_id, operation_type, "generation_entity_id", "generation_activity_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."generation_entity_id", OLD."generation_activity_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_generation_audit)

    public_role_audit = PGFunction(
        schema="public",
        signature="role_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE role_version\n    SET operation_type = 1, "name" = NEW."name", "role_id" = NEW."role_id", "legacy_id" = NEW."legacy_id", "legacy_self" = NEW."legacy_self", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO role_version\n(transaction_id, operation_type, "name", "role_id", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."name", NEW."role_id", NEW."legacy_id", NEW."legacy_self", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE role_version\n    SET operation_type = 1, "name" = NEW."name", "role_id" = NEW."role_id", "legacy_id" = NEW."legacy_id", "legacy_self" = NEW."legacy_self", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO role_version\n(transaction_id, operation_type, "name", "role_id", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."name", NEW."role_id", NEW."legacy_id", NEW."legacy_self", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE role_version\n    SET "name" = OLD."name", "role_id" = OLD."role_id", "legacy_id" = OLD."legacy_id", "legacy_self" = OLD."legacy_self", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO role_version\n(transaction_id, operation_type, "name", "role_id", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."name", OLD."role_id", OLD."legacy_id", OLD."legacy_self", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_role_audit)

    public_em_cell_mesh__skeletonization_campaign_audit = PGFunction(
        schema="public",
        signature="em_cell_mesh__skeletonization_campaign_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE em_cell_mesh__skeletonization_campaign_version\n    SET operation_type = 1, "em_cell_mesh_id" = NEW."em_cell_mesh_id", "skeletonization_campaign_id" = NEW."skeletonization_campaign_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "em_cell_mesh_id" = NEW."em_cell_mesh_id" AND "skeletonization_campaign_id" = NEW."skeletonization_campaign_id"\n    RETURNING *\n)\nINSERT INTO em_cell_mesh__skeletonization_campaign_version\n(transaction_id, operation_type, "em_cell_mesh_id", "skeletonization_campaign_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."em_cell_mesh_id", NEW."skeletonization_campaign_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE em_cell_mesh__skeletonization_campaign_version\n    SET operation_type = 1, "em_cell_mesh_id" = NEW."em_cell_mesh_id", "skeletonization_campaign_id" = NEW."skeletonization_campaign_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "em_cell_mesh_id" = NEW."em_cell_mesh_id" AND "skeletonization_campaign_id" = NEW."skeletonization_campaign_id"\n    RETURNING *\n)\nINSERT INTO em_cell_mesh__skeletonization_campaign_version\n(transaction_id, operation_type, "em_cell_mesh_id", "skeletonization_campaign_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."em_cell_mesh_id", NEW."skeletonization_campaign_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE em_cell_mesh__skeletonization_campaign_version\n    SET "em_cell_mesh_id" = OLD."em_cell_mesh_id", "skeletonization_campaign_id" = OLD."skeletonization_campaign_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "em_cell_mesh_id" = OLD."em_cell_mesh_id" AND "skeletonization_campaign_id" = OLD."skeletonization_campaign_id"\n    RETURNING *\n)\nINSERT INTO em_cell_mesh__skeletonization_campaign_version\n(transaction_id, operation_type, "em_cell_mesh_id", "skeletonization_campaign_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."em_cell_mesh_id", OLD."skeletonization_campaign_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_em_cell_mesh__skeletonization_campaign_audit)

    public_organization_audit = PGFunction(
        schema="public",
        signature="organization_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE organization_version\n    SET operation_type = 1, "id" = NEW."id", "alternative_name" = NEW."alternative_name"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO organization_version\n(transaction_id, operation_type, "id", "alternative_name")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."alternative_name"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE organization_version\n    SET operation_type = 1, "id" = NEW."id", "alternative_name" = NEW."alternative_name"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO organization_version\n(transaction_id, operation_type, "id", "alternative_name")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."alternative_name"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE organization_version\n    SET "id" = OLD."id", "alternative_name" = OLD."alternative_name"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO organization_version\n(transaction_id, operation_type, "id", "alternative_name")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."alternative_name"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_organization_audit)

    public_usage_audit = PGFunction(
        schema="public",
        signature="usage_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE usage_version\n    SET operation_type = 1, "usage_entity_id" = NEW."usage_entity_id", "usage_activity_id" = NEW."usage_activity_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "usage_entity_id" = NEW."usage_entity_id" AND "usage_activity_id" = NEW."usage_activity_id"\n    RETURNING *\n)\nINSERT INTO usage_version\n(transaction_id, operation_type, "usage_entity_id", "usage_activity_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."usage_entity_id", NEW."usage_activity_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE usage_version\n    SET operation_type = 1, "usage_entity_id" = NEW."usage_entity_id", "usage_activity_id" = NEW."usage_activity_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "usage_entity_id" = NEW."usage_entity_id" AND "usage_activity_id" = NEW."usage_activity_id"\n    RETURNING *\n)\nINSERT INTO usage_version\n(transaction_id, operation_type, "usage_entity_id", "usage_activity_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."usage_entity_id", NEW."usage_activity_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE usage_version\n    SET "usage_entity_id" = OLD."usage_entity_id", "usage_activity_id" = OLD."usage_activity_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "usage_entity_id" = OLD."usage_entity_id" AND "usage_activity_id" = OLD."usage_activity_id"\n    RETURNING *\n)\nINSERT INTO usage_version\n(transaction_id, operation_type, "usage_entity_id", "usage_activity_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."usage_entity_id", OLD."usage_activity_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_usage_audit)

    public_analysis_notebook_environment_audit = PGFunction(
        schema="public",
        signature="analysis_notebook_environment_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE analysis_notebook_environment_version\n    SET operation_type = 1, "id" = NEW."id", "runtime_info" = NEW."runtime_info"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO analysis_notebook_environment_version\n(transaction_id, operation_type, "id", "runtime_info")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."runtime_info"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE analysis_notebook_environment_version\n    SET operation_type = 1, "id" = NEW."id", "runtime_info" = NEW."runtime_info"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO analysis_notebook_environment_version\n(transaction_id, operation_type, "id", "runtime_info")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."runtime_info"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE analysis_notebook_environment_version\n    SET "id" = OLD."id", "runtime_info" = OLD."runtime_info"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO analysis_notebook_environment_version\n(transaction_id, operation_type, "id", "runtime_info")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."runtime_info"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_analysis_notebook_environment_audit)

    public_circuit_extraction_config_audit = PGFunction(
        schema="public",
        signature="circuit_extraction_config_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE circuit_extraction_config_version\n    SET operation_type = 1, "id" = NEW."id", "circuit_id" = NEW."circuit_id", "scan_parameters" = NEW."scan_parameters", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO circuit_extraction_config_version\n(transaction_id, operation_type, "id", "circuit_id", "scan_parameters", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."circuit_id", NEW."scan_parameters", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE circuit_extraction_config_version\n    SET operation_type = 1, "id" = NEW."id", "circuit_id" = NEW."circuit_id", "scan_parameters" = NEW."scan_parameters", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO circuit_extraction_config_version\n(transaction_id, operation_type, "id", "circuit_id", "scan_parameters", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."circuit_id", NEW."scan_parameters", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE circuit_extraction_config_version\n    SET "id" = OLD."id", "circuit_id" = OLD."circuit_id", "scan_parameters" = OLD."scan_parameters", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO circuit_extraction_config_version\n(transaction_id, operation_type, "id", "circuit_id", "scan_parameters", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."circuit_id", OLD."scan_parameters", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_circuit_extraction_config_audit)

    public_measurement_annotation_audit = PGFunction(
        schema="public",
        signature="measurement_annotation_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE measurement_annotation_version\n    SET operation_type = 1, "entity_id" = NEW."entity_id", "legacy_id" = NEW."legacy_id", "legacy_self" = NEW."legacy_self", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO measurement_annotation_version\n(transaction_id, operation_type, "entity_id", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."entity_id", NEW."legacy_id", NEW."legacy_self", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE measurement_annotation_version\n    SET operation_type = 1, "entity_id" = NEW."entity_id", "legacy_id" = NEW."legacy_id", "legacy_self" = NEW."legacy_self", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO measurement_annotation_version\n(transaction_id, operation_type, "entity_id", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."entity_id", NEW."legacy_id", NEW."legacy_self", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE measurement_annotation_version\n    SET "entity_id" = OLD."entity_id", "legacy_id" = OLD."legacy_id", "legacy_self" = OLD."legacy_self", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO measurement_annotation_version\n(transaction_id, operation_type, "entity_id", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."entity_id", OLD."legacy_id", OLD."legacy_self", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_measurement_annotation_audit)

    public_annotation_body_audit = PGFunction(
        schema="public",
        signature="annotation_body_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE annotation_body_version\n    SET operation_type = 1, "type" = NEW."type", "legacy_id" = NEW."legacy_id", "legacy_self" = NEW."legacy_self", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO annotation_body_version\n(transaction_id, operation_type, "type", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."type", NEW."legacy_id", NEW."legacy_self", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE annotation_body_version\n    SET operation_type = 1, "type" = NEW."type", "legacy_id" = NEW."legacy_id", "legacy_self" = NEW."legacy_self", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO annotation_body_version\n(transaction_id, operation_type, "type", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."type", NEW."legacy_id", NEW."legacy_self", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE annotation_body_version\n    SET "type" = OLD."type", "legacy_id" = OLD."legacy_id", "legacy_self" = OLD."legacy_self", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO annotation_body_version\n(transaction_id, operation_type, "type", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."type", OLD."legacy_id", OLD."legacy_self", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_annotation_body_audit)

    public_annotation_audit = PGFunction(
        schema="public",
        signature="annotation_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE annotation_version\n    SET operation_type = 1, "note" = NEW."note", "entity_id" = NEW."entity_id", "annotation_body_id" = NEW."annotation_body_id", "legacy_id" = NEW."legacy_id", "legacy_self" = NEW."legacy_self", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO annotation_version\n(transaction_id, operation_type, "note", "entity_id", "annotation_body_id", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."note", NEW."entity_id", NEW."annotation_body_id", NEW."legacy_id", NEW."legacy_self", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE annotation_version\n    SET operation_type = 1, "note" = NEW."note", "entity_id" = NEW."entity_id", "annotation_body_id" = NEW."annotation_body_id", "legacy_id" = NEW."legacy_id", "legacy_self" = NEW."legacy_self", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO annotation_version\n(transaction_id, operation_type, "note", "entity_id", "annotation_body_id", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."note", NEW."entity_id", NEW."annotation_body_id", NEW."legacy_id", NEW."legacy_self", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE annotation_version\n    SET "note" = OLD."note", "entity_id" = OLD."entity_id", "annotation_body_id" = OLD."annotation_body_id", "legacy_id" = OLD."legacy_id", "legacy_self" = OLD."legacy_self", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO annotation_version\n(transaction_id, operation_type, "note", "entity_id", "annotation_body_id", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."note", OLD."entity_id", OLD."annotation_body_id", OLD."legacy_id", OLD."legacy_self", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_annotation_audit)

    public_ion_channel_model__emodel_audit = PGFunction(
        schema="public",
        signature="ion_channel_model__emodel_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_model__emodel_version\n    SET operation_type = 1, "ion_channel_model_id" = NEW."ion_channel_model_id", "emodel_id" = NEW."emodel_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "ion_channel_model_id" = NEW."ion_channel_model_id" AND "emodel_id" = NEW."emodel_id"\n    RETURNING *\n)\nINSERT INTO ion_channel_model__emodel_version\n(transaction_id, operation_type, "ion_channel_model_id", "emodel_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."ion_channel_model_id", NEW."emodel_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_model__emodel_version\n    SET operation_type = 1, "ion_channel_model_id" = NEW."ion_channel_model_id", "emodel_id" = NEW."emodel_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "ion_channel_model_id" = NEW."ion_channel_model_id" AND "emodel_id" = NEW."emodel_id"\n    RETURNING *\n)\nINSERT INTO ion_channel_model__emodel_version\n(transaction_id, operation_type, "ion_channel_model_id", "emodel_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."ion_channel_model_id", NEW."emodel_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_model__emodel_version\n    SET "ion_channel_model_id" = OLD."ion_channel_model_id", "emodel_id" = OLD."emodel_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "ion_channel_model_id" = OLD."ion_channel_model_id" AND "emodel_id" = OLD."emodel_id"\n    RETURNING *\n)\nINSERT INTO ion_channel_model__emodel_version\n(transaction_id, operation_type, "ion_channel_model_id", "emodel_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."ion_channel_model_id", OLD."emodel_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_ion_channel_model__emodel_audit)

    public_ion_channel_modeling_execution_audit = PGFunction(
        schema="public",
        signature="ion_channel_modeling_execution_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_modeling_execution_version\n    SET operation_type = 1, "id" = NEW."id", "status" = NEW."status", "executor" = NEW."executor", "execution_id" = NEW."execution_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO ion_channel_modeling_execution_version\n(transaction_id, operation_type, "id", "status", "executor", "execution_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."status", NEW."executor", NEW."execution_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_modeling_execution_version\n    SET operation_type = 1, "id" = NEW."id", "status" = NEW."status", "executor" = NEW."executor", "execution_id" = NEW."execution_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO ion_channel_modeling_execution_version\n(transaction_id, operation_type, "id", "status", "executor", "execution_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."status", NEW."executor", NEW."execution_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_modeling_execution_version\n    SET "id" = OLD."id", "status" = OLD."status", "executor" = OLD."executor", "execution_id" = OLD."execution_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO ion_channel_modeling_execution_version\n(transaction_id, operation_type, "id", "status", "executor", "execution_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."status", OLD."executor", OLD."execution_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_ion_channel_modeling_execution_audit)

    public_cell_morphology_audit = PGFunction(
        schema="public",
        signature="cell_morphology_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE cell_morphology_version\n    SET operation_type = 1, "id" = NEW."id", "location" = NEW."location", "repair_pipeline_state" = NEW."repair_pipeline_state", "cell_morphology_protocol_id" = NEW."cell_morphology_protocol_id", "has_segmented_spines" = NEW."has_segmented_spines", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO cell_morphology_version\n(transaction_id, operation_type, "id", "location", "repair_pipeline_state", "cell_morphology_protocol_id", "has_segmented_spines", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."location", NEW."repair_pipeline_state", NEW."cell_morphology_protocol_id", NEW."has_segmented_spines", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE cell_morphology_version\n    SET operation_type = 1, "id" = NEW."id", "location" = NEW."location", "repair_pipeline_state" = NEW."repair_pipeline_state", "cell_morphology_protocol_id" = NEW."cell_morphology_protocol_id", "has_segmented_spines" = NEW."has_segmented_spines", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO cell_morphology_version\n(transaction_id, operation_type, "id", "location", "repair_pipeline_state", "cell_morphology_protocol_id", "has_segmented_spines", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."location", NEW."repair_pipeline_state", NEW."cell_morphology_protocol_id", NEW."has_segmented_spines", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE cell_morphology_version\n    SET "id" = OLD."id", "location" = OLD."location", "repair_pipeline_state" = OLD."repair_pipeline_state", "cell_morphology_protocol_id" = OLD."cell_morphology_protocol_id", "has_segmented_spines" = OLD."has_segmented_spines", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO cell_morphology_version\n(transaction_id, operation_type, "id", "location", "repair_pipeline_state", "cell_morphology_protocol_id", "has_segmented_spines", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."location", OLD."repair_pipeline_state", OLD."cell_morphology_protocol_id", OLD."has_segmented_spines", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_cell_morphology_audit)

    public_simulation_campaign_audit = PGFunction(
        schema="public",
        signature="simulation_campaign_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE simulation_campaign_version\n    SET operation_type = 1, "id" = NEW."id", "entity_id" = NEW."entity_id", "scan_parameters" = NEW."scan_parameters", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO simulation_campaign_version\n(transaction_id, operation_type, "id", "entity_id", "scan_parameters", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."entity_id", NEW."scan_parameters", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE simulation_campaign_version\n    SET operation_type = 1, "id" = NEW."id", "entity_id" = NEW."entity_id", "scan_parameters" = NEW."scan_parameters", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO simulation_campaign_version\n(transaction_id, operation_type, "id", "entity_id", "scan_parameters", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."entity_id", NEW."scan_parameters", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE simulation_campaign_version\n    SET "id" = OLD."id", "entity_id" = OLD."entity_id", "scan_parameters" = OLD."scan_parameters", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO simulation_campaign_version\n(transaction_id, operation_type, "id", "entity_id", "scan_parameters", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."entity_id", OLD."scan_parameters", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_simulation_campaign_audit)

    public_circuit_audit = PGFunction(
        schema="public",
        signature="circuit_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE circuit_version\n    SET operation_type = 1, "id" = NEW."id", "root_circuit_id" = NEW."root_circuit_id", "atlas_id" = NEW."atlas_id", "build_category" = NEW."build_category", "scale" = NEW."scale", "has_morphologies" = NEW."has_morphologies", "has_point_neurons" = NEW."has_point_neurons", "has_electrical_cell_models" = NEW."has_electrical_cell_models", "has_spines" = NEW."has_spines", "number_neurons" = NEW."number_neurons", "number_synapses" = NEW."number_synapses", "number_connections" = NEW."number_connections", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO circuit_version\n(transaction_id, operation_type, "id", "root_circuit_id", "atlas_id", "build_category", "scale", "has_morphologies", "has_point_neurons", "has_electrical_cell_models", "has_spines", "number_neurons", "number_synapses", "number_connections", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."root_circuit_id", NEW."atlas_id", NEW."build_category", NEW."scale", NEW."has_morphologies", NEW."has_point_neurons", NEW."has_electrical_cell_models", NEW."has_spines", NEW."number_neurons", NEW."number_synapses", NEW."number_connections", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE circuit_version\n    SET operation_type = 1, "id" = NEW."id", "root_circuit_id" = NEW."root_circuit_id", "atlas_id" = NEW."atlas_id", "build_category" = NEW."build_category", "scale" = NEW."scale", "has_morphologies" = NEW."has_morphologies", "has_point_neurons" = NEW."has_point_neurons", "has_electrical_cell_models" = NEW."has_electrical_cell_models", "has_spines" = NEW."has_spines", "number_neurons" = NEW."number_neurons", "number_synapses" = NEW."number_synapses", "number_connections" = NEW."number_connections", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO circuit_version\n(transaction_id, operation_type, "id", "root_circuit_id", "atlas_id", "build_category", "scale", "has_morphologies", "has_point_neurons", "has_electrical_cell_models", "has_spines", "number_neurons", "number_synapses", "number_connections", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."root_circuit_id", NEW."atlas_id", NEW."build_category", NEW."scale", NEW."has_morphologies", NEW."has_point_neurons", NEW."has_electrical_cell_models", NEW."has_spines", NEW."number_neurons", NEW."number_synapses", NEW."number_connections", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE circuit_version\n    SET "id" = OLD."id", "root_circuit_id" = OLD."root_circuit_id", "atlas_id" = OLD."atlas_id", "build_category" = OLD."build_category", "scale" = OLD."scale", "has_morphologies" = OLD."has_morphologies", "has_point_neurons" = OLD."has_point_neurons", "has_electrical_cell_models" = OLD."has_electrical_cell_models", "has_spines" = OLD."has_spines", "number_neurons" = OLD."number_neurons", "number_synapses" = OLD."number_synapses", "number_connections" = OLD."number_connections", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO circuit_version\n(transaction_id, operation_type, "id", "root_circuit_id", "atlas_id", "build_category", "scale", "has_morphologies", "has_point_neurons", "has_electrical_cell_models", "has_spines", "number_neurons", "number_synapses", "number_connections", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."root_circuit_id", OLD."atlas_id", OLD."build_category", OLD."scale", OLD."has_morphologies", OLD."has_point_neurons", OLD."has_electrical_cell_models", OLD."has_spines", OLD."number_neurons", OLD."number_synapses", OLD."number_connections", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_circuit_audit)

    public_ion_channel_recording__ion_channel_modeling_campaign_audit = PGFunction(
        schema="public",
        signature="ion_channel_recording__ion_channel_modeling_campaign_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_recording__ion_channel_modeling_campaign_version\n    SET operation_type = 1, "ion_channel_recording_id" = NEW."ion_channel_recording_id", "ion_channel_modeling_campaign_id" = NEW."ion_channel_modeling_campaign_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "ion_channel_recording_id" = NEW."ion_channel_recording_id" AND "ion_channel_modeling_campaign_id" = NEW."ion_channel_modeling_campaign_id"\n    RETURNING *\n)\nINSERT INTO ion_channel_recording__ion_channel_modeling_campaign_version\n(transaction_id, operation_type, "ion_channel_recording_id", "ion_channel_modeling_campaign_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."ion_channel_recording_id", NEW."ion_channel_modeling_campaign_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_recording__ion_channel_modeling_campaign_version\n    SET operation_type = 1, "ion_channel_recording_id" = NEW."ion_channel_recording_id", "ion_channel_modeling_campaign_id" = NEW."ion_channel_modeling_campaign_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "ion_channel_recording_id" = NEW."ion_channel_recording_id" AND "ion_channel_modeling_campaign_id" = NEW."ion_channel_modeling_campaign_id"\n    RETURNING *\n)\nINSERT INTO ion_channel_recording__ion_channel_modeling_campaign_version\n(transaction_id, operation_type, "ion_channel_recording_id", "ion_channel_modeling_campaign_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."ion_channel_recording_id", NEW."ion_channel_modeling_campaign_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_recording__ion_channel_modeling_campaign_version\n    SET "ion_channel_recording_id" = OLD."ion_channel_recording_id", "ion_channel_modeling_campaign_id" = OLD."ion_channel_modeling_campaign_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "ion_channel_recording_id" = OLD."ion_channel_recording_id" AND "ion_channel_modeling_campaign_id" = OLD."ion_channel_modeling_campaign_id"\n    RETURNING *\n)\nINSERT INTO ion_channel_recording__ion_channel_modeling_campaign_version\n(transaction_id, operation_type, "ion_channel_recording_id", "ion_channel_modeling_campaign_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."ion_channel_recording_id", OLD."ion_channel_modeling_campaign_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_ion_channel_recording__ion_channel_modeling_campaign_audit)

    public_memodel_calibration_result_audit = PGFunction(
        schema="public",
        signature="memodel_calibration_result_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE memodel_calibration_result_version\n    SET operation_type = 1, "id" = NEW."id", "holding_current" = NEW."holding_current", "threshold_current" = NEW."threshold_current", "rin" = NEW."rin", "calibrated_entity_id" = NEW."calibrated_entity_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO memodel_calibration_result_version\n(transaction_id, operation_type, "id", "holding_current", "threshold_current", "rin", "calibrated_entity_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."holding_current", NEW."threshold_current", NEW."rin", NEW."calibrated_entity_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE memodel_calibration_result_version\n    SET operation_type = 1, "id" = NEW."id", "holding_current" = NEW."holding_current", "threshold_current" = NEW."threshold_current", "rin" = NEW."rin", "calibrated_entity_id" = NEW."calibrated_entity_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO memodel_calibration_result_version\n(transaction_id, operation_type, "id", "holding_current", "threshold_current", "rin", "calibrated_entity_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."holding_current", NEW."threshold_current", NEW."rin", NEW."calibrated_entity_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE memodel_calibration_result_version\n    SET "id" = OLD."id", "holding_current" = OLD."holding_current", "threshold_current" = OLD."threshold_current", "rin" = OLD."rin", "calibrated_entity_id" = OLD."calibrated_entity_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO memodel_calibration_result_version\n(transaction_id, operation_type, "id", "holding_current", "threshold_current", "rin", "calibrated_entity_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."holding_current", OLD."threshold_current", OLD."rin", OLD."calibrated_entity_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_memodel_calibration_result_audit)

    public_brain_region_audit = PGFunction(
        schema="public",
        signature="brain_region_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE brain_region_version\n    SET operation_type = 1, "annotation_value" = NEW."annotation_value", "name" = NEW."name", "acronym" = NEW."acronym", "color_hex_triplet" = NEW."color_hex_triplet", "parent_structure_id" = NEW."parent_structure_id", "hierarchy_id" = NEW."hierarchy_id", "embedding" = NEW."embedding", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO brain_region_version\n(transaction_id, operation_type, "annotation_value", "name", "acronym", "color_hex_triplet", "parent_structure_id", "hierarchy_id", "embedding", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."annotation_value", NEW."name", NEW."acronym", NEW."color_hex_triplet", NEW."parent_structure_id", NEW."hierarchy_id", NEW."embedding", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE brain_region_version\n    SET operation_type = 1, "annotation_value" = NEW."annotation_value", "name" = NEW."name", "acronym" = NEW."acronym", "color_hex_triplet" = NEW."color_hex_triplet", "parent_structure_id" = NEW."parent_structure_id", "hierarchy_id" = NEW."hierarchy_id", "embedding" = NEW."embedding", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO brain_region_version\n(transaction_id, operation_type, "annotation_value", "name", "acronym", "color_hex_triplet", "parent_structure_id", "hierarchy_id", "embedding", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."annotation_value", NEW."name", NEW."acronym", NEW."color_hex_triplet", NEW."parent_structure_id", NEW."hierarchy_id", NEW."embedding", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE brain_region_version\n    SET "annotation_value" = OLD."annotation_value", "name" = OLD."name", "acronym" = OLD."acronym", "color_hex_triplet" = OLD."color_hex_triplet", "parent_structure_id" = OLD."parent_structure_id", "hierarchy_id" = OLD."hierarchy_id", "embedding" = OLD."embedding", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO brain_region_version\n(transaction_id, operation_type, "annotation_value", "name", "acronym", "color_hex_triplet", "parent_structure_id", "hierarchy_id", "embedding", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."annotation_value", OLD."name", OLD."acronym", OLD."color_hex_triplet", OLD."parent_structure_id", OLD."hierarchy_id", OLD."embedding", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_brain_region_audit)

    public_skeletonization_config_audit = PGFunction(
        schema="public",
        signature="skeletonization_config_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE skeletonization_config_version\n    SET operation_type = 1, "id" = NEW."id", "scan_parameters" = NEW."scan_parameters", "skeletonization_campaign_id" = NEW."skeletonization_campaign_id", "em_cell_mesh_id" = NEW."em_cell_mesh_id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO skeletonization_config_version\n(transaction_id, operation_type, "id", "scan_parameters", "skeletonization_campaign_id", "em_cell_mesh_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."scan_parameters", NEW."skeletonization_campaign_id", NEW."em_cell_mesh_id", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE skeletonization_config_version\n    SET operation_type = 1, "id" = NEW."id", "scan_parameters" = NEW."scan_parameters", "skeletonization_campaign_id" = NEW."skeletonization_campaign_id", "em_cell_mesh_id" = NEW."em_cell_mesh_id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO skeletonization_config_version\n(transaction_id, operation_type, "id", "scan_parameters", "skeletonization_campaign_id", "em_cell_mesh_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."scan_parameters", NEW."skeletonization_campaign_id", NEW."em_cell_mesh_id", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE skeletonization_config_version\n    SET "id" = OLD."id", "scan_parameters" = OLD."scan_parameters", "skeletonization_campaign_id" = OLD."skeletonization_campaign_id", "em_cell_mesh_id" = OLD."em_cell_mesh_id", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO skeletonization_config_version\n(transaction_id, operation_type, "id", "scan_parameters", "skeletonization_campaign_id", "em_cell_mesh_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."scan_parameters", OLD."skeletonization_campaign_id", OLD."em_cell_mesh_id", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_skeletonization_config_audit)

    public_species_audit = PGFunction(
        schema="public",
        signature="species_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE species_version\n    SET operation_type = 1, "name" = NEW."name", "taxonomy_id" = NEW."taxonomy_id", "embedding" = NEW."embedding", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO species_version\n(transaction_id, operation_type, "name", "taxonomy_id", "embedding", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."name", NEW."taxonomy_id", NEW."embedding", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE species_version\n    SET operation_type = 1, "name" = NEW."name", "taxonomy_id" = NEW."taxonomy_id", "embedding" = NEW."embedding", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO species_version\n(transaction_id, operation_type, "name", "taxonomy_id", "embedding", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."name", NEW."taxonomy_id", NEW."embedding", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE species_version\n    SET "name" = OLD."name", "taxonomy_id" = OLD."taxonomy_id", "embedding" = OLD."embedding", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO species_version\n(transaction_id, operation_type, "name", "taxonomy_id", "embedding", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."name", OLD."taxonomy_id", OLD."embedding", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_species_audit)

    public_scientific_artifact_external_url_link_audit = PGFunction(
        schema="public",
        signature="scientific_artifact_external_url_link_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE scientific_artifact_external_url_link_version\n    SET operation_type = 1, "external_url_id" = NEW."external_url_id", "scientific_artifact_id" = NEW."scientific_artifact_id", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO scientific_artifact_external_url_link_version\n(transaction_id, operation_type, "external_url_id", "scientific_artifact_id", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."external_url_id", NEW."scientific_artifact_id", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE scientific_artifact_external_url_link_version\n    SET operation_type = 1, "external_url_id" = NEW."external_url_id", "scientific_artifact_id" = NEW."scientific_artifact_id", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO scientific_artifact_external_url_link_version\n(transaction_id, operation_type, "external_url_id", "scientific_artifact_id", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."external_url_id", NEW."scientific_artifact_id", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE scientific_artifact_external_url_link_version\n    SET "external_url_id" = OLD."external_url_id", "scientific_artifact_id" = OLD."scientific_artifact_id", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO scientific_artifact_external_url_link_version\n(transaction_id, operation_type, "external_url_id", "scientific_artifact_id", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."external_url_id", OLD."scientific_artifact_id", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_scientific_artifact_external_url_link_audit)

    public_mtype_classification_audit = PGFunction(
        schema="public",
        signature="mtype_classification_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE mtype_classification_version\n    SET operation_type = 1, "authorized_project_id" = NEW."authorized_project_id", "authorized_public" = NEW."authorized_public", "mtype_class_id" = NEW."mtype_class_id", "entity_id" = NEW."entity_id", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO mtype_classification_version\n(transaction_id, operation_type, "authorized_project_id", "authorized_public", "mtype_class_id", "entity_id", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."authorized_project_id", NEW."authorized_public", NEW."mtype_class_id", NEW."entity_id", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE mtype_classification_version\n    SET operation_type = 1, "authorized_project_id" = NEW."authorized_project_id", "authorized_public" = NEW."authorized_public", "mtype_class_id" = NEW."mtype_class_id", "entity_id" = NEW."entity_id", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO mtype_classification_version\n(transaction_id, operation_type, "authorized_project_id", "authorized_public", "mtype_class_id", "entity_id", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."authorized_project_id", NEW."authorized_public", NEW."mtype_class_id", NEW."entity_id", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE mtype_classification_version\n    SET "authorized_project_id" = OLD."authorized_project_id", "authorized_public" = OLD."authorized_public", "mtype_class_id" = OLD."mtype_class_id", "entity_id" = OLD."entity_id", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO mtype_classification_version\n(transaction_id, operation_type, "authorized_project_id", "authorized_public", "mtype_class_id", "entity_id", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."authorized_project_id", OLD."authorized_public", OLD."mtype_class_id", OLD."entity_id", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_mtype_classification_audit)

    public_ion_channel_audit = PGFunction(
        schema="public",
        signature="ion_channel_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_version\n    SET operation_type = 1, "label" = NEW."label", "gene" = NEW."gene", "synonyms" = NEW."synonyms", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO ion_channel_version\n(transaction_id, operation_type, "label", "gene", "synonyms", "name", "description", "description_vector", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."label", NEW."gene", NEW."synonyms", NEW."name", NEW."description", NEW."description_vector", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_version\n    SET operation_type = 1, "label" = NEW."label", "gene" = NEW."gene", "synonyms" = NEW."synonyms", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO ion_channel_version\n(transaction_id, operation_type, "label", "gene", "synonyms", "name", "description", "description_vector", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."label", NEW."gene", NEW."synonyms", NEW."name", NEW."description", NEW."description_vector", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_version\n    SET "label" = OLD."label", "gene" = OLD."gene", "synonyms" = OLD."synonyms", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO ion_channel_version\n(transaction_id, operation_type, "label", "gene", "synonyms", "name", "description", "description_vector", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."label", OLD."gene", OLD."synonyms", OLD."name", OLD."description", OLD."description_vector", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_ion_channel_audit)

    public_cell_composition_audit = PGFunction(
        schema="public",
        signature="cell_composition_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE cell_composition_version\n    SET operation_type = 1, "id" = NEW."id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector", "brain_region_id" = NEW."brain_region_id", "species_id" = NEW."species_id", "strain_id" = NEW."strain_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO cell_composition_version\n(transaction_id, operation_type, "id", "name", "description", "description_vector", "brain_region_id", "species_id", "strain_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."name", NEW."description", NEW."description_vector", NEW."brain_region_id", NEW."species_id", NEW."strain_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE cell_composition_version\n    SET operation_type = 1, "id" = NEW."id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector", "brain_region_id" = NEW."brain_region_id", "species_id" = NEW."species_id", "strain_id" = NEW."strain_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO cell_composition_version\n(transaction_id, operation_type, "id", "name", "description", "description_vector", "brain_region_id", "species_id", "strain_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."name", NEW."description", NEW."description_vector", NEW."brain_region_id", NEW."species_id", NEW."strain_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE cell_composition_version\n    SET "id" = OLD."id", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector", "brain_region_id" = OLD."brain_region_id", "species_id" = OLD."species_id", "strain_id" = OLD."strain_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO cell_composition_version\n(transaction_id, operation_type, "id", "name", "description", "description_vector", "brain_region_id", "species_id", "strain_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."name", OLD."description", OLD."description_vector", OLD."brain_region_id", OLD."species_id", OLD."strain_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_cell_composition_audit)

    public_circuit_extraction_campaign_audit = PGFunction(
        schema="public",
        signature="circuit_extraction_campaign_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE circuit_extraction_campaign_version\n    SET operation_type = 1, "id" = NEW."id", "scan_parameters" = NEW."scan_parameters", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO circuit_extraction_campaign_version\n(transaction_id, operation_type, "id", "scan_parameters", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."scan_parameters", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE circuit_extraction_campaign_version\n    SET operation_type = 1, "id" = NEW."id", "scan_parameters" = NEW."scan_parameters", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO circuit_extraction_campaign_version\n(transaction_id, operation_type, "id", "scan_parameters", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."scan_parameters", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE circuit_extraction_campaign_version\n    SET "id" = OLD."id", "scan_parameters" = OLD."scan_parameters", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO circuit_extraction_campaign_version\n(transaction_id, operation_type, "id", "scan_parameters", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."scan_parameters", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_circuit_extraction_campaign_audit)

    public_mtype_class_audit = PGFunction(
        schema="public",
        signature="mtype_class_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE mtype_class_version\n    SET operation_type = 1, "pref_label" = NEW."pref_label", "definition" = NEW."definition", "alt_label" = NEW."alt_label", "legacy_id" = NEW."legacy_id", "legacy_self" = NEW."legacy_self", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO mtype_class_version\n(transaction_id, operation_type, "pref_label", "definition", "alt_label", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."pref_label", NEW."definition", NEW."alt_label", NEW."legacy_id", NEW."legacy_self", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE mtype_class_version\n    SET operation_type = 1, "pref_label" = NEW."pref_label", "definition" = NEW."definition", "alt_label" = NEW."alt_label", "legacy_id" = NEW."legacy_id", "legacy_self" = NEW."legacy_self", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO mtype_class_version\n(transaction_id, operation_type, "pref_label", "definition", "alt_label", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."pref_label", NEW."definition", NEW."alt_label", NEW."legacy_id", NEW."legacy_self", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE mtype_class_version\n    SET "pref_label" = OLD."pref_label", "definition" = OLD."definition", "alt_label" = OLD."alt_label", "legacy_id" = OLD."legacy_id", "legacy_self" = OLD."legacy_self", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO mtype_class_version\n(transaction_id, operation_type, "pref_label", "definition", "alt_label", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."pref_label", OLD."definition", OLD."alt_label", OLD."legacy_id", OLD."legacy_self", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_mtype_class_audit)

    public_ion_channel_model_audit = PGFunction(
        schema="public",
        signature="ion_channel_model_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_model_version\n    SET operation_type = 1, "id" = NEW."id", "is_ljp_corrected" = NEW."is_ljp_corrected", "is_temperature_dependent" = NEW."is_temperature_dependent", "temperature_celsius" = NEW."temperature_celsius", "is_stochastic" = NEW."is_stochastic", "nmodl_suffix" = NEW."nmodl_suffix", "neuron_block" = NEW."neuron_block", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO ion_channel_model_version\n(transaction_id, operation_type, "id", "is_ljp_corrected", "is_temperature_dependent", "temperature_celsius", "is_stochastic", "nmodl_suffix", "neuron_block", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."is_ljp_corrected", NEW."is_temperature_dependent", NEW."temperature_celsius", NEW."is_stochastic", NEW."nmodl_suffix", NEW."neuron_block", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_model_version\n    SET operation_type = 1, "id" = NEW."id", "is_ljp_corrected" = NEW."is_ljp_corrected", "is_temperature_dependent" = NEW."is_temperature_dependent", "temperature_celsius" = NEW."temperature_celsius", "is_stochastic" = NEW."is_stochastic", "nmodl_suffix" = NEW."nmodl_suffix", "neuron_block" = NEW."neuron_block", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO ion_channel_model_version\n(transaction_id, operation_type, "id", "is_ljp_corrected", "is_temperature_dependent", "temperature_celsius", "is_stochastic", "nmodl_suffix", "neuron_block", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."is_ljp_corrected", NEW."is_temperature_dependent", NEW."temperature_celsius", NEW."is_stochastic", NEW."nmodl_suffix", NEW."neuron_block", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_model_version\n    SET "id" = OLD."id", "is_ljp_corrected" = OLD."is_ljp_corrected", "is_temperature_dependent" = OLD."is_temperature_dependent", "temperature_celsius" = OLD."temperature_celsius", "is_stochastic" = OLD."is_stochastic", "nmodl_suffix" = OLD."nmodl_suffix", "neuron_block" = OLD."neuron_block", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO ion_channel_model_version\n(transaction_id, operation_type, "id", "is_ljp_corrected", "is_temperature_dependent", "temperature_celsius", "is_stochastic", "nmodl_suffix", "neuron_block", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."is_ljp_corrected", OLD."is_temperature_dependent", OLD."temperature_celsius", OLD."is_stochastic", OLD."nmodl_suffix", OLD."neuron_block", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_ion_channel_model_audit)

    public_circuit_extraction_execution_audit = PGFunction(
        schema="public",
        signature="circuit_extraction_execution_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE circuit_extraction_execution_version\n    SET operation_type = 1, "id" = NEW."id", "status" = NEW."status", "executor" = NEW."executor", "execution_id" = NEW."execution_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO circuit_extraction_execution_version\n(transaction_id, operation_type, "id", "status", "executor", "execution_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."status", NEW."executor", NEW."execution_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE circuit_extraction_execution_version\n    SET operation_type = 1, "id" = NEW."id", "status" = NEW."status", "executor" = NEW."executor", "execution_id" = NEW."execution_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO circuit_extraction_execution_version\n(transaction_id, operation_type, "id", "status", "executor", "execution_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."status", NEW."executor", NEW."execution_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE circuit_extraction_execution_version\n    SET "id" = OLD."id", "status" = OLD."status", "executor" = OLD."executor", "execution_id" = OLD."execution_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO circuit_extraction_execution_version\n(transaction_id, operation_type, "id", "status", "executor", "execution_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."status", OLD."executor", OLD."execution_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_circuit_extraction_execution_audit)

    public_cell_morphology_protocol_audit = PGFunction(
        schema="public",
        signature="cell_morphology_protocol_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE cell_morphology_protocol_version\n    SET operation_type = 1, "id" = NEW."id", "protocol_document" = NEW."protocol_document", "protocol_design" = NEW."protocol_design", "generation_type" = NEW."generation_type", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector", "staining_type" = NEW."staining_type", "slicing_thickness" = NEW."slicing_thickness", "slicing_direction" = NEW."slicing_direction", "magnification" = NEW."magnification", "tissue_shrinkage" = NEW."tissue_shrinkage", "corrected_for_shrinkage" = NEW."corrected_for_shrinkage", "method_type" = NEW."method_type"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO cell_morphology_protocol_version\n(transaction_id, operation_type, "id", "protocol_document", "protocol_design", "generation_type", "name", "description", "description_vector", "staining_type", "slicing_thickness", "slicing_direction", "magnification", "tissue_shrinkage", "corrected_for_shrinkage", "method_type")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."protocol_document", NEW."protocol_design", NEW."generation_type", NEW."name", NEW."description", NEW."description_vector", NEW."staining_type", NEW."slicing_thickness", NEW."slicing_direction", NEW."magnification", NEW."tissue_shrinkage", NEW."corrected_for_shrinkage", NEW."method_type"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE cell_morphology_protocol_version\n    SET operation_type = 1, "id" = NEW."id", "protocol_document" = NEW."protocol_document", "protocol_design" = NEW."protocol_design", "generation_type" = NEW."generation_type", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector", "staining_type" = NEW."staining_type", "slicing_thickness" = NEW."slicing_thickness", "slicing_direction" = NEW."slicing_direction", "magnification" = NEW."magnification", "tissue_shrinkage" = NEW."tissue_shrinkage", "corrected_for_shrinkage" = NEW."corrected_for_shrinkage", "method_type" = NEW."method_type"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO cell_morphology_protocol_version\n(transaction_id, operation_type, "id", "protocol_document", "protocol_design", "generation_type", "name", "description", "description_vector", "staining_type", "slicing_thickness", "slicing_direction", "magnification", "tissue_shrinkage", "corrected_for_shrinkage", "method_type")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."protocol_document", NEW."protocol_design", NEW."generation_type", NEW."name", NEW."description", NEW."description_vector", NEW."staining_type", NEW."slicing_thickness", NEW."slicing_direction", NEW."magnification", NEW."tissue_shrinkage", NEW."corrected_for_shrinkage", NEW."method_type"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE cell_morphology_protocol_version\n    SET "id" = OLD."id", "protocol_document" = OLD."protocol_document", "protocol_design" = OLD."protocol_design", "generation_type" = OLD."generation_type", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector", "staining_type" = OLD."staining_type", "slicing_thickness" = OLD."slicing_thickness", "slicing_direction" = OLD."slicing_direction", "magnification" = OLD."magnification", "tissue_shrinkage" = OLD."tissue_shrinkage", "corrected_for_shrinkage" = OLD."corrected_for_shrinkage", "method_type" = OLD."method_type"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO cell_morphology_protocol_version\n(transaction_id, operation_type, "id", "protocol_document", "protocol_design", "generation_type", "name", "description", "description_vector", "staining_type", "slicing_thickness", "slicing_direction", "magnification", "tissue_shrinkage", "corrected_for_shrinkage", "method_type")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."protocol_document", OLD."protocol_design", OLD."generation_type", OLD."name", OLD."description", OLD."description_vector", OLD."staining_type", OLD."slicing_thickness", OLD."slicing_direction", OLD."magnification", OLD."tissue_shrinkage", OLD."corrected_for_shrinkage", OLD."method_type"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_cell_morphology_protocol_audit)

    public_simulation_result_audit = PGFunction(
        schema="public",
        signature="simulation_result_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE simulation_result_version\n    SET operation_type = 1, "id" = NEW."id", "simulation_id" = NEW."simulation_id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO simulation_result_version\n(transaction_id, operation_type, "id", "simulation_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."simulation_id", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE simulation_result_version\n    SET operation_type = 1, "id" = NEW."id", "simulation_id" = NEW."simulation_id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO simulation_result_version\n(transaction_id, operation_type, "id", "simulation_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."simulation_id", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE simulation_result_version\n    SET "id" = OLD."id", "simulation_id" = OLD."simulation_id", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO simulation_result_version\n(transaction_id, operation_type, "id", "simulation_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."simulation_id", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_simulation_result_audit)

    public_validation_audit = PGFunction(
        schema="public",
        signature="validation_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE validation_version\n    SET operation_type = 1, "id" = NEW."id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO validation_version\n(transaction_id, operation_type, "id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE validation_version\n    SET operation_type = 1, "id" = NEW."id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO validation_version\n(transaction_id, operation_type, "id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE validation_version\n    SET "id" = OLD."id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO validation_version\n(transaction_id, operation_type, "id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_validation_audit)

    public_person_audit = PGFunction(
        schema="public",
        signature="person_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE person_version\n    SET operation_type = 1, "id" = NEW."id", "given_name" = NEW."given_name", "family_name" = NEW."family_name", "sub_id" = NEW."sub_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO person_version\n(transaction_id, operation_type, "id", "given_name", "family_name", "sub_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."given_name", NEW."family_name", NEW."sub_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE person_version\n    SET operation_type = 1, "id" = NEW."id", "given_name" = NEW."given_name", "family_name" = NEW."family_name", "sub_id" = NEW."sub_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO person_version\n(transaction_id, operation_type, "id", "given_name", "family_name", "sub_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."given_name", NEW."family_name", NEW."sub_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE person_version\n    SET "id" = OLD."id", "given_name" = OLD."given_name", "family_name" = OLD."family_name", "sub_id" = OLD."sub_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO person_version\n(transaction_id, operation_type, "id", "given_name", "family_name", "sub_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."given_name", OLD."family_name", OLD."sub_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_person_audit)

    public_datamaturity_annotation_body_audit = PGFunction(
        schema="public",
        signature="datamaturity_annotation_body_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE datamaturity_annotation_body_version\n    SET operation_type = 1, "id" = NEW."id", "pref_label" = NEW."pref_label"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO datamaturity_annotation_body_version\n(transaction_id, operation_type, "id", "pref_label")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."pref_label"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE datamaturity_annotation_body_version\n    SET operation_type = 1, "id" = NEW."id", "pref_label" = NEW."pref_label"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO datamaturity_annotation_body_version\n(transaction_id, operation_type, "id", "pref_label")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."pref_label"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE datamaturity_annotation_body_version\n    SET "id" = OLD."id", "pref_label" = OLD."pref_label"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO datamaturity_annotation_body_version\n(transaction_id, operation_type, "id", "pref_label")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."pref_label"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_datamaturity_annotation_body_audit)

    public_ion_channel_modeling_config_audit = PGFunction(
        schema="public",
        signature="ion_channel_modeling_config_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_modeling_config_version\n    SET operation_type = 1, "id" = NEW."id", "ion_channel_modeling_campaign_id" = NEW."ion_channel_modeling_campaign_id", "scan_parameters" = NEW."scan_parameters", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO ion_channel_modeling_config_version\n(transaction_id, operation_type, "id", "ion_channel_modeling_campaign_id", "scan_parameters", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."ion_channel_modeling_campaign_id", NEW."scan_parameters", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_modeling_config_version\n    SET operation_type = 1, "id" = NEW."id", "ion_channel_modeling_campaign_id" = NEW."ion_channel_modeling_campaign_id", "scan_parameters" = NEW."scan_parameters", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO ion_channel_modeling_config_version\n(transaction_id, operation_type, "id", "ion_channel_modeling_campaign_id", "scan_parameters", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."ion_channel_modeling_campaign_id", NEW."scan_parameters", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_modeling_config_version\n    SET "id" = OLD."id", "ion_channel_modeling_campaign_id" = OLD."ion_channel_modeling_campaign_id", "scan_parameters" = OLD."scan_parameters", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO ion_channel_modeling_config_version\n(transaction_id, operation_type, "id", "ion_channel_modeling_campaign_id", "scan_parameters", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."ion_channel_modeling_campaign_id", OLD."scan_parameters", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_ion_channel_modeling_config_audit)

    public_contribution_audit = PGFunction(
        schema="public",
        signature="contribution_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE contribution_version\n    SET operation_type = 1, "agent_id" = NEW."agent_id", "role_id" = NEW."role_id", "entity_id" = NEW."entity_id", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO contribution_version\n(transaction_id, operation_type, "agent_id", "role_id", "entity_id", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."agent_id", NEW."role_id", NEW."entity_id", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE contribution_version\n    SET operation_type = 1, "agent_id" = NEW."agent_id", "role_id" = NEW."role_id", "entity_id" = NEW."entity_id", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO contribution_version\n(transaction_id, operation_type, "agent_id", "role_id", "entity_id", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."agent_id", NEW."role_id", NEW."entity_id", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE contribution_version\n    SET "agent_id" = OLD."agent_id", "role_id" = OLD."role_id", "entity_id" = OLD."entity_id", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO contribution_version\n(transaction_id, operation_type, "agent_id", "role_id", "entity_id", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."agent_id", OLD."role_id", OLD."entity_id", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_contribution_audit)

    public_skeletonization_campaign_audit = PGFunction(
        schema="public",
        signature="skeletonization_campaign_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE skeletonization_campaign_version\n    SET operation_type = 1, "id" = NEW."id", "scan_parameters" = NEW."scan_parameters", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO skeletonization_campaign_version\n(transaction_id, operation_type, "id", "scan_parameters", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."scan_parameters", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE skeletonization_campaign_version\n    SET operation_type = 1, "id" = NEW."id", "scan_parameters" = NEW."scan_parameters", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO skeletonization_campaign_version\n(transaction_id, operation_type, "id", "scan_parameters", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."scan_parameters", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE skeletonization_campaign_version\n    SET "id" = OLD."id", "scan_parameters" = OLD."scan_parameters", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO skeletonization_campaign_version\n(transaction_id, operation_type, "id", "scan_parameters", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."scan_parameters", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_skeletonization_campaign_audit)

    public_emodel_audit = PGFunction(
        schema="public",
        signature="emodel_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE emodel_version\n    SET operation_type = 1, "id" = NEW."id", "eModel" = NEW."eModel", "eType" = NEW."eType", "iteration" = NEW."iteration", "score" = NEW."score", "seed" = NEW."seed", "exemplar_morphology_id" = NEW."exemplar_morphology_id", "species_id" = NEW."species_id", "strain_id" = NEW."strain_id", "brain_region_id" = NEW."brain_region_id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO emodel_version\n(transaction_id, operation_type, "id", "eModel", "eType", "iteration", "score", "seed", "exemplar_morphology_id", "species_id", "strain_id", "brain_region_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."eModel", NEW."eType", NEW."iteration", NEW."score", NEW."seed", NEW."exemplar_morphology_id", NEW."species_id", NEW."strain_id", NEW."brain_region_id", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE emodel_version\n    SET operation_type = 1, "id" = NEW."id", "eModel" = NEW."eModel", "eType" = NEW."eType", "iteration" = NEW."iteration", "score" = NEW."score", "seed" = NEW."seed", "exemplar_morphology_id" = NEW."exemplar_morphology_id", "species_id" = NEW."species_id", "strain_id" = NEW."strain_id", "brain_region_id" = NEW."brain_region_id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO emodel_version\n(transaction_id, operation_type, "id", "eModel", "eType", "iteration", "score", "seed", "exemplar_morphology_id", "species_id", "strain_id", "brain_region_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."eModel", NEW."eType", NEW."iteration", NEW."score", NEW."seed", NEW."exemplar_morphology_id", NEW."species_id", NEW."strain_id", NEW."brain_region_id", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE emodel_version\n    SET "id" = OLD."id", "eModel" = OLD."eModel", "eType" = OLD."eType", "iteration" = OLD."iteration", "score" = OLD."score", "seed" = OLD."seed", "exemplar_morphology_id" = OLD."exemplar_morphology_id", "species_id" = OLD."species_id", "strain_id" = OLD."strain_id", "brain_region_id" = OLD."brain_region_id", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO emodel_version\n(transaction_id, operation_type, "id", "eModel", "eType", "iteration", "score", "seed", "exemplar_morphology_id", "species_id", "strain_id", "brain_region_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."eModel", OLD."eType", OLD."iteration", OLD."score", OLD."seed", OLD."exemplar_morphology_id", OLD."species_id", OLD."strain_id", OLD."brain_region_id", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_emodel_audit)

    public_brain_atlas_region_audit = PGFunction(
        schema="public",
        signature="brain_atlas_region_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE brain_atlas_region_version\n    SET operation_type = 1, "id" = NEW."id", "volume" = NEW."volume", "is_leaf_region" = NEW."is_leaf_region", "brain_atlas_id" = NEW."brain_atlas_id", "brain_region_id" = NEW."brain_region_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO brain_atlas_region_version\n(transaction_id, operation_type, "id", "volume", "is_leaf_region", "brain_atlas_id", "brain_region_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."volume", NEW."is_leaf_region", NEW."brain_atlas_id", NEW."brain_region_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE brain_atlas_region_version\n    SET operation_type = 1, "id" = NEW."id", "volume" = NEW."volume", "is_leaf_region" = NEW."is_leaf_region", "brain_atlas_id" = NEW."brain_atlas_id", "brain_region_id" = NEW."brain_region_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO brain_atlas_region_version\n(transaction_id, operation_type, "id", "volume", "is_leaf_region", "brain_atlas_id", "brain_region_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."volume", NEW."is_leaf_region", NEW."brain_atlas_id", NEW."brain_region_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE brain_atlas_region_version\n    SET "id" = OLD."id", "volume" = OLD."volume", "is_leaf_region" = OLD."is_leaf_region", "brain_atlas_id" = OLD."brain_atlas_id", "brain_region_id" = OLD."brain_region_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO brain_atlas_region_version\n(transaction_id, operation_type, "id", "volume", "is_leaf_region", "brain_atlas_id", "brain_region_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."volume", OLD."is_leaf_region", OLD."brain_atlas_id", OLD."brain_region_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_brain_atlas_region_audit)

    public_derivation_audit = PGFunction(
        schema="public",
        signature="derivation_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE derivation_version\n    SET operation_type = 1, "used_id" = NEW."used_id", "generated_id" = NEW."generated_id", "derivation_type" = NEW."derivation_type"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "used_id" = NEW."used_id" AND "generated_id" = NEW."generated_id"\n    RETURNING *\n)\nINSERT INTO derivation_version\n(transaction_id, operation_type, "used_id", "generated_id", "derivation_type")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."used_id", NEW."generated_id", NEW."derivation_type"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE derivation_version\n    SET operation_type = 1, "used_id" = NEW."used_id", "generated_id" = NEW."generated_id", "derivation_type" = NEW."derivation_type"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "used_id" = NEW."used_id" AND "generated_id" = NEW."generated_id"\n    RETURNING *\n)\nINSERT INTO derivation_version\n(transaction_id, operation_type, "used_id", "generated_id", "derivation_type")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."used_id", NEW."generated_id", NEW."derivation_type"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE derivation_version\n    SET "used_id" = OLD."used_id", "generated_id" = OLD."generated_id", "derivation_type" = OLD."derivation_type"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "used_id" = OLD."used_id" AND "generated_id" = OLD."generated_id"\n    RETURNING *\n)\nINSERT INTO derivation_version\n(transaction_id, operation_type, "used_id", "generated_id", "derivation_type")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."used_id", OLD."generated_id", OLD."derivation_type"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_derivation_audit)

    public_publication_audit = PGFunction(
        schema="public",
        signature="publication_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE publication_version\n    SET operation_type = 1, "DOI" = NEW."DOI", "title" = NEW."title", "authors" = NEW."authors", "publication_year" = NEW."publication_year", "abstract" = NEW."abstract", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO publication_version\n(transaction_id, operation_type, "DOI", "title", "authors", "publication_year", "abstract", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."DOI", NEW."title", NEW."authors", NEW."publication_year", NEW."abstract", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE publication_version\n    SET operation_type = 1, "DOI" = NEW."DOI", "title" = NEW."title", "authors" = NEW."authors", "publication_year" = NEW."publication_year", "abstract" = NEW."abstract", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO publication_version\n(transaction_id, operation_type, "DOI", "title", "authors", "publication_year", "abstract", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."DOI", NEW."title", NEW."authors", NEW."publication_year", NEW."abstract", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE publication_version\n    SET "DOI" = OLD."DOI", "title" = OLD."title", "authors" = OLD."authors", "publication_year" = OLD."publication_year", "abstract" = OLD."abstract", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO publication_version\n(transaction_id, operation_type, "DOI", "title", "authors", "publication_year", "abstract", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."DOI", OLD."title", OLD."authors", OLD."publication_year", OLD."abstract", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_publication_audit)

    public_electrical_recording_stimulus_audit = PGFunction(
        schema="public",
        signature="electrical_recording_stimulus_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE electrical_recording_stimulus_version\n    SET operation_type = 1, "id" = NEW."id", "dt" = NEW."dt", "injection_type" = NEW."injection_type", "shape" = NEW."shape", "start_time" = NEW."start_time", "end_time" = NEW."end_time", "recording_id" = NEW."recording_id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO electrical_recording_stimulus_version\n(transaction_id, operation_type, "id", "dt", "injection_type", "shape", "start_time", "end_time", "recording_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."dt", NEW."injection_type", NEW."shape", NEW."start_time", NEW."end_time", NEW."recording_id", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE electrical_recording_stimulus_version\n    SET operation_type = 1, "id" = NEW."id", "dt" = NEW."dt", "injection_type" = NEW."injection_type", "shape" = NEW."shape", "start_time" = NEW."start_time", "end_time" = NEW."end_time", "recording_id" = NEW."recording_id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO electrical_recording_stimulus_version\n(transaction_id, operation_type, "id", "dt", "injection_type", "shape", "start_time", "end_time", "recording_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."dt", NEW."injection_type", NEW."shape", NEW."start_time", NEW."end_time", NEW."recording_id", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE electrical_recording_stimulus_version\n    SET "id" = OLD."id", "dt" = OLD."dt", "injection_type" = OLD."injection_type", "shape" = OLD."shape", "start_time" = OLD."start_time", "end_time" = OLD."end_time", "recording_id" = OLD."recording_id", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO electrical_recording_stimulus_version\n(transaction_id, operation_type, "id", "dt", "injection_type", "shape", "start_time", "end_time", "recording_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."dt", OLD."injection_type", OLD."shape", OLD."start_time", OLD."end_time", OLD."recording_id", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_electrical_recording_stimulus_audit)

    public_single_neuron_synaptome_simulation_audit = PGFunction(
        schema="public",
        signature="single_neuron_synaptome_simulation_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE single_neuron_synaptome_simulation_version\n    SET operation_type = 1, "id" = NEW."id", "seed" = NEW."seed", "injection_location" = NEW."injection_location", "recording_location" = NEW."recording_location", "status" = NEW."status", "synaptome_id" = NEW."synaptome_id", "brain_region_id" = NEW."brain_region_id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO single_neuron_synaptome_simulation_version\n(transaction_id, operation_type, "id", "seed", "injection_location", "recording_location", "status", "synaptome_id", "brain_region_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."seed", NEW."injection_location", NEW."recording_location", NEW."status", NEW."synaptome_id", NEW."brain_region_id", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE single_neuron_synaptome_simulation_version\n    SET operation_type = 1, "id" = NEW."id", "seed" = NEW."seed", "injection_location" = NEW."injection_location", "recording_location" = NEW."recording_location", "status" = NEW."status", "synaptome_id" = NEW."synaptome_id", "brain_region_id" = NEW."brain_region_id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO single_neuron_synaptome_simulation_version\n(transaction_id, operation_type, "id", "seed", "injection_location", "recording_location", "status", "synaptome_id", "brain_region_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."seed", NEW."injection_location", NEW."recording_location", NEW."status", NEW."synaptome_id", NEW."brain_region_id", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE single_neuron_synaptome_simulation_version\n    SET "id" = OLD."id", "seed" = OLD."seed", "injection_location" = OLD."injection_location", "recording_location" = OLD."recording_location", "status" = OLD."status", "synaptome_id" = OLD."synaptome_id", "brain_region_id" = OLD."brain_region_id", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO single_neuron_synaptome_simulation_version\n(transaction_id, operation_type, "id", "seed", "injection_location", "recording_location", "status", "synaptome_id", "brain_region_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."seed", OLD."injection_location", OLD."recording_location", OLD."status", OLD."synaptome_id", OLD."brain_region_id", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_single_neuron_synaptome_simulation_audit)

    public_subject_audit = PGFunction(
        schema="public",
        signature="subject_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE subject_version\n    SET operation_type = 1, "id" = NEW."id", "age_value" = NEW."age_value", "age_min" = NEW."age_min", "age_max" = NEW."age_max", "age_period" = NEW."age_period", "sex" = NEW."sex", "weight" = NEW."weight", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector", "species_id" = NEW."species_id", "strain_id" = NEW."strain_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO subject_version\n(transaction_id, operation_type, "id", "age_value", "age_min", "age_max", "age_period", "sex", "weight", "name", "description", "description_vector", "species_id", "strain_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."age_value", NEW."age_min", NEW."age_max", NEW."age_period", NEW."sex", NEW."weight", NEW."name", NEW."description", NEW."description_vector", NEW."species_id", NEW."strain_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE subject_version\n    SET operation_type = 1, "id" = NEW."id", "age_value" = NEW."age_value", "age_min" = NEW."age_min", "age_max" = NEW."age_max", "age_period" = NEW."age_period", "sex" = NEW."sex", "weight" = NEW."weight", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector", "species_id" = NEW."species_id", "strain_id" = NEW."strain_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO subject_version\n(transaction_id, operation_type, "id", "age_value", "age_min", "age_max", "age_period", "sex", "weight", "name", "description", "description_vector", "species_id", "strain_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."age_value", NEW."age_min", NEW."age_max", NEW."age_period", NEW."sex", NEW."weight", NEW."name", NEW."description", NEW."description_vector", NEW."species_id", NEW."strain_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE subject_version\n    SET "id" = OLD."id", "age_value" = OLD."age_value", "age_min" = OLD."age_min", "age_max" = OLD."age_max", "age_period" = OLD."age_period", "sex" = OLD."sex", "weight" = OLD."weight", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector", "species_id" = OLD."species_id", "strain_id" = OLD."strain_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO subject_version\n(transaction_id, operation_type, "id", "age_value", "age_min", "age_max", "age_period", "sex", "weight", "name", "description", "description_vector", "species_id", "strain_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."age_value", OLD."age_min", OLD."age_max", OLD."age_period", OLD."sex", OLD."weight", OLD."name", OLD."description", OLD."description_vector", OLD."species_id", OLD."strain_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_subject_audit)

    public_consortium_audit = PGFunction(
        schema="public",
        signature="consortium_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE consortium_version\n    SET operation_type = 1, "id" = NEW."id", "alternative_name" = NEW."alternative_name"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO consortium_version\n(transaction_id, operation_type, "id", "alternative_name")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."alternative_name"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE consortium_version\n    SET operation_type = 1, "id" = NEW."id", "alternative_name" = NEW."alternative_name"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO consortium_version\n(transaction_id, operation_type, "id", "alternative_name")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."alternative_name"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE consortium_version\n    SET "id" = OLD."id", "alternative_name" = OLD."alternative_name"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO consortium_version\n(transaction_id, operation_type, "id", "alternative_name")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."alternative_name"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_consortium_audit)

    public_ion_channel_recording_audit = PGFunction(
        schema="public",
        signature="ion_channel_recording_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_recording_version\n    SET operation_type = 1, "id" = NEW."id", "cell_line" = NEW."cell_line", "ion_channel_id" = NEW."ion_channel_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO ion_channel_recording_version\n(transaction_id, operation_type, "id", "cell_line", "ion_channel_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."cell_line", NEW."ion_channel_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_recording_version\n    SET operation_type = 1, "id" = NEW."id", "cell_line" = NEW."cell_line", "ion_channel_id" = NEW."ion_channel_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO ion_channel_recording_version\n(transaction_id, operation_type, "id", "cell_line", "ion_channel_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."cell_line", NEW."ion_channel_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_recording_version\n    SET "id" = OLD."id", "cell_line" = OLD."cell_line", "ion_channel_id" = OLD."ion_channel_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO ion_channel_recording_version\n(transaction_id, operation_type, "id", "cell_line", "ion_channel_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."cell_line", OLD."ion_channel_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_ion_channel_recording_audit)

    public_analysis_notebook_execution_audit = PGFunction(
        schema="public",
        signature="analysis_notebook_execution_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE analysis_notebook_execution_version\n    SET operation_type = 1, "id" = NEW."id", "analysis_notebook_template_id" = NEW."analysis_notebook_template_id", "analysis_notebook_environment_id" = NEW."analysis_notebook_environment_id", "executor" = NEW."executor", "execution_id" = NEW."execution_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO analysis_notebook_execution_version\n(transaction_id, operation_type, "id", "analysis_notebook_template_id", "analysis_notebook_environment_id", "executor", "execution_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."analysis_notebook_template_id", NEW."analysis_notebook_environment_id", NEW."executor", NEW."execution_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE analysis_notebook_execution_version\n    SET operation_type = 1, "id" = NEW."id", "analysis_notebook_template_id" = NEW."analysis_notebook_template_id", "analysis_notebook_environment_id" = NEW."analysis_notebook_environment_id", "executor" = NEW."executor", "execution_id" = NEW."execution_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO analysis_notebook_execution_version\n(transaction_id, operation_type, "id", "analysis_notebook_template_id", "analysis_notebook_environment_id", "executor", "execution_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."analysis_notebook_template_id", NEW."analysis_notebook_environment_id", NEW."executor", NEW."execution_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE analysis_notebook_execution_version\n    SET "id" = OLD."id", "analysis_notebook_template_id" = OLD."analysis_notebook_template_id", "analysis_notebook_environment_id" = OLD."analysis_notebook_environment_id", "executor" = OLD."executor", "execution_id" = OLD."execution_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO analysis_notebook_execution_version\n(transaction_id, operation_type, "id", "analysis_notebook_template_id", "analysis_notebook_environment_id", "executor", "execution_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."analysis_notebook_template_id", OLD."analysis_notebook_environment_id", OLD."executor", OLD."execution_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_analysis_notebook_execution_audit)

    public_single_neuron_simulation_audit = PGFunction(
        schema="public",
        signature="single_neuron_simulation_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE single_neuron_simulation_version\n    SET operation_type = 1, "id" = NEW."id", "seed" = NEW."seed", "injection_location" = NEW."injection_location", "recording_location" = NEW."recording_location", "status" = NEW."status", "me_model_id" = NEW."me_model_id", "brain_region_id" = NEW."brain_region_id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO single_neuron_simulation_version\n(transaction_id, operation_type, "id", "seed", "injection_location", "recording_location", "status", "me_model_id", "brain_region_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."seed", NEW."injection_location", NEW."recording_location", NEW."status", NEW."me_model_id", NEW."brain_region_id", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE single_neuron_simulation_version\n    SET operation_type = 1, "id" = NEW."id", "seed" = NEW."seed", "injection_location" = NEW."injection_location", "recording_location" = NEW."recording_location", "status" = NEW."status", "me_model_id" = NEW."me_model_id", "brain_region_id" = NEW."brain_region_id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO single_neuron_simulation_version\n(transaction_id, operation_type, "id", "seed", "injection_location", "recording_location", "status", "me_model_id", "brain_region_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."seed", NEW."injection_location", NEW."recording_location", NEW."status", NEW."me_model_id", NEW."brain_region_id", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE single_neuron_simulation_version\n    SET "id" = OLD."id", "seed" = OLD."seed", "injection_location" = OLD."injection_location", "recording_location" = OLD."recording_location", "status" = OLD."status", "me_model_id" = OLD."me_model_id", "brain_region_id" = OLD."brain_region_id", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO single_neuron_simulation_version\n(transaction_id, operation_type, "id", "seed", "injection_location", "recording_location", "status", "me_model_id", "brain_region_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."seed", OLD."injection_location", OLD."recording_location", OLD."status", OLD."me_model_id", OLD."brain_region_id", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_single_neuron_simulation_audit)

    public_analysis_notebook_template_audit = PGFunction(
        schema="public",
        signature="analysis_notebook_template_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE analysis_notebook_template_version\n    SET operation_type = 1, "id" = NEW."id", "scale" = NEW."scale", "specifications" = NEW."specifications", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO analysis_notebook_template_version\n(transaction_id, operation_type, "id", "scale", "specifications", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."scale", NEW."specifications", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE analysis_notebook_template_version\n    SET operation_type = 1, "id" = NEW."id", "scale" = NEW."scale", "specifications" = NEW."specifications", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO analysis_notebook_template_version\n(transaction_id, operation_type, "id", "scale", "specifications", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."scale", NEW."specifications", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE analysis_notebook_template_version\n    SET "id" = OLD."id", "scale" = OLD."scale", "specifications" = OLD."specifications", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO analysis_notebook_template_version\n(transaction_id, operation_type, "id", "scale", "specifications", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."scale", OLD."specifications", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_analysis_notebook_template_audit)

    public_analysis_notebook_result_audit = PGFunction(
        schema="public",
        signature="analysis_notebook_result_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE analysis_notebook_result_version\n    SET operation_type = 1, "id" = NEW."id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO analysis_notebook_result_version\n(transaction_id, operation_type, "id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE analysis_notebook_result_version\n    SET operation_type = 1, "id" = NEW."id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO analysis_notebook_result_version\n(transaction_id, operation_type, "id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE analysis_notebook_result_version\n    SET "id" = OLD."id", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO analysis_notebook_result_version\n(transaction_id, operation_type, "id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_analysis_notebook_result_audit)

    public_brain_region_hierarchy_audit = PGFunction(
        schema="public",
        signature="brain_region_hierarchy_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE brain_region_hierarchy_version\n    SET operation_type = 1, "name" = NEW."name", "species_id" = NEW."species_id", "strain_id" = NEW."strain_id", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO brain_region_hierarchy_version\n(transaction_id, operation_type, "name", "species_id", "strain_id", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."name", NEW."species_id", NEW."strain_id", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE brain_region_hierarchy_version\n    SET operation_type = 1, "name" = NEW."name", "species_id" = NEW."species_id", "strain_id" = NEW."strain_id", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO brain_region_hierarchy_version\n(transaction_id, operation_type, "name", "species_id", "strain_id", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."name", NEW."species_id", NEW."strain_id", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE brain_region_hierarchy_version\n    SET "name" = OLD."name", "species_id" = OLD."species_id", "strain_id" = OLD."strain_id", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO brain_region_hierarchy_version\n(transaction_id, operation_type, "name", "species_id", "strain_id", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."name", OLD."species_id", OLD."strain_id", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_brain_region_hierarchy_audit)

    public_strain_audit = PGFunction(
        schema="public",
        signature="strain_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE strain_version\n    SET operation_type = 1, "name" = NEW."name", "taxonomy_id" = NEW."taxonomy_id", "species_id" = NEW."species_id", "embedding" = NEW."embedding", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO strain_version\n(transaction_id, operation_type, "name", "taxonomy_id", "species_id", "embedding", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."name", NEW."taxonomy_id", NEW."species_id", NEW."embedding", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE strain_version\n    SET operation_type = 1, "name" = NEW."name", "taxonomy_id" = NEW."taxonomy_id", "species_id" = NEW."species_id", "embedding" = NEW."embedding", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO strain_version\n(transaction_id, operation_type, "name", "taxonomy_id", "species_id", "embedding", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."name", NEW."taxonomy_id", NEW."species_id", NEW."embedding", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE strain_version\n    SET "name" = OLD."name", "taxonomy_id" = OLD."taxonomy_id", "species_id" = OLD."species_id", "embedding" = OLD."embedding", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO strain_version\n(transaction_id, operation_type, "name", "taxonomy_id", "species_id", "embedding", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."name", OLD."taxonomy_id", OLD."species_id", OLD."embedding", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_strain_audit)

    public_ion_audit = PGFunction(
        schema="public",
        signature="ion_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE ion_version\n    SET operation_type = 1, "id" = NEW."id", "name" = NEW."name", "ontology_id" = NEW."ontology_id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO ion_version\n(transaction_id, operation_type, "id", "name", "ontology_id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."name", NEW."ontology_id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE ion_version\n    SET operation_type = 1, "id" = NEW."id", "name" = NEW."name", "ontology_id" = NEW."ontology_id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO ion_version\n(transaction_id, operation_type, "id", "name", "ontology_id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."name", NEW."ontology_id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE ion_version\n    SET "id" = OLD."id", "name" = OLD."name", "ontology_id" = OLD."ontology_id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO ion_version\n(transaction_id, operation_type, "id", "name", "ontology_id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."name", OLD."ontology_id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_ion_audit)

    public_validation_result_audit = PGFunction(
        schema="public",
        signature="validation_result_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE validation_result_version\n    SET operation_type = 1, "id" = NEW."id", "passed" = NEW."passed", "name" = NEW."name", "validated_entity_id" = NEW."validated_entity_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO validation_result_version\n(transaction_id, operation_type, "id", "passed", "name", "validated_entity_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."passed", NEW."name", NEW."validated_entity_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE validation_result_version\n    SET operation_type = 1, "id" = NEW."id", "passed" = NEW."passed", "name" = NEW."name", "validated_entity_id" = NEW."validated_entity_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO validation_result_version\n(transaction_id, operation_type, "id", "passed", "name", "validated_entity_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."passed", NEW."name", NEW."validated_entity_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE validation_result_version\n    SET "id" = OLD."id", "passed" = OLD."passed", "name" = OLD."name", "validated_entity_id" = OLD."validated_entity_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO validation_result_version\n(transaction_id, operation_type, "id", "passed", "name", "validated_entity_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."passed", OLD."name", OLD."validated_entity_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_validation_result_audit)

    public_circuit_extraction_config_generation_audit = PGFunction(
        schema="public",
        signature="circuit_extraction_config_generation_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE circuit_extraction_config_generation_version\n    SET operation_type = 1, "id" = NEW."id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO circuit_extraction_config_generation_version\n(transaction_id, operation_type, "id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE circuit_extraction_config_generation_version\n    SET operation_type = 1, "id" = NEW."id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO circuit_extraction_config_generation_version\n(transaction_id, operation_type, "id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE circuit_extraction_config_generation_version\n    SET "id" = OLD."id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO circuit_extraction_config_generation_version\n(transaction_id, operation_type, "id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_circuit_extraction_config_generation_audit)

    public_electrical_recording_audit = PGFunction(
        schema="public",
        signature="electrical_recording_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE electrical_recording_version\n    SET operation_type = 1, "id" = NEW."id", "recording_type" = NEW."recording_type", "recording_origin" = NEW."recording_origin", "recording_location" = NEW."recording_location", "ljp" = NEW."ljp", "temperature" = NEW."temperature", "comment" = NEW."comment", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO electrical_recording_version\n(transaction_id, operation_type, "id", "recording_type", "recording_origin", "recording_location", "ljp", "temperature", "comment", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."recording_type", NEW."recording_origin", NEW."recording_location", NEW."ljp", NEW."temperature", NEW."comment", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE electrical_recording_version\n    SET operation_type = 1, "id" = NEW."id", "recording_type" = NEW."recording_type", "recording_origin" = NEW."recording_origin", "recording_location" = NEW."recording_location", "ljp" = NEW."ljp", "temperature" = NEW."temperature", "comment" = NEW."comment", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO electrical_recording_version\n(transaction_id, operation_type, "id", "recording_type", "recording_origin", "recording_location", "ljp", "temperature", "comment", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."recording_type", NEW."recording_origin", NEW."recording_location", NEW."ljp", NEW."temperature", NEW."comment", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE electrical_recording_version\n    SET "id" = OLD."id", "recording_type" = OLD."recording_type", "recording_origin" = OLD."recording_origin", "recording_location" = OLD."recording_location", "ljp" = OLD."ljp", "temperature" = OLD."temperature", "comment" = OLD."comment", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO electrical_recording_version\n(transaction_id, operation_type, "id", "recording_type", "recording_origin", "recording_location", "ljp", "temperature", "comment", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."recording_type", OLD."recording_origin", OLD."recording_location", OLD."ljp", OLD."temperature", OLD."comment", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_electrical_recording_audit)

    public_em_cell_mesh_audit = PGFunction(
        schema="public",
        signature="em_cell_mesh_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE em_cell_mesh_version\n    SET operation_type = 1, "id" = NEW."id", "em_dense_reconstruction_dataset_id" = NEW."em_dense_reconstruction_dataset_id", "release_version" = NEW."release_version", "dense_reconstruction_cell_id" = NEW."dense_reconstruction_cell_id", "generation_method" = NEW."generation_method", "level_of_detail" = NEW."level_of_detail", "generation_parameters" = NEW."generation_parameters", "mesh_type" = NEW."mesh_type"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO em_cell_mesh_version\n(transaction_id, operation_type, "id", "em_dense_reconstruction_dataset_id", "release_version", "dense_reconstruction_cell_id", "generation_method", "level_of_detail", "generation_parameters", "mesh_type")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."em_dense_reconstruction_dataset_id", NEW."release_version", NEW."dense_reconstruction_cell_id", NEW."generation_method", NEW."level_of_detail", NEW."generation_parameters", NEW."mesh_type"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE em_cell_mesh_version\n    SET operation_type = 1, "id" = NEW."id", "em_dense_reconstruction_dataset_id" = NEW."em_dense_reconstruction_dataset_id", "release_version" = NEW."release_version", "dense_reconstruction_cell_id" = NEW."dense_reconstruction_cell_id", "generation_method" = NEW."generation_method", "level_of_detail" = NEW."level_of_detail", "generation_parameters" = NEW."generation_parameters", "mesh_type" = NEW."mesh_type"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO em_cell_mesh_version\n(transaction_id, operation_type, "id", "em_dense_reconstruction_dataset_id", "release_version", "dense_reconstruction_cell_id", "generation_method", "level_of_detail", "generation_parameters", "mesh_type")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."em_dense_reconstruction_dataset_id", NEW."release_version", NEW."dense_reconstruction_cell_id", NEW."generation_method", NEW."level_of_detail", NEW."generation_parameters", NEW."mesh_type"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE em_cell_mesh_version\n    SET "id" = OLD."id", "em_dense_reconstruction_dataset_id" = OLD."em_dense_reconstruction_dataset_id", "release_version" = OLD."release_version", "dense_reconstruction_cell_id" = OLD."dense_reconstruction_cell_id", "generation_method" = OLD."generation_method", "level_of_detail" = OLD."level_of_detail", "generation_parameters" = OLD."generation_parameters", "mesh_type" = OLD."mesh_type"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO em_cell_mesh_version\n(transaction_id, operation_type, "id", "em_dense_reconstruction_dataset_id", "release_version", "dense_reconstruction_cell_id", "generation_method", "level_of_detail", "generation_parameters", "mesh_type")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."em_dense_reconstruction_dataset_id", OLD."release_version", OLD."dense_reconstruction_cell_id", OLD."generation_method", OLD."level_of_detail", OLD."generation_parameters", OLD."mesh_type"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_em_cell_mesh_audit)

    public_memodel_audit = PGFunction(
        schema="public",
        signature="memodel_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE memodel_version\n    SET operation_type = 1, "id" = NEW."id", "validation_status" = NEW."validation_status", "morphology_id" = NEW."morphology_id", "emodel_id" = NEW."emodel_id", "species_id" = NEW."species_id", "strain_id" = NEW."strain_id", "brain_region_id" = NEW."brain_region_id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO memodel_version\n(transaction_id, operation_type, "id", "validation_status", "morphology_id", "emodel_id", "species_id", "strain_id", "brain_region_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."validation_status", NEW."morphology_id", NEW."emodel_id", NEW."species_id", NEW."strain_id", NEW."brain_region_id", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE memodel_version\n    SET operation_type = 1, "id" = NEW."id", "validation_status" = NEW."validation_status", "morphology_id" = NEW."morphology_id", "emodel_id" = NEW."emodel_id", "species_id" = NEW."species_id", "strain_id" = NEW."strain_id", "brain_region_id" = NEW."brain_region_id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO memodel_version\n(transaction_id, operation_type, "id", "validation_status", "morphology_id", "emodel_id", "species_id", "strain_id", "brain_region_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."validation_status", NEW."morphology_id", NEW."emodel_id", NEW."species_id", NEW."strain_id", NEW."brain_region_id", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE memodel_version\n    SET "id" = OLD."id", "validation_status" = OLD."validation_status", "morphology_id" = OLD."morphology_id", "emodel_id" = OLD."emodel_id", "species_id" = OLD."species_id", "strain_id" = OLD."strain_id", "brain_region_id" = OLD."brain_region_id", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO memodel_version\n(transaction_id, operation_type, "id", "validation_status", "morphology_id", "emodel_id", "species_id", "strain_id", "brain_region_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."validation_status", OLD."morphology_id", OLD."emodel_id", OLD."species_id", OLD."strain_id", OLD."brain_region_id", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_memodel_audit)

    public_ion_channel_modeling_config_generation_audit = PGFunction(
        schema="public",
        signature="ion_channel_modeling_config_generation_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_modeling_config_generation_version\n    SET operation_type = 1, "id" = NEW."id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO ion_channel_modeling_config_generation_version\n(transaction_id, operation_type, "id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_modeling_config_generation_version\n    SET operation_type = 1, "id" = NEW."id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO ion_channel_modeling_config_generation_version\n(transaction_id, operation_type, "id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_modeling_config_generation_version\n    SET "id" = OLD."id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO ion_channel_modeling_config_generation_version\n(transaction_id, operation_type, "id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_ion_channel_modeling_config_generation_audit)

    public_single_neuron_synaptome_audit = PGFunction(
        schema="public",
        signature="single_neuron_synaptome_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE single_neuron_synaptome_version\n    SET operation_type = 1, "id" = NEW."id", "seed" = NEW."seed", "me_model_id" = NEW."me_model_id", "brain_region_id" = NEW."brain_region_id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO single_neuron_synaptome_version\n(transaction_id, operation_type, "id", "seed", "me_model_id", "brain_region_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."seed", NEW."me_model_id", NEW."brain_region_id", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE single_neuron_synaptome_version\n    SET operation_type = 1, "id" = NEW."id", "seed" = NEW."seed", "me_model_id" = NEW."me_model_id", "brain_region_id" = NEW."brain_region_id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO single_neuron_synaptome_version\n(transaction_id, operation_type, "id", "seed", "me_model_id", "brain_region_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."seed", NEW."me_model_id", NEW."brain_region_id", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE single_neuron_synaptome_version\n    SET "id" = OLD."id", "seed" = OLD."seed", "me_model_id" = OLD."me_model_id", "brain_region_id" = OLD."brain_region_id", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO single_neuron_synaptome_version\n(transaction_id, operation_type, "id", "seed", "me_model_id", "brain_region_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."seed", OLD."me_model_id", OLD."brain_region_id", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_single_neuron_synaptome_audit)

    public_activity_audit = PGFunction(
        schema="public",
        signature="activity_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE activity_version\n    SET operation_type = 1, "authorized_project_id" = NEW."authorized_project_id", "authorized_public" = NEW."authorized_public", "type" = NEW."type", "start_time" = NEW."start_time", "end_time" = NEW."end_time", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO activity_version\n(transaction_id, operation_type, "authorized_project_id", "authorized_public", "type", "start_time", "end_time", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."authorized_project_id", NEW."authorized_public", NEW."type", NEW."start_time", NEW."end_time", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE activity_version\n    SET operation_type = 1, "authorized_project_id" = NEW."authorized_project_id", "authorized_public" = NEW."authorized_public", "type" = NEW."type", "start_time" = NEW."start_time", "end_time" = NEW."end_time", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO activity_version\n(transaction_id, operation_type, "authorized_project_id", "authorized_public", "type", "start_time", "end_time", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."authorized_project_id", NEW."authorized_public", NEW."type", NEW."start_time", NEW."end_time", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE activity_version\n    SET "authorized_project_id" = OLD."authorized_project_id", "authorized_public" = OLD."authorized_public", "type" = OLD."type", "start_time" = OLD."start_time", "end_time" = OLD."end_time", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO activity_version\n(transaction_id, operation_type, "authorized_project_id", "authorized_public", "type", "start_time", "end_time", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."authorized_project_id", OLD."authorized_public", OLD."type", OLD."start_time", OLD."end_time", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_activity_audit)

    public_brain_atlas_audit = PGFunction(
        schema="public",
        signature="brain_atlas_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE brain_atlas_version\n    SET operation_type = 1, "id" = NEW."id", "hierarchy_id" = NEW."hierarchy_id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector", "species_id" = NEW."species_id", "strain_id" = NEW."strain_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO brain_atlas_version\n(transaction_id, operation_type, "id", "hierarchy_id", "name", "description", "description_vector", "species_id", "strain_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."hierarchy_id", NEW."name", NEW."description", NEW."description_vector", NEW."species_id", NEW."strain_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE brain_atlas_version\n    SET operation_type = 1, "id" = NEW."id", "hierarchy_id" = NEW."hierarchy_id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector", "species_id" = NEW."species_id", "strain_id" = NEW."strain_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO brain_atlas_version\n(transaction_id, operation_type, "id", "hierarchy_id", "name", "description", "description_vector", "species_id", "strain_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."hierarchy_id", NEW."name", NEW."description", NEW."description_vector", NEW."species_id", NEW."strain_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE brain_atlas_version\n    SET "id" = OLD."id", "hierarchy_id" = OLD."hierarchy_id", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector", "species_id" = OLD."species_id", "strain_id" = OLD."strain_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO brain_atlas_version\n(transaction_id, operation_type, "id", "hierarchy_id", "name", "description", "description_vector", "species_id", "strain_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."hierarchy_id", OLD."name", OLD."description", OLD."description_vector", OLD."species_id", OLD."strain_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_brain_atlas_audit)

    public_entity_audit = PGFunction(
        schema="public",
        signature="entity_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE entity_version\n    SET operation_type = 1, "type" = NEW."type", "authorized_project_id" = NEW."authorized_project_id", "authorized_public" = NEW."authorized_public", "legacy_id" = NEW."legacy_id", "legacy_self" = NEW."legacy_self", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO entity_version\n(transaction_id, operation_type, "type", "authorized_project_id", "authorized_public", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."type", NEW."authorized_project_id", NEW."authorized_public", NEW."legacy_id", NEW."legacy_self", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE entity_version\n    SET operation_type = 1, "type" = NEW."type", "authorized_project_id" = NEW."authorized_project_id", "authorized_public" = NEW."authorized_public", "legacy_id" = NEW."legacy_id", "legacy_self" = NEW."legacy_self", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO entity_version\n(transaction_id, operation_type, "type", "authorized_project_id", "authorized_public", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."type", NEW."authorized_project_id", NEW."authorized_public", NEW."legacy_id", NEW."legacy_self", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE entity_version\n    SET "type" = OLD."type", "authorized_project_id" = OLD."authorized_project_id", "authorized_public" = OLD."authorized_public", "legacy_id" = OLD."legacy_id", "legacy_self" = OLD."legacy_self", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO entity_version\n(transaction_id, operation_type, "type", "authorized_project_id", "authorized_public", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."type", OLD."authorized_project_id", OLD."authorized_public", OLD."legacy_id", OLD."legacy_self", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_entity_audit)

    public_ion_channel_modeling_campaign_audit = PGFunction(
        schema="public",
        signature="ion_channel_modeling_campaign_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_modeling_campaign_version\n    SET operation_type = 1, "id" = NEW."id", "scan_parameters" = NEW."scan_parameters", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO ion_channel_modeling_campaign_version\n(transaction_id, operation_type, "id", "scan_parameters", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."scan_parameters", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_modeling_campaign_version\n    SET operation_type = 1, "id" = NEW."id", "scan_parameters" = NEW."scan_parameters", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO ion_channel_modeling_campaign_version\n(transaction_id, operation_type, "id", "scan_parameters", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."scan_parameters", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_modeling_campaign_version\n    SET "id" = OLD."id", "scan_parameters" = OLD."scan_parameters", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO ion_channel_modeling_campaign_version\n(transaction_id, operation_type, "id", "scan_parameters", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."scan_parameters", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_ion_channel_modeling_campaign_audit)

    public_em_dense_reconstruction_dataset_audit = PGFunction(
        schema="public",
        signature="em_dense_reconstruction_dataset_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE em_dense_reconstruction_dataset_version\n    SET operation_type = 1, "id" = NEW."id", "protocol_document" = NEW."protocol_document", "fixation" = NEW."fixation", "staining_type" = NEW."staining_type", "slicing_thickness" = NEW."slicing_thickness", "tissue_shrinkage" = NEW."tissue_shrinkage", "microscope_type" = NEW."microscope_type", "detector" = NEW."detector", "slicing_direction" = NEW."slicing_direction", "landmarks" = NEW."landmarks", "voltage" = NEW."voltage", "current" = NEW."current", "dose" = NEW."dose", "temperature" = NEW."temperature", "volume_resolution_x_nm" = NEW."volume_resolution_x_nm", "volume_resolution_y_nm" = NEW."volume_resolution_y_nm", "volume_resolution_z_nm" = NEW."volume_resolution_z_nm", "release_url" = NEW."release_url", "cave_client_url" = NEW."cave_client_url", "cave_datastack" = NEW."cave_datastack", "precomputed_mesh_url" = NEW."precomputed_mesh_url", "cell_identifying_property" = NEW."cell_identifying_property", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO em_dense_reconstruction_dataset_version\n(transaction_id, operation_type, "id", "protocol_document", "fixation", "staining_type", "slicing_thickness", "tissue_shrinkage", "microscope_type", "detector", "slicing_direction", "landmarks", "voltage", "current", "dose", "temperature", "volume_resolution_x_nm", "volume_resolution_y_nm", "volume_resolution_z_nm", "release_url", "cave_client_url", "cave_datastack", "precomputed_mesh_url", "cell_identifying_property", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."protocol_document", NEW."fixation", NEW."staining_type", NEW."slicing_thickness", NEW."tissue_shrinkage", NEW."microscope_type", NEW."detector", NEW."slicing_direction", NEW."landmarks", NEW."voltage", NEW."current", NEW."dose", NEW."temperature", NEW."volume_resolution_x_nm", NEW."volume_resolution_y_nm", NEW."volume_resolution_z_nm", NEW."release_url", NEW."cave_client_url", NEW."cave_datastack", NEW."precomputed_mesh_url", NEW."cell_identifying_property", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE em_dense_reconstruction_dataset_version\n    SET operation_type = 1, "id" = NEW."id", "protocol_document" = NEW."protocol_document", "fixation" = NEW."fixation", "staining_type" = NEW."staining_type", "slicing_thickness" = NEW."slicing_thickness", "tissue_shrinkage" = NEW."tissue_shrinkage", "microscope_type" = NEW."microscope_type", "detector" = NEW."detector", "slicing_direction" = NEW."slicing_direction", "landmarks" = NEW."landmarks", "voltage" = NEW."voltage", "current" = NEW."current", "dose" = NEW."dose", "temperature" = NEW."temperature", "volume_resolution_x_nm" = NEW."volume_resolution_x_nm", "volume_resolution_y_nm" = NEW."volume_resolution_y_nm", "volume_resolution_z_nm" = NEW."volume_resolution_z_nm", "release_url" = NEW."release_url", "cave_client_url" = NEW."cave_client_url", "cave_datastack" = NEW."cave_datastack", "precomputed_mesh_url" = NEW."precomputed_mesh_url", "cell_identifying_property" = NEW."cell_identifying_property", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO em_dense_reconstruction_dataset_version\n(transaction_id, operation_type, "id", "protocol_document", "fixation", "staining_type", "slicing_thickness", "tissue_shrinkage", "microscope_type", "detector", "slicing_direction", "landmarks", "voltage", "current", "dose", "temperature", "volume_resolution_x_nm", "volume_resolution_y_nm", "volume_resolution_z_nm", "release_url", "cave_client_url", "cave_datastack", "precomputed_mesh_url", "cell_identifying_property", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."protocol_document", NEW."fixation", NEW."staining_type", NEW."slicing_thickness", NEW."tissue_shrinkage", NEW."microscope_type", NEW."detector", NEW."slicing_direction", NEW."landmarks", NEW."voltage", NEW."current", NEW."dose", NEW."temperature", NEW."volume_resolution_x_nm", NEW."volume_resolution_y_nm", NEW."volume_resolution_z_nm", NEW."release_url", NEW."cave_client_url", NEW."cave_datastack", NEW."precomputed_mesh_url", NEW."cell_identifying_property", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE em_dense_reconstruction_dataset_version\n    SET "id" = OLD."id", "protocol_document" = OLD."protocol_document", "fixation" = OLD."fixation", "staining_type" = OLD."staining_type", "slicing_thickness" = OLD."slicing_thickness", "tissue_shrinkage" = OLD."tissue_shrinkage", "microscope_type" = OLD."microscope_type", "detector" = OLD."detector", "slicing_direction" = OLD."slicing_direction", "landmarks" = OLD."landmarks", "voltage" = OLD."voltage", "current" = OLD."current", "dose" = OLD."dose", "temperature" = OLD."temperature", "volume_resolution_x_nm" = OLD."volume_resolution_x_nm", "volume_resolution_y_nm" = OLD."volume_resolution_y_nm", "volume_resolution_z_nm" = OLD."volume_resolution_z_nm", "release_url" = OLD."release_url", "cave_client_url" = OLD."cave_client_url", "cave_datastack" = OLD."cave_datastack", "precomputed_mesh_url" = OLD."precomputed_mesh_url", "cell_identifying_property" = OLD."cell_identifying_property", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO em_dense_reconstruction_dataset_version\n(transaction_id, operation_type, "id", "protocol_document", "fixation", "staining_type", "slicing_thickness", "tissue_shrinkage", "microscope_type", "detector", "slicing_direction", "landmarks", "voltage", "current", "dose", "temperature", "volume_resolution_x_nm", "volume_resolution_y_nm", "volume_resolution_z_nm", "release_url", "cave_client_url", "cave_datastack", "precomputed_mesh_url", "cell_identifying_property", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."protocol_document", OLD."fixation", OLD."staining_type", OLD."slicing_thickness", OLD."tissue_shrinkage", OLD."microscope_type", OLD."detector", OLD."slicing_direction", OLD."landmarks", OLD."voltage", OLD."current", OLD."dose", OLD."temperature", OLD."volume_resolution_x_nm", OLD."volume_resolution_y_nm", OLD."volume_resolution_z_nm", OLD."release_url", OLD."cave_client_url", OLD."cave_datastack", OLD."precomputed_mesh_url", OLD."cell_identifying_property", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_em_dense_reconstruction_dataset_audit)

    public_electrical_cell_recording_audit = PGFunction(
        schema="public",
        signature="electrical_cell_recording_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE electrical_cell_recording_version\n    SET operation_type = 1, "id" = NEW."id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO electrical_cell_recording_version\n(transaction_id, operation_type, "id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE electrical_cell_recording_version\n    SET operation_type = 1, "id" = NEW."id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO electrical_cell_recording_version\n(transaction_id, operation_type, "id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE electrical_cell_recording_version\n    SET "id" = OLD."id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO electrical_cell_recording_version\n(transaction_id, operation_type, "id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_electrical_cell_recording_audit)

    public_etype_class_audit = PGFunction(
        schema="public",
        signature="etype_class_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE etype_class_version\n    SET operation_type = 1, "pref_label" = NEW."pref_label", "definition" = NEW."definition", "alt_label" = NEW."alt_label", "legacy_id" = NEW."legacy_id", "legacy_self" = NEW."legacy_self", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO etype_class_version\n(transaction_id, operation_type, "pref_label", "definition", "alt_label", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."pref_label", NEW."definition", NEW."alt_label", NEW."legacy_id", NEW."legacy_self", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE etype_class_version\n    SET operation_type = 1, "pref_label" = NEW."pref_label", "definition" = NEW."definition", "alt_label" = NEW."alt_label", "legacy_id" = NEW."legacy_id", "legacy_self" = NEW."legacy_self", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO etype_class_version\n(transaction_id, operation_type, "pref_label", "definition", "alt_label", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."pref_label", NEW."definition", NEW."alt_label", NEW."legacy_id", NEW."legacy_self", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE etype_class_version\n    SET "pref_label" = OLD."pref_label", "definition" = OLD."definition", "alt_label" = OLD."alt_label", "legacy_id" = OLD."legacy_id", "legacy_self" = OLD."legacy_self", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO etype_class_version\n(transaction_id, operation_type, "pref_label", "definition", "alt_label", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."pref_label", OLD."definition", OLD."alt_label", OLD."legacy_id", OLD."legacy_self", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_etype_class_audit)

    public_calibration_audit = PGFunction(
        schema="public",
        signature="calibration_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE calibration_version\n    SET operation_type = 1, "id" = NEW."id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO calibration_version\n(transaction_id, operation_type, "id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE calibration_version\n    SET operation_type = 1, "id" = NEW."id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO calibration_version\n(transaction_id, operation_type, "id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE calibration_version\n    SET "id" = OLD."id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO calibration_version\n(transaction_id, operation_type, "id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_calibration_audit)

    public_scientific_artifact_publication_link_audit = PGFunction(
        schema="public",
        signature="scientific_artifact_publication_link_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE scientific_artifact_publication_link_version\n    SET operation_type = 1, "publication_id" = NEW."publication_id", "publication_type" = NEW."publication_type", "scientific_artifact_id" = NEW."scientific_artifact_id", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO scientific_artifact_publication_link_version\n(transaction_id, operation_type, "publication_id", "publication_type", "scientific_artifact_id", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."publication_id", NEW."publication_type", NEW."scientific_artifact_id", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE scientific_artifact_publication_link_version\n    SET operation_type = 1, "publication_id" = NEW."publication_id", "publication_type" = NEW."publication_type", "scientific_artifact_id" = NEW."scientific_artifact_id", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO scientific_artifact_publication_link_version\n(transaction_id, operation_type, "publication_id", "publication_type", "scientific_artifact_id", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."publication_id", NEW."publication_type", NEW."scientific_artifact_id", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE scientific_artifact_publication_link_version\n    SET "publication_id" = OLD."publication_id", "publication_type" = OLD."publication_type", "scientific_artifact_id" = OLD."scientific_artifact_id", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO scientific_artifact_publication_link_version\n(transaction_id, operation_type, "publication_id", "publication_type", "scientific_artifact_id", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."publication_id", OLD."publication_type", OLD."scientific_artifact_id", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_scientific_artifact_publication_link_audit)

    public_simulation_execution_audit = PGFunction(
        schema="public",
        signature="simulation_execution_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE simulation_execution_version\n    SET operation_type = 1, "id" = NEW."id", "status" = NEW."status", "executor" = NEW."executor", "execution_id" = NEW."execution_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO simulation_execution_version\n(transaction_id, operation_type, "id", "status", "executor", "execution_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."status", NEW."executor", NEW."execution_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE simulation_execution_version\n    SET operation_type = 1, "id" = NEW."id", "status" = NEW."status", "executor" = NEW."executor", "execution_id" = NEW."execution_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO simulation_execution_version\n(transaction_id, operation_type, "id", "status", "executor", "execution_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."status", NEW."executor", NEW."execution_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE simulation_execution_version\n    SET "id" = OLD."id", "status" = OLD."status", "executor" = OLD."executor", "execution_id" = OLD."execution_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO simulation_execution_version\n(transaction_id, operation_type, "id", "status", "executor", "execution_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."status", OLD."executor", OLD."execution_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_simulation_execution_audit)

    public_scientific_artifact_audit = PGFunction(
        schema="public",
        signature="scientific_artifact_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE scientific_artifact_version\n    SET operation_type = 1, "id" = NEW."id", "experiment_date" = NEW."experiment_date", "contact_email" = NEW."contact_email", "published_in" = NEW."published_in", "notice_text" = NEW."notice_text", "subject_id" = NEW."subject_id", "brain_region_id" = NEW."brain_region_id", "license_id" = NEW."license_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO scientific_artifact_version\n(transaction_id, operation_type, "id", "experiment_date", "contact_email", "published_in", "notice_text", "subject_id", "brain_region_id", "license_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."experiment_date", NEW."contact_email", NEW."published_in", NEW."notice_text", NEW."subject_id", NEW."brain_region_id", NEW."license_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE scientific_artifact_version\n    SET operation_type = 1, "id" = NEW."id", "experiment_date" = NEW."experiment_date", "contact_email" = NEW."contact_email", "published_in" = NEW."published_in", "notice_text" = NEW."notice_text", "subject_id" = NEW."subject_id", "brain_region_id" = NEW."brain_region_id", "license_id" = NEW."license_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO scientific_artifact_version\n(transaction_id, operation_type, "id", "experiment_date", "contact_email", "published_in", "notice_text", "subject_id", "brain_region_id", "license_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."experiment_date", NEW."contact_email", NEW."published_in", NEW."notice_text", NEW."subject_id", NEW."brain_region_id", NEW."license_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE scientific_artifact_version\n    SET "id" = OLD."id", "experiment_date" = OLD."experiment_date", "contact_email" = OLD."contact_email", "published_in" = OLD."published_in", "notice_text" = OLD."notice_text", "subject_id" = OLD."subject_id", "brain_region_id" = OLD."brain_region_id", "license_id" = OLD."license_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO scientific_artifact_version\n(transaction_id, operation_type, "id", "experiment_date", "contact_email", "published_in", "notice_text", "subject_id", "brain_region_id", "license_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."experiment_date", OLD."contact_email", OLD."published_in", OLD."notice_text", OLD."subject_id", OLD."brain_region_id", OLD."license_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_scientific_artifact_audit)

    public_analysis_software_source_code_audit = PGFunction(
        schema="public",
        signature="analysis_software_source_code_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE analysis_software_source_code_version\n    SET operation_type = 1, "id" = NEW."id", "branch" = NEW."branch", "codeRepository" = NEW."codeRepository", "command" = NEW."command", "commit" = NEW."commit", "subdirectory" = NEW."subdirectory", "targetEntity" = NEW."targetEntity", "programmingLanguage" = NEW."programmingLanguage", "runtimePlatform" = NEW."runtimePlatform", "version" = NEW."version", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO analysis_software_source_code_version\n(transaction_id, operation_type, "id", "branch", "codeRepository", "command", "commit", "subdirectory", "targetEntity", "programmingLanguage", "runtimePlatform", "version", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."branch", NEW."codeRepository", NEW."command", NEW."commit", NEW."subdirectory", NEW."targetEntity", NEW."programmingLanguage", NEW."runtimePlatform", NEW."version", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE analysis_software_source_code_version\n    SET operation_type = 1, "id" = NEW."id", "branch" = NEW."branch", "codeRepository" = NEW."codeRepository", "command" = NEW."command", "commit" = NEW."commit", "subdirectory" = NEW."subdirectory", "targetEntity" = NEW."targetEntity", "programmingLanguage" = NEW."programmingLanguage", "runtimePlatform" = NEW."runtimePlatform", "version" = NEW."version", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO analysis_software_source_code_version\n(transaction_id, operation_type, "id", "branch", "codeRepository", "command", "commit", "subdirectory", "targetEntity", "programmingLanguage", "runtimePlatform", "version", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."branch", NEW."codeRepository", NEW."command", NEW."commit", NEW."subdirectory", NEW."targetEntity", NEW."programmingLanguage", NEW."runtimePlatform", NEW."version", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE analysis_software_source_code_version\n    SET "id" = OLD."id", "branch" = OLD."branch", "codeRepository" = OLD."codeRepository", "command" = OLD."command", "commit" = OLD."commit", "subdirectory" = OLD."subdirectory", "targetEntity" = OLD."targetEntity", "programmingLanguage" = OLD."programmingLanguage", "runtimePlatform" = OLD."runtimePlatform", "version" = OLD."version", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO analysis_software_source_code_version\n(transaction_id, operation_type, "id", "branch", "codeRepository", "command", "commit", "subdirectory", "targetEntity", "programmingLanguage", "runtimePlatform", "version", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."branch", OLD."codeRepository", OLD."command", OLD."commit", OLD."subdirectory", OLD."targetEntity", OLD."programmingLanguage", OLD."runtimePlatform", OLD."version", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_analysis_software_source_code_audit)

    public_experimental_bouton_density_audit = PGFunction(
        schema="public",
        signature="experimental_bouton_density_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE experimental_bouton_density_version\n    SET operation_type = 1, "id" = NEW."id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector", "brain_region_id" = NEW."brain_region_id", "license_id" = NEW."license_id", "subject_id" = NEW."subject_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO experimental_bouton_density_version\n(transaction_id, operation_type, "id", "name", "description", "description_vector", "brain_region_id", "license_id", "subject_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."name", NEW."description", NEW."description_vector", NEW."brain_region_id", NEW."license_id", NEW."subject_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE experimental_bouton_density_version\n    SET operation_type = 1, "id" = NEW."id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector", "brain_region_id" = NEW."brain_region_id", "license_id" = NEW."license_id", "subject_id" = NEW."subject_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO experimental_bouton_density_version\n(transaction_id, operation_type, "id", "name", "description", "description_vector", "brain_region_id", "license_id", "subject_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."name", NEW."description", NEW."description_vector", NEW."brain_region_id", NEW."license_id", NEW."subject_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE experimental_bouton_density_version\n    SET "id" = OLD."id", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector", "brain_region_id" = OLD."brain_region_id", "license_id" = OLD."license_id", "subject_id" = OLD."subject_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO experimental_bouton_density_version\n(transaction_id, operation_type, "id", "name", "description", "description_vector", "brain_region_id", "license_id", "subject_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."name", OLD."description", OLD."description_vector", OLD."brain_region_id", OLD."license_id", OLD."subject_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.create_entity(public_experimental_bouton_density_audit)

    public_transaction_transaction_trigger = PGTrigger(
        schema="public",
        signature="transaction_trigger",
        on_entity="public.transaction",
        is_constraint=False,
        definition="AFTER INSERT ON transaction\nFOR EACH ROW EXECUTE PROCEDURE transaction_temp_table_generator()",
    )
    op.create_entity(public_transaction_transaction_trigger)

    public_me_type_density_me_type_density_trigger = PGTrigger(
        schema="public",
        signature="me_type_density_trigger",
        on_entity="public.me_type_density",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "me_type_density"\nFOR EACH ROW EXECUTE PROCEDURE me_type_density_audit()',
    )
    op.create_entity(public_me_type_density_me_type_density_trigger)

    public_experimental_synapses_per_connection_experimental_synapses_per_connection_trigger = PGTrigger(
        schema="public",
        signature="experimental_synapses_per_connection_trigger",
        on_entity="public.experimental_synapses_per_connection",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "experimental_synapses_per_connection"\nFOR EACH ROW EXECUTE PROCEDURE experimental_synapses_per_connection_audit()',
    )
    op.create_entity(
        public_experimental_synapses_per_connection_experimental_synapses_per_connection_trigger
    )

    public_skeletonization_config_generation_skeletonization_config_generation_trigger = PGTrigger(
        schema="public",
        signature="skeletonization_config_generation_trigger",
        on_entity="public.skeletonization_config_generation",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "skeletonization_config_generation"\nFOR EACH ROW EXECUTE PROCEDURE skeletonization_config_generation_audit()',
    )
    op.create_entity(
        public_skeletonization_config_generation_skeletonization_config_generation_trigger
    )

    public_etype_classification_etype_classification_trigger = PGTrigger(
        schema="public",
        signature="etype_classification_trigger",
        on_entity="public.etype_classification",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "etype_classification"\nFOR EACH ROW EXECUTE PROCEDURE etype_classification_audit()',
    )
    op.create_entity(public_etype_classification_etype_classification_trigger)

    public_skeletonization_execution_skeletonization_execution_trigger = PGTrigger(
        schema="public",
        signature="skeletonization_execution_trigger",
        on_entity="public.skeletonization_execution",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "skeletonization_execution"\nFOR EACH ROW EXECUTE PROCEDURE skeletonization_execution_audit()',
    )
    op.create_entity(public_skeletonization_execution_skeletonization_execution_trigger)

    public_experimental_neuron_density_experimental_neuron_density_trigger = PGTrigger(
        schema="public",
        signature="experimental_neuron_density_trigger",
        on_entity="public.experimental_neuron_density",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "experimental_neuron_density"\nFOR EACH ROW EXECUTE PROCEDURE experimental_neuron_density_audit()',
    )
    op.create_entity(public_experimental_neuron_density_experimental_neuron_density_trigger)

    public_asset_asset_trigger = PGTrigger(
        schema="public",
        signature="asset_trigger",
        on_entity="public.asset",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "asset"\nFOR EACH ROW EXECUTE PROCEDURE asset_audit()',
    )
    op.create_entity(public_asset_asset_trigger)

    public_simulation_generation_simulation_generation_trigger = PGTrigger(
        schema="public",
        signature="simulation_generation_trigger",
        on_entity="public.simulation_generation",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "simulation_generation"\nFOR EACH ROW EXECUTE PROCEDURE simulation_generation_audit()',
    )
    op.create_entity(public_simulation_generation_simulation_generation_trigger)

    public_agent_agent_trigger = PGTrigger(
        schema="public",
        signature="agent_trigger",
        on_entity="public.agent",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "agent"\nFOR EACH ROW EXECUTE PROCEDURE agent_audit()',
    )
    op.create_entity(public_agent_agent_trigger)

    public_license_license_trigger = PGTrigger(
        schema="public",
        signature="license_trigger",
        on_entity="public.license",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "license"\nFOR EACH ROW EXECUTE PROCEDURE license_audit()',
    )
    op.create_entity(public_license_license_trigger)

    public_simulation_simulation_trigger = PGTrigger(
        schema="public",
        signature="simulation_trigger",
        on_entity="public.simulation",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "simulation"\nFOR EACH ROW EXECUTE PROCEDURE simulation_audit()',
    )
    op.create_entity(public_simulation_simulation_trigger)

    public_external_url_external_url_trigger = PGTrigger(
        schema="public",
        signature="external_url_trigger",
        on_entity="public.external_url",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "external_url"\nFOR EACH ROW EXECUTE PROCEDURE external_url_audit()',
    )
    op.create_entity(public_external_url_external_url_trigger)

    public_generation_generation_trigger = PGTrigger(
        schema="public",
        signature="generation_trigger",
        on_entity="public.generation",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "generation"\nFOR EACH ROW EXECUTE PROCEDURE generation_audit()',
    )
    op.create_entity(public_generation_generation_trigger)

    public_role_role_trigger = PGTrigger(
        schema="public",
        signature="role_trigger",
        on_entity="public.role",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "role"\nFOR EACH ROW EXECUTE PROCEDURE role_audit()',
    )
    op.create_entity(public_role_role_trigger)

    public_em_cell_mesh__skeletonization_campaign_em_cell_mesh__skeletonization_campaign_trigger = PGTrigger(
        schema="public",
        signature="em_cell_mesh__skeletonization_campaign_trigger",
        on_entity="public.em_cell_mesh__skeletonization_campaign",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "em_cell_mesh__skeletonization_campaign"\nFOR EACH ROW EXECUTE PROCEDURE em_cell_mesh__skeletonization_campaign_audit()',
    )
    op.create_entity(
        public_em_cell_mesh__skeletonization_campaign_em_cell_mesh__skeletonization_campaign_trigger
    )

    public_organization_organization_trigger = PGTrigger(
        schema="public",
        signature="organization_trigger",
        on_entity="public.organization",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "organization"\nFOR EACH ROW EXECUTE PROCEDURE organization_audit()',
    )
    op.create_entity(public_organization_organization_trigger)

    public_usage_usage_trigger = PGTrigger(
        schema="public",
        signature="usage_trigger",
        on_entity="public.usage",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "usage"\nFOR EACH ROW EXECUTE PROCEDURE usage_audit()',
    )
    op.create_entity(public_usage_usage_trigger)

    public_analysis_notebook_environment_analysis_notebook_environment_trigger = PGTrigger(
        schema="public",
        signature="analysis_notebook_environment_trigger",
        on_entity="public.analysis_notebook_environment",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "analysis_notebook_environment"\nFOR EACH ROW EXECUTE PROCEDURE analysis_notebook_environment_audit()',
    )
    op.create_entity(public_analysis_notebook_environment_analysis_notebook_environment_trigger)

    public_circuit_extraction_config_circuit_extraction_config_trigger = PGTrigger(
        schema="public",
        signature="circuit_extraction_config_trigger",
        on_entity="public.circuit_extraction_config",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "circuit_extraction_config"\nFOR EACH ROW EXECUTE PROCEDURE circuit_extraction_config_audit()',
    )
    op.create_entity(public_circuit_extraction_config_circuit_extraction_config_trigger)

    public_measurement_annotation_measurement_annotation_trigger = PGTrigger(
        schema="public",
        signature="measurement_annotation_trigger",
        on_entity="public.measurement_annotation",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "measurement_annotation"\nFOR EACH ROW EXECUTE PROCEDURE measurement_annotation_audit()',
    )
    op.create_entity(public_measurement_annotation_measurement_annotation_trigger)

    public_annotation_body_annotation_body_trigger = PGTrigger(
        schema="public",
        signature="annotation_body_trigger",
        on_entity="public.annotation_body",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "annotation_body"\nFOR EACH ROW EXECUTE PROCEDURE annotation_body_audit()',
    )
    op.create_entity(public_annotation_body_annotation_body_trigger)

    public_annotation_annotation_trigger = PGTrigger(
        schema="public",
        signature="annotation_trigger",
        on_entity="public.annotation",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "annotation"\nFOR EACH ROW EXECUTE PROCEDURE annotation_audit()',
    )
    op.create_entity(public_annotation_annotation_trigger)

    public_ion_channel_model__emodel_ion_channel_model__emodel_trigger = PGTrigger(
        schema="public",
        signature="ion_channel_model__emodel_trigger",
        on_entity="public.ion_channel_model__emodel",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "ion_channel_model__emodel"\nFOR EACH ROW EXECUTE PROCEDURE ion_channel_model__emodel_audit()',
    )
    op.create_entity(public_ion_channel_model__emodel_ion_channel_model__emodel_trigger)

    public_ion_channel_modeling_execution_ion_channel_modeling_execution_trigger = PGTrigger(
        schema="public",
        signature="ion_channel_modeling_execution_trigger",
        on_entity="public.ion_channel_modeling_execution",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "ion_channel_modeling_execution"\nFOR EACH ROW EXECUTE PROCEDURE ion_channel_modeling_execution_audit()',
    )
    op.create_entity(public_ion_channel_modeling_execution_ion_channel_modeling_execution_trigger)

    public_cell_morphology_cell_morphology_trigger = PGTrigger(
        schema="public",
        signature="cell_morphology_trigger",
        on_entity="public.cell_morphology",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "cell_morphology"\nFOR EACH ROW EXECUTE PROCEDURE cell_morphology_audit()',
    )
    op.create_entity(public_cell_morphology_cell_morphology_trigger)

    public_simulation_campaign_simulation_campaign_trigger = PGTrigger(
        schema="public",
        signature="simulation_campaign_trigger",
        on_entity="public.simulation_campaign",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "simulation_campaign"\nFOR EACH ROW EXECUTE PROCEDURE simulation_campaign_audit()',
    )
    op.create_entity(public_simulation_campaign_simulation_campaign_trigger)

    public_circuit_circuit_trigger = PGTrigger(
        schema="public",
        signature="circuit_trigger",
        on_entity="public.circuit",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "circuit"\nFOR EACH ROW EXECUTE PROCEDURE circuit_audit()',
    )
    op.create_entity(public_circuit_circuit_trigger)

    public_ion_channel_recording__ion_channel_modeling_campaign_ion_channel_recording__ion_channel_modeling_campaign_trigger = PGTrigger(
        schema="public",
        signature="ion_channel_recording__ion_channel_modeling_campaign_trigger",
        on_entity="public.ion_channel_recording__ion_channel_modeling_campaign",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "ion_channel_recording__ion_channel_modeling_campaign"\nFOR EACH ROW EXECUTE PROCEDURE ion_channel_recording__ion_channel_modeling_campaign_audit()',
    )
    op.create_entity(
        public_ion_channel_recording__ion_channel_modeling_campaign_ion_channel_recording__ion_channel_modeling_campaign_trigger
    )

    public_memodel_calibration_result_memodel_calibration_result_trigger = PGTrigger(
        schema="public",
        signature="memodel_calibration_result_trigger",
        on_entity="public.memodel_calibration_result",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "memodel_calibration_result"\nFOR EACH ROW EXECUTE PROCEDURE memodel_calibration_result_audit()',
    )
    op.create_entity(public_memodel_calibration_result_memodel_calibration_result_trigger)

    public_brain_region_brain_region_trigger = PGTrigger(
        schema="public",
        signature="brain_region_trigger",
        on_entity="public.brain_region",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "brain_region"\nFOR EACH ROW EXECUTE PROCEDURE brain_region_audit()',
    )
    op.create_entity(public_brain_region_brain_region_trigger)

    public_skeletonization_config_skeletonization_config_trigger = PGTrigger(
        schema="public",
        signature="skeletonization_config_trigger",
        on_entity="public.skeletonization_config",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "skeletonization_config"\nFOR EACH ROW EXECUTE PROCEDURE skeletonization_config_audit()',
    )
    op.create_entity(public_skeletonization_config_skeletonization_config_trigger)

    public_species_species_trigger = PGTrigger(
        schema="public",
        signature="species_trigger",
        on_entity="public.species",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "species"\nFOR EACH ROW EXECUTE PROCEDURE species_audit()',
    )
    op.create_entity(public_species_species_trigger)

    public_scientific_artifact_external_url_link_scientific_artifact_external_url_link_trigger = PGTrigger(
        schema="public",
        signature="scientific_artifact_external_url_link_trigger",
        on_entity="public.scientific_artifact_external_url_link",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "scientific_artifact_external_url_link"\nFOR EACH ROW EXECUTE PROCEDURE scientific_artifact_external_url_link_audit()',
    )
    op.create_entity(
        public_scientific_artifact_external_url_link_scientific_artifact_external_url_link_trigger
    )

    public_mtype_classification_mtype_classification_trigger = PGTrigger(
        schema="public",
        signature="mtype_classification_trigger",
        on_entity="public.mtype_classification",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "mtype_classification"\nFOR EACH ROW EXECUTE PROCEDURE mtype_classification_audit()',
    )
    op.create_entity(public_mtype_classification_mtype_classification_trigger)

    public_ion_channel_ion_channel_trigger = PGTrigger(
        schema="public",
        signature="ion_channel_trigger",
        on_entity="public.ion_channel",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "ion_channel"\nFOR EACH ROW EXECUTE PROCEDURE ion_channel_audit()',
    )
    op.create_entity(public_ion_channel_ion_channel_trigger)

    public_cell_composition_cell_composition_trigger = PGTrigger(
        schema="public",
        signature="cell_composition_trigger",
        on_entity="public.cell_composition",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "cell_composition"\nFOR EACH ROW EXECUTE PROCEDURE cell_composition_audit()',
    )
    op.create_entity(public_cell_composition_cell_composition_trigger)

    public_circuit_extraction_campaign_circuit_extraction_campaign_trigger = PGTrigger(
        schema="public",
        signature="circuit_extraction_campaign_trigger",
        on_entity="public.circuit_extraction_campaign",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "circuit_extraction_campaign"\nFOR EACH ROW EXECUTE PROCEDURE circuit_extraction_campaign_audit()',
    )
    op.create_entity(public_circuit_extraction_campaign_circuit_extraction_campaign_trigger)

    public_mtype_class_mtype_class_trigger = PGTrigger(
        schema="public",
        signature="mtype_class_trigger",
        on_entity="public.mtype_class",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "mtype_class"\nFOR EACH ROW EXECUTE PROCEDURE mtype_class_audit()',
    )
    op.create_entity(public_mtype_class_mtype_class_trigger)

    public_ion_channel_model_ion_channel_model_trigger = PGTrigger(
        schema="public",
        signature="ion_channel_model_trigger",
        on_entity="public.ion_channel_model",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "ion_channel_model"\nFOR EACH ROW EXECUTE PROCEDURE ion_channel_model_audit()',
    )
    op.create_entity(public_ion_channel_model_ion_channel_model_trigger)

    public_circuit_extraction_execution_circuit_extraction_execution_trigger = PGTrigger(
        schema="public",
        signature="circuit_extraction_execution_trigger",
        on_entity="public.circuit_extraction_execution",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "circuit_extraction_execution"\nFOR EACH ROW EXECUTE PROCEDURE circuit_extraction_execution_audit()',
    )
    op.create_entity(public_circuit_extraction_execution_circuit_extraction_execution_trigger)

    public_cell_morphology_protocol_cell_morphology_protocol_trigger = PGTrigger(
        schema="public",
        signature="cell_morphology_protocol_trigger",
        on_entity="public.cell_morphology_protocol",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "cell_morphology_protocol"\nFOR EACH ROW EXECUTE PROCEDURE cell_morphology_protocol_audit()',
    )
    op.create_entity(public_cell_morphology_protocol_cell_morphology_protocol_trigger)

    public_simulation_result_simulation_result_trigger = PGTrigger(
        schema="public",
        signature="simulation_result_trigger",
        on_entity="public.simulation_result",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "simulation_result"\nFOR EACH ROW EXECUTE PROCEDURE simulation_result_audit()',
    )
    op.create_entity(public_simulation_result_simulation_result_trigger)

    public_validation_validation_trigger = PGTrigger(
        schema="public",
        signature="validation_trigger",
        on_entity="public.validation",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "validation"\nFOR EACH ROW EXECUTE PROCEDURE validation_audit()',
    )
    op.create_entity(public_validation_validation_trigger)

    public_person_person_trigger = PGTrigger(
        schema="public",
        signature="person_trigger",
        on_entity="public.person",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "person"\nFOR EACH ROW EXECUTE PROCEDURE person_audit()',
    )
    op.create_entity(public_person_person_trigger)

    public_datamaturity_annotation_body_datamaturity_annotation_body_trigger = PGTrigger(
        schema="public",
        signature="datamaturity_annotation_body_trigger",
        on_entity="public.datamaturity_annotation_body",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "datamaturity_annotation_body"\nFOR EACH ROW EXECUTE PROCEDURE datamaturity_annotation_body_audit()',
    )
    op.create_entity(public_datamaturity_annotation_body_datamaturity_annotation_body_trigger)

    public_ion_channel_modeling_config_ion_channel_modeling_config_trigger = PGTrigger(
        schema="public",
        signature="ion_channel_modeling_config_trigger",
        on_entity="public.ion_channel_modeling_config",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "ion_channel_modeling_config"\nFOR EACH ROW EXECUTE PROCEDURE ion_channel_modeling_config_audit()',
    )
    op.create_entity(public_ion_channel_modeling_config_ion_channel_modeling_config_trigger)

    public_contribution_contribution_trigger = PGTrigger(
        schema="public",
        signature="contribution_trigger",
        on_entity="public.contribution",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "contribution"\nFOR EACH ROW EXECUTE PROCEDURE contribution_audit()',
    )
    op.create_entity(public_contribution_contribution_trigger)

    public_skeletonization_campaign_skeletonization_campaign_trigger = PGTrigger(
        schema="public",
        signature="skeletonization_campaign_trigger",
        on_entity="public.skeletonization_campaign",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "skeletonization_campaign"\nFOR EACH ROW EXECUTE PROCEDURE skeletonization_campaign_audit()',
    )
    op.create_entity(public_skeletonization_campaign_skeletonization_campaign_trigger)

    public_emodel_emodel_trigger = PGTrigger(
        schema="public",
        signature="emodel_trigger",
        on_entity="public.emodel",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "emodel"\nFOR EACH ROW EXECUTE PROCEDURE emodel_audit()',
    )
    op.create_entity(public_emodel_emodel_trigger)

    public_brain_atlas_region_brain_atlas_region_trigger = PGTrigger(
        schema="public",
        signature="brain_atlas_region_trigger",
        on_entity="public.brain_atlas_region",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "brain_atlas_region"\nFOR EACH ROW EXECUTE PROCEDURE brain_atlas_region_audit()',
    )
    op.create_entity(public_brain_atlas_region_brain_atlas_region_trigger)

    public_derivation_derivation_trigger = PGTrigger(
        schema="public",
        signature="derivation_trigger",
        on_entity="public.derivation",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "derivation"\nFOR EACH ROW EXECUTE PROCEDURE derivation_audit()',
    )
    op.create_entity(public_derivation_derivation_trigger)

    public_publication_publication_trigger = PGTrigger(
        schema="public",
        signature="publication_trigger",
        on_entity="public.publication",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "publication"\nFOR EACH ROW EXECUTE PROCEDURE publication_audit()',
    )
    op.create_entity(public_publication_publication_trigger)

    public_electrical_recording_stimulus_electrical_recording_stimulus_trigger = PGTrigger(
        schema="public",
        signature="electrical_recording_stimulus_trigger",
        on_entity="public.electrical_recording_stimulus",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "electrical_recording_stimulus"\nFOR EACH ROW EXECUTE PROCEDURE electrical_recording_stimulus_audit()',
    )
    op.create_entity(public_electrical_recording_stimulus_electrical_recording_stimulus_trigger)

    public_single_neuron_synaptome_simulation_single_neuron_synaptome_simulation_trigger = PGTrigger(
        schema="public",
        signature="single_neuron_synaptome_simulation_trigger",
        on_entity="public.single_neuron_synaptome_simulation",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "single_neuron_synaptome_simulation"\nFOR EACH ROW EXECUTE PROCEDURE single_neuron_synaptome_simulation_audit()',
    )
    op.create_entity(
        public_single_neuron_synaptome_simulation_single_neuron_synaptome_simulation_trigger
    )

    public_subject_subject_trigger = PGTrigger(
        schema="public",
        signature="subject_trigger",
        on_entity="public.subject",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "subject"\nFOR EACH ROW EXECUTE PROCEDURE subject_audit()',
    )
    op.create_entity(public_subject_subject_trigger)

    public_consortium_consortium_trigger = PGTrigger(
        schema="public",
        signature="consortium_trigger",
        on_entity="public.consortium",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "consortium"\nFOR EACH ROW EXECUTE PROCEDURE consortium_audit()',
    )
    op.create_entity(public_consortium_consortium_trigger)

    public_ion_channel_recording_ion_channel_recording_trigger = PGTrigger(
        schema="public",
        signature="ion_channel_recording_trigger",
        on_entity="public.ion_channel_recording",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "ion_channel_recording"\nFOR EACH ROW EXECUTE PROCEDURE ion_channel_recording_audit()',
    )
    op.create_entity(public_ion_channel_recording_ion_channel_recording_trigger)

    public_analysis_notebook_execution_analysis_notebook_execution_trigger = PGTrigger(
        schema="public",
        signature="analysis_notebook_execution_trigger",
        on_entity="public.analysis_notebook_execution",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "analysis_notebook_execution"\nFOR EACH ROW EXECUTE PROCEDURE analysis_notebook_execution_audit()',
    )
    op.create_entity(public_analysis_notebook_execution_analysis_notebook_execution_trigger)

    public_single_neuron_simulation_single_neuron_simulation_trigger = PGTrigger(
        schema="public",
        signature="single_neuron_simulation_trigger",
        on_entity="public.single_neuron_simulation",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "single_neuron_simulation"\nFOR EACH ROW EXECUTE PROCEDURE single_neuron_simulation_audit()',
    )
    op.create_entity(public_single_neuron_simulation_single_neuron_simulation_trigger)

    public_analysis_notebook_template_analysis_notebook_template_trigger = PGTrigger(
        schema="public",
        signature="analysis_notebook_template_trigger",
        on_entity="public.analysis_notebook_template",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "analysis_notebook_template"\nFOR EACH ROW EXECUTE PROCEDURE analysis_notebook_template_audit()',
    )
    op.create_entity(public_analysis_notebook_template_analysis_notebook_template_trigger)

    public_analysis_notebook_result_analysis_notebook_result_trigger = PGTrigger(
        schema="public",
        signature="analysis_notebook_result_trigger",
        on_entity="public.analysis_notebook_result",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "analysis_notebook_result"\nFOR EACH ROW EXECUTE PROCEDURE analysis_notebook_result_audit()',
    )
    op.create_entity(public_analysis_notebook_result_analysis_notebook_result_trigger)

    public_brain_region_hierarchy_brain_region_hierarchy_trigger = PGTrigger(
        schema="public",
        signature="brain_region_hierarchy_trigger",
        on_entity="public.brain_region_hierarchy",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "brain_region_hierarchy"\nFOR EACH ROW EXECUTE PROCEDURE brain_region_hierarchy_audit()',
    )
    op.create_entity(public_brain_region_hierarchy_brain_region_hierarchy_trigger)

    public_strain_strain_trigger = PGTrigger(
        schema="public",
        signature="strain_trigger",
        on_entity="public.strain",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "strain"\nFOR EACH ROW EXECUTE PROCEDURE strain_audit()',
    )
    op.create_entity(public_strain_strain_trigger)

    public_ion_ion_trigger = PGTrigger(
        schema="public",
        signature="ion_trigger",
        on_entity="public.ion",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "ion"\nFOR EACH ROW EXECUTE PROCEDURE ion_audit()',
    )
    op.create_entity(public_ion_ion_trigger)

    public_validation_result_validation_result_trigger = PGTrigger(
        schema="public",
        signature="validation_result_trigger",
        on_entity="public.validation_result",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "validation_result"\nFOR EACH ROW EXECUTE PROCEDURE validation_result_audit()',
    )
    op.create_entity(public_validation_result_validation_result_trigger)

    public_circuit_extraction_config_generation_circuit_extraction_config_generation_trigger = PGTrigger(
        schema="public",
        signature="circuit_extraction_config_generation_trigger",
        on_entity="public.circuit_extraction_config_generation",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "circuit_extraction_config_generation"\nFOR EACH ROW EXECUTE PROCEDURE circuit_extraction_config_generation_audit()',
    )
    op.create_entity(
        public_circuit_extraction_config_generation_circuit_extraction_config_generation_trigger
    )

    public_electrical_recording_electrical_recording_trigger = PGTrigger(
        schema="public",
        signature="electrical_recording_trigger",
        on_entity="public.electrical_recording",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "electrical_recording"\nFOR EACH ROW EXECUTE PROCEDURE electrical_recording_audit()',
    )
    op.create_entity(public_electrical_recording_electrical_recording_trigger)

    public_em_cell_mesh_em_cell_mesh_trigger = PGTrigger(
        schema="public",
        signature="em_cell_mesh_trigger",
        on_entity="public.em_cell_mesh",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "em_cell_mesh"\nFOR EACH ROW EXECUTE PROCEDURE em_cell_mesh_audit()',
    )
    op.create_entity(public_em_cell_mesh_em_cell_mesh_trigger)

    public_memodel_memodel_trigger = PGTrigger(
        schema="public",
        signature="memodel_trigger",
        on_entity="public.memodel",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "memodel"\nFOR EACH ROW EXECUTE PROCEDURE memodel_audit()',
    )
    op.create_entity(public_memodel_memodel_trigger)

    public_ion_channel_modeling_config_generation_ion_channel_modeling_config_generation_trigger = PGTrigger(
        schema="public",
        signature="ion_channel_modeling_config_generation_trigger",
        on_entity="public.ion_channel_modeling_config_generation",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "ion_channel_modeling_config_generation"\nFOR EACH ROW EXECUTE PROCEDURE ion_channel_modeling_config_generation_audit()',
    )
    op.create_entity(
        public_ion_channel_modeling_config_generation_ion_channel_modeling_config_generation_trigger
    )

    public_single_neuron_synaptome_single_neuron_synaptome_trigger = PGTrigger(
        schema="public",
        signature="single_neuron_synaptome_trigger",
        on_entity="public.single_neuron_synaptome",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "single_neuron_synaptome"\nFOR EACH ROW EXECUTE PROCEDURE single_neuron_synaptome_audit()',
    )
    op.create_entity(public_single_neuron_synaptome_single_neuron_synaptome_trigger)

    public_activity_activity_trigger = PGTrigger(
        schema="public",
        signature="activity_trigger",
        on_entity="public.activity",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "activity"\nFOR EACH ROW EXECUTE PROCEDURE activity_audit()',
    )
    op.create_entity(public_activity_activity_trigger)

    public_brain_atlas_brain_atlas_trigger = PGTrigger(
        schema="public",
        signature="brain_atlas_trigger",
        on_entity="public.brain_atlas",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "brain_atlas"\nFOR EACH ROW EXECUTE PROCEDURE brain_atlas_audit()',
    )
    op.create_entity(public_brain_atlas_brain_atlas_trigger)

    public_entity_entity_trigger = PGTrigger(
        schema="public",
        signature="entity_trigger",
        on_entity="public.entity",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "entity"\nFOR EACH ROW EXECUTE PROCEDURE entity_audit()',
    )
    op.create_entity(public_entity_entity_trigger)

    public_ion_channel_modeling_campaign_ion_channel_modeling_campaign_trigger = PGTrigger(
        schema="public",
        signature="ion_channel_modeling_campaign_trigger",
        on_entity="public.ion_channel_modeling_campaign",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "ion_channel_modeling_campaign"\nFOR EACH ROW EXECUTE PROCEDURE ion_channel_modeling_campaign_audit()',
    )
    op.create_entity(public_ion_channel_modeling_campaign_ion_channel_modeling_campaign_trigger)

    public_em_dense_reconstruction_dataset_em_dense_reconstruction_dataset_trigger = PGTrigger(
        schema="public",
        signature="em_dense_reconstruction_dataset_trigger",
        on_entity="public.em_dense_reconstruction_dataset",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "em_dense_reconstruction_dataset"\nFOR EACH ROW EXECUTE PROCEDURE em_dense_reconstruction_dataset_audit()',
    )
    op.create_entity(public_em_dense_reconstruction_dataset_em_dense_reconstruction_dataset_trigger)

    public_electrical_cell_recording_electrical_cell_recording_trigger = PGTrigger(
        schema="public",
        signature="electrical_cell_recording_trigger",
        on_entity="public.electrical_cell_recording",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "electrical_cell_recording"\nFOR EACH ROW EXECUTE PROCEDURE electrical_cell_recording_audit()',
    )
    op.create_entity(public_electrical_cell_recording_electrical_cell_recording_trigger)

    public_etype_class_etype_class_trigger = PGTrigger(
        schema="public",
        signature="etype_class_trigger",
        on_entity="public.etype_class",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "etype_class"\nFOR EACH ROW EXECUTE PROCEDURE etype_class_audit()',
    )
    op.create_entity(public_etype_class_etype_class_trigger)

    public_calibration_calibration_trigger = PGTrigger(
        schema="public",
        signature="calibration_trigger",
        on_entity="public.calibration",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "calibration"\nFOR EACH ROW EXECUTE PROCEDURE calibration_audit()',
    )
    op.create_entity(public_calibration_calibration_trigger)

    public_scientific_artifact_publication_link_scientific_artifact_publication_link_trigger = PGTrigger(
        schema="public",
        signature="scientific_artifact_publication_link_trigger",
        on_entity="public.scientific_artifact_publication_link",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "scientific_artifact_publication_link"\nFOR EACH ROW EXECUTE PROCEDURE scientific_artifact_publication_link_audit()',
    )
    op.create_entity(
        public_scientific_artifact_publication_link_scientific_artifact_publication_link_trigger
    )

    public_simulation_execution_simulation_execution_trigger = PGTrigger(
        schema="public",
        signature="simulation_execution_trigger",
        on_entity="public.simulation_execution",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "simulation_execution"\nFOR EACH ROW EXECUTE PROCEDURE simulation_execution_audit()',
    )
    op.create_entity(public_simulation_execution_simulation_execution_trigger)

    public_scientific_artifact_scientific_artifact_trigger = PGTrigger(
        schema="public",
        signature="scientific_artifact_trigger",
        on_entity="public.scientific_artifact",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "scientific_artifact"\nFOR EACH ROW EXECUTE PROCEDURE scientific_artifact_audit()',
    )
    op.create_entity(public_scientific_artifact_scientific_artifact_trigger)

    public_analysis_software_source_code_analysis_software_source_code_trigger = PGTrigger(
        schema="public",
        signature="analysis_software_source_code_trigger",
        on_entity="public.analysis_software_source_code",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "analysis_software_source_code"\nFOR EACH ROW EXECUTE PROCEDURE analysis_software_source_code_audit()',
    )
    op.create_entity(public_analysis_software_source_code_analysis_software_source_code_trigger)

    public_experimental_bouton_density_experimental_bouton_density_trigger = PGTrigger(
        schema="public",
        signature="experimental_bouton_density_trigger",
        on_entity="public.experimental_bouton_density",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "experimental_bouton_density"\nFOR EACH ROW EXECUTE PROCEDURE experimental_bouton_density_audit()',
    )
    op.create_entity(public_experimental_bouton_density_experimental_bouton_density_trigger)

    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    public_experimental_bouton_density_experimental_bouton_density_trigger = PGTrigger(
        schema="public",
        signature="experimental_bouton_density_trigger",
        on_entity="public.experimental_bouton_density",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "experimental_bouton_density"\nFOR EACH ROW EXECUTE PROCEDURE experimental_bouton_density_audit()',
    )
    op.drop_entity(public_experimental_bouton_density_experimental_bouton_density_trigger)

    public_analysis_software_source_code_analysis_software_source_code_trigger = PGTrigger(
        schema="public",
        signature="analysis_software_source_code_trigger",
        on_entity="public.analysis_software_source_code",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "analysis_software_source_code"\nFOR EACH ROW EXECUTE PROCEDURE analysis_software_source_code_audit()',
    )
    op.drop_entity(public_analysis_software_source_code_analysis_software_source_code_trigger)

    public_scientific_artifact_scientific_artifact_trigger = PGTrigger(
        schema="public",
        signature="scientific_artifact_trigger",
        on_entity="public.scientific_artifact",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "scientific_artifact"\nFOR EACH ROW EXECUTE PROCEDURE scientific_artifact_audit()',
    )
    op.drop_entity(public_scientific_artifact_scientific_artifact_trigger)

    public_simulation_execution_simulation_execution_trigger = PGTrigger(
        schema="public",
        signature="simulation_execution_trigger",
        on_entity="public.simulation_execution",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "simulation_execution"\nFOR EACH ROW EXECUTE PROCEDURE simulation_execution_audit()',
    )
    op.drop_entity(public_simulation_execution_simulation_execution_trigger)

    public_scientific_artifact_publication_link_scientific_artifact_publication_link_trigger = PGTrigger(
        schema="public",
        signature="scientific_artifact_publication_link_trigger",
        on_entity="public.scientific_artifact_publication_link",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "scientific_artifact_publication_link"\nFOR EACH ROW EXECUTE PROCEDURE scientific_artifact_publication_link_audit()',
    )
    op.drop_entity(
        public_scientific_artifact_publication_link_scientific_artifact_publication_link_trigger
    )

    public_calibration_calibration_trigger = PGTrigger(
        schema="public",
        signature="calibration_trigger",
        on_entity="public.calibration",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "calibration"\nFOR EACH ROW EXECUTE PROCEDURE calibration_audit()',
    )
    op.drop_entity(public_calibration_calibration_trigger)

    public_etype_class_etype_class_trigger = PGTrigger(
        schema="public",
        signature="etype_class_trigger",
        on_entity="public.etype_class",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "etype_class"\nFOR EACH ROW EXECUTE PROCEDURE etype_class_audit()',
    )
    op.drop_entity(public_etype_class_etype_class_trigger)

    public_electrical_cell_recording_electrical_cell_recording_trigger = PGTrigger(
        schema="public",
        signature="electrical_cell_recording_trigger",
        on_entity="public.electrical_cell_recording",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "electrical_cell_recording"\nFOR EACH ROW EXECUTE PROCEDURE electrical_cell_recording_audit()',
    )
    op.drop_entity(public_electrical_cell_recording_electrical_cell_recording_trigger)

    public_em_dense_reconstruction_dataset_em_dense_reconstruction_dataset_trigger = PGTrigger(
        schema="public",
        signature="em_dense_reconstruction_dataset_trigger",
        on_entity="public.em_dense_reconstruction_dataset",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "em_dense_reconstruction_dataset"\nFOR EACH ROW EXECUTE PROCEDURE em_dense_reconstruction_dataset_audit()',
    )
    op.drop_entity(public_em_dense_reconstruction_dataset_em_dense_reconstruction_dataset_trigger)

    public_ion_channel_modeling_campaign_ion_channel_modeling_campaign_trigger = PGTrigger(
        schema="public",
        signature="ion_channel_modeling_campaign_trigger",
        on_entity="public.ion_channel_modeling_campaign",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "ion_channel_modeling_campaign"\nFOR EACH ROW EXECUTE PROCEDURE ion_channel_modeling_campaign_audit()',
    )
    op.drop_entity(public_ion_channel_modeling_campaign_ion_channel_modeling_campaign_trigger)

    public_entity_entity_trigger = PGTrigger(
        schema="public",
        signature="entity_trigger",
        on_entity="public.entity",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "entity"\nFOR EACH ROW EXECUTE PROCEDURE entity_audit()',
    )
    op.drop_entity(public_entity_entity_trigger)

    public_brain_atlas_brain_atlas_trigger = PGTrigger(
        schema="public",
        signature="brain_atlas_trigger",
        on_entity="public.brain_atlas",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "brain_atlas"\nFOR EACH ROW EXECUTE PROCEDURE brain_atlas_audit()',
    )
    op.drop_entity(public_brain_atlas_brain_atlas_trigger)

    public_activity_activity_trigger = PGTrigger(
        schema="public",
        signature="activity_trigger",
        on_entity="public.activity",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "activity"\nFOR EACH ROW EXECUTE PROCEDURE activity_audit()',
    )
    op.drop_entity(public_activity_activity_trigger)

    public_single_neuron_synaptome_single_neuron_synaptome_trigger = PGTrigger(
        schema="public",
        signature="single_neuron_synaptome_trigger",
        on_entity="public.single_neuron_synaptome",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "single_neuron_synaptome"\nFOR EACH ROW EXECUTE PROCEDURE single_neuron_synaptome_audit()',
    )
    op.drop_entity(public_single_neuron_synaptome_single_neuron_synaptome_trigger)

    public_ion_channel_modeling_config_generation_ion_channel_modeling_config_generation_trigger = PGTrigger(
        schema="public",
        signature="ion_channel_modeling_config_generation_trigger",
        on_entity="public.ion_channel_modeling_config_generation",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "ion_channel_modeling_config_generation"\nFOR EACH ROW EXECUTE PROCEDURE ion_channel_modeling_config_generation_audit()',
    )
    op.drop_entity(
        public_ion_channel_modeling_config_generation_ion_channel_modeling_config_generation_trigger
    )

    public_memodel_memodel_trigger = PGTrigger(
        schema="public",
        signature="memodel_trigger",
        on_entity="public.memodel",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "memodel"\nFOR EACH ROW EXECUTE PROCEDURE memodel_audit()',
    )
    op.drop_entity(public_memodel_memodel_trigger)

    public_em_cell_mesh_em_cell_mesh_trigger = PGTrigger(
        schema="public",
        signature="em_cell_mesh_trigger",
        on_entity="public.em_cell_mesh",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "em_cell_mesh"\nFOR EACH ROW EXECUTE PROCEDURE em_cell_mesh_audit()',
    )
    op.drop_entity(public_em_cell_mesh_em_cell_mesh_trigger)

    public_electrical_recording_electrical_recording_trigger = PGTrigger(
        schema="public",
        signature="electrical_recording_trigger",
        on_entity="public.electrical_recording",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "electrical_recording"\nFOR EACH ROW EXECUTE PROCEDURE electrical_recording_audit()',
    )
    op.drop_entity(public_electrical_recording_electrical_recording_trigger)

    public_circuit_extraction_config_generation_circuit_extraction_config_generation_trigger = PGTrigger(
        schema="public",
        signature="circuit_extraction_config_generation_trigger",
        on_entity="public.circuit_extraction_config_generation",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "circuit_extraction_config_generation"\nFOR EACH ROW EXECUTE PROCEDURE circuit_extraction_config_generation_audit()',
    )
    op.drop_entity(
        public_circuit_extraction_config_generation_circuit_extraction_config_generation_trigger
    )

    public_validation_result_validation_result_trigger = PGTrigger(
        schema="public",
        signature="validation_result_trigger",
        on_entity="public.validation_result",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "validation_result"\nFOR EACH ROW EXECUTE PROCEDURE validation_result_audit()',
    )
    op.drop_entity(public_validation_result_validation_result_trigger)

    public_ion_ion_trigger = PGTrigger(
        schema="public",
        signature="ion_trigger",
        on_entity="public.ion",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "ion"\nFOR EACH ROW EXECUTE PROCEDURE ion_audit()',
    )
    op.drop_entity(public_ion_ion_trigger)

    public_strain_strain_trigger = PGTrigger(
        schema="public",
        signature="strain_trigger",
        on_entity="public.strain",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "strain"\nFOR EACH ROW EXECUTE PROCEDURE strain_audit()',
    )
    op.drop_entity(public_strain_strain_trigger)

    public_brain_region_hierarchy_brain_region_hierarchy_trigger = PGTrigger(
        schema="public",
        signature="brain_region_hierarchy_trigger",
        on_entity="public.brain_region_hierarchy",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "brain_region_hierarchy"\nFOR EACH ROW EXECUTE PROCEDURE brain_region_hierarchy_audit()',
    )
    op.drop_entity(public_brain_region_hierarchy_brain_region_hierarchy_trigger)

    public_analysis_notebook_result_analysis_notebook_result_trigger = PGTrigger(
        schema="public",
        signature="analysis_notebook_result_trigger",
        on_entity="public.analysis_notebook_result",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "analysis_notebook_result"\nFOR EACH ROW EXECUTE PROCEDURE analysis_notebook_result_audit()',
    )
    op.drop_entity(public_analysis_notebook_result_analysis_notebook_result_trigger)

    public_analysis_notebook_template_analysis_notebook_template_trigger = PGTrigger(
        schema="public",
        signature="analysis_notebook_template_trigger",
        on_entity="public.analysis_notebook_template",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "analysis_notebook_template"\nFOR EACH ROW EXECUTE PROCEDURE analysis_notebook_template_audit()',
    )
    op.drop_entity(public_analysis_notebook_template_analysis_notebook_template_trigger)

    public_single_neuron_simulation_single_neuron_simulation_trigger = PGTrigger(
        schema="public",
        signature="single_neuron_simulation_trigger",
        on_entity="public.single_neuron_simulation",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "single_neuron_simulation"\nFOR EACH ROW EXECUTE PROCEDURE single_neuron_simulation_audit()',
    )
    op.drop_entity(public_single_neuron_simulation_single_neuron_simulation_trigger)

    public_analysis_notebook_execution_analysis_notebook_execution_trigger = PGTrigger(
        schema="public",
        signature="analysis_notebook_execution_trigger",
        on_entity="public.analysis_notebook_execution",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "analysis_notebook_execution"\nFOR EACH ROW EXECUTE PROCEDURE analysis_notebook_execution_audit()',
    )
    op.drop_entity(public_analysis_notebook_execution_analysis_notebook_execution_trigger)

    public_ion_channel_recording_ion_channel_recording_trigger = PGTrigger(
        schema="public",
        signature="ion_channel_recording_trigger",
        on_entity="public.ion_channel_recording",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "ion_channel_recording"\nFOR EACH ROW EXECUTE PROCEDURE ion_channel_recording_audit()',
    )
    op.drop_entity(public_ion_channel_recording_ion_channel_recording_trigger)

    public_consortium_consortium_trigger = PGTrigger(
        schema="public",
        signature="consortium_trigger",
        on_entity="public.consortium",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "consortium"\nFOR EACH ROW EXECUTE PROCEDURE consortium_audit()',
    )
    op.drop_entity(public_consortium_consortium_trigger)

    public_subject_subject_trigger = PGTrigger(
        schema="public",
        signature="subject_trigger",
        on_entity="public.subject",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "subject"\nFOR EACH ROW EXECUTE PROCEDURE subject_audit()',
    )
    op.drop_entity(public_subject_subject_trigger)

    public_single_neuron_synaptome_simulation_single_neuron_synaptome_simulation_trigger = PGTrigger(
        schema="public",
        signature="single_neuron_synaptome_simulation_trigger",
        on_entity="public.single_neuron_synaptome_simulation",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "single_neuron_synaptome_simulation"\nFOR EACH ROW EXECUTE PROCEDURE single_neuron_synaptome_simulation_audit()',
    )
    op.drop_entity(
        public_single_neuron_synaptome_simulation_single_neuron_synaptome_simulation_trigger
    )

    public_electrical_recording_stimulus_electrical_recording_stimulus_trigger = PGTrigger(
        schema="public",
        signature="electrical_recording_stimulus_trigger",
        on_entity="public.electrical_recording_stimulus",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "electrical_recording_stimulus"\nFOR EACH ROW EXECUTE PROCEDURE electrical_recording_stimulus_audit()',
    )
    op.drop_entity(public_electrical_recording_stimulus_electrical_recording_stimulus_trigger)

    public_publication_publication_trigger = PGTrigger(
        schema="public",
        signature="publication_trigger",
        on_entity="public.publication",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "publication"\nFOR EACH ROW EXECUTE PROCEDURE publication_audit()',
    )
    op.drop_entity(public_publication_publication_trigger)

    public_derivation_derivation_trigger = PGTrigger(
        schema="public",
        signature="derivation_trigger",
        on_entity="public.derivation",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "derivation"\nFOR EACH ROW EXECUTE PROCEDURE derivation_audit()',
    )
    op.drop_entity(public_derivation_derivation_trigger)

    public_brain_atlas_region_brain_atlas_region_trigger = PGTrigger(
        schema="public",
        signature="brain_atlas_region_trigger",
        on_entity="public.brain_atlas_region",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "brain_atlas_region"\nFOR EACH ROW EXECUTE PROCEDURE brain_atlas_region_audit()',
    )
    op.drop_entity(public_brain_atlas_region_brain_atlas_region_trigger)

    public_emodel_emodel_trigger = PGTrigger(
        schema="public",
        signature="emodel_trigger",
        on_entity="public.emodel",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "emodel"\nFOR EACH ROW EXECUTE PROCEDURE emodel_audit()',
    )
    op.drop_entity(public_emodel_emodel_trigger)

    public_skeletonization_campaign_skeletonization_campaign_trigger = PGTrigger(
        schema="public",
        signature="skeletonization_campaign_trigger",
        on_entity="public.skeletonization_campaign",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "skeletonization_campaign"\nFOR EACH ROW EXECUTE PROCEDURE skeletonization_campaign_audit()',
    )
    op.drop_entity(public_skeletonization_campaign_skeletonization_campaign_trigger)

    public_contribution_contribution_trigger = PGTrigger(
        schema="public",
        signature="contribution_trigger",
        on_entity="public.contribution",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "contribution"\nFOR EACH ROW EXECUTE PROCEDURE contribution_audit()',
    )
    op.drop_entity(public_contribution_contribution_trigger)

    public_ion_channel_modeling_config_ion_channel_modeling_config_trigger = PGTrigger(
        schema="public",
        signature="ion_channel_modeling_config_trigger",
        on_entity="public.ion_channel_modeling_config",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "ion_channel_modeling_config"\nFOR EACH ROW EXECUTE PROCEDURE ion_channel_modeling_config_audit()',
    )
    op.drop_entity(public_ion_channel_modeling_config_ion_channel_modeling_config_trigger)

    public_datamaturity_annotation_body_datamaturity_annotation_body_trigger = PGTrigger(
        schema="public",
        signature="datamaturity_annotation_body_trigger",
        on_entity="public.datamaturity_annotation_body",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "datamaturity_annotation_body"\nFOR EACH ROW EXECUTE PROCEDURE datamaturity_annotation_body_audit()',
    )
    op.drop_entity(public_datamaturity_annotation_body_datamaturity_annotation_body_trigger)

    public_person_person_trigger = PGTrigger(
        schema="public",
        signature="person_trigger",
        on_entity="public.person",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "person"\nFOR EACH ROW EXECUTE PROCEDURE person_audit()',
    )
    op.drop_entity(public_person_person_trigger)

    public_validation_validation_trigger = PGTrigger(
        schema="public",
        signature="validation_trigger",
        on_entity="public.validation",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "validation"\nFOR EACH ROW EXECUTE PROCEDURE validation_audit()',
    )
    op.drop_entity(public_validation_validation_trigger)

    public_simulation_result_simulation_result_trigger = PGTrigger(
        schema="public",
        signature="simulation_result_trigger",
        on_entity="public.simulation_result",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "simulation_result"\nFOR EACH ROW EXECUTE PROCEDURE simulation_result_audit()',
    )
    op.drop_entity(public_simulation_result_simulation_result_trigger)

    public_cell_morphology_protocol_cell_morphology_protocol_trigger = PGTrigger(
        schema="public",
        signature="cell_morphology_protocol_trigger",
        on_entity="public.cell_morphology_protocol",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "cell_morphology_protocol"\nFOR EACH ROW EXECUTE PROCEDURE cell_morphology_protocol_audit()',
    )
    op.drop_entity(public_cell_morphology_protocol_cell_morphology_protocol_trigger)

    public_circuit_extraction_execution_circuit_extraction_execution_trigger = PGTrigger(
        schema="public",
        signature="circuit_extraction_execution_trigger",
        on_entity="public.circuit_extraction_execution",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "circuit_extraction_execution"\nFOR EACH ROW EXECUTE PROCEDURE circuit_extraction_execution_audit()',
    )
    op.drop_entity(public_circuit_extraction_execution_circuit_extraction_execution_trigger)

    public_ion_channel_model_ion_channel_model_trigger = PGTrigger(
        schema="public",
        signature="ion_channel_model_trigger",
        on_entity="public.ion_channel_model",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "ion_channel_model"\nFOR EACH ROW EXECUTE PROCEDURE ion_channel_model_audit()',
    )
    op.drop_entity(public_ion_channel_model_ion_channel_model_trigger)

    public_mtype_class_mtype_class_trigger = PGTrigger(
        schema="public",
        signature="mtype_class_trigger",
        on_entity="public.mtype_class",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "mtype_class"\nFOR EACH ROW EXECUTE PROCEDURE mtype_class_audit()',
    )
    op.drop_entity(public_mtype_class_mtype_class_trigger)

    public_circuit_extraction_campaign_circuit_extraction_campaign_trigger = PGTrigger(
        schema="public",
        signature="circuit_extraction_campaign_trigger",
        on_entity="public.circuit_extraction_campaign",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "circuit_extraction_campaign"\nFOR EACH ROW EXECUTE PROCEDURE circuit_extraction_campaign_audit()',
    )
    op.drop_entity(public_circuit_extraction_campaign_circuit_extraction_campaign_trigger)

    public_cell_composition_cell_composition_trigger = PGTrigger(
        schema="public",
        signature="cell_composition_trigger",
        on_entity="public.cell_composition",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "cell_composition"\nFOR EACH ROW EXECUTE PROCEDURE cell_composition_audit()',
    )
    op.drop_entity(public_cell_composition_cell_composition_trigger)

    public_ion_channel_ion_channel_trigger = PGTrigger(
        schema="public",
        signature="ion_channel_trigger",
        on_entity="public.ion_channel",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "ion_channel"\nFOR EACH ROW EXECUTE PROCEDURE ion_channel_audit()',
    )
    op.drop_entity(public_ion_channel_ion_channel_trigger)

    public_mtype_classification_mtype_classification_trigger = PGTrigger(
        schema="public",
        signature="mtype_classification_trigger",
        on_entity="public.mtype_classification",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "mtype_classification"\nFOR EACH ROW EXECUTE PROCEDURE mtype_classification_audit()',
    )
    op.drop_entity(public_mtype_classification_mtype_classification_trigger)

    public_scientific_artifact_external_url_link_scientific_artifact_external_url_link_trigger = PGTrigger(
        schema="public",
        signature="scientific_artifact_external_url_link_trigger",
        on_entity="public.scientific_artifact_external_url_link",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "scientific_artifact_external_url_link"\nFOR EACH ROW EXECUTE PROCEDURE scientific_artifact_external_url_link_audit()',
    )
    op.drop_entity(
        public_scientific_artifact_external_url_link_scientific_artifact_external_url_link_trigger
    )

    public_species_species_trigger = PGTrigger(
        schema="public",
        signature="species_trigger",
        on_entity="public.species",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "species"\nFOR EACH ROW EXECUTE PROCEDURE species_audit()',
    )
    op.drop_entity(public_species_species_trigger)

    public_skeletonization_config_skeletonization_config_trigger = PGTrigger(
        schema="public",
        signature="skeletonization_config_trigger",
        on_entity="public.skeletonization_config",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "skeletonization_config"\nFOR EACH ROW EXECUTE PROCEDURE skeletonization_config_audit()',
    )
    op.drop_entity(public_skeletonization_config_skeletonization_config_trigger)

    public_brain_region_brain_region_trigger = PGTrigger(
        schema="public",
        signature="brain_region_trigger",
        on_entity="public.brain_region",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "brain_region"\nFOR EACH ROW EXECUTE PROCEDURE brain_region_audit()',
    )
    op.drop_entity(public_brain_region_brain_region_trigger)

    public_memodel_calibration_result_memodel_calibration_result_trigger = PGTrigger(
        schema="public",
        signature="memodel_calibration_result_trigger",
        on_entity="public.memodel_calibration_result",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "memodel_calibration_result"\nFOR EACH ROW EXECUTE PROCEDURE memodel_calibration_result_audit()',
    )
    op.drop_entity(public_memodel_calibration_result_memodel_calibration_result_trigger)

    public_ion_channel_recording__ion_channel_modeling_campaign_ion_channel_recording__ion_channel_modeling_campaign_trigger = PGTrigger(
        schema="public",
        signature="ion_channel_recording__ion_channel_modeling_campaign_trigger",
        on_entity="public.ion_channel_recording__ion_channel_modeling_campaign",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "ion_channel_recording__ion_channel_modeling_campaign"\nFOR EACH ROW EXECUTE PROCEDURE ion_channel_recording__ion_channel_modeling_campaign_audit()',
    )
    op.drop_entity(
        public_ion_channel_recording__ion_channel_modeling_campaign_ion_channel_recording__ion_channel_modeling_campaign_trigger
    )

    public_circuit_circuit_trigger = PGTrigger(
        schema="public",
        signature="circuit_trigger",
        on_entity="public.circuit",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "circuit"\nFOR EACH ROW EXECUTE PROCEDURE circuit_audit()',
    )
    op.drop_entity(public_circuit_circuit_trigger)

    public_simulation_campaign_simulation_campaign_trigger = PGTrigger(
        schema="public",
        signature="simulation_campaign_trigger",
        on_entity="public.simulation_campaign",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "simulation_campaign"\nFOR EACH ROW EXECUTE PROCEDURE simulation_campaign_audit()',
    )
    op.drop_entity(public_simulation_campaign_simulation_campaign_trigger)

    public_cell_morphology_cell_morphology_trigger = PGTrigger(
        schema="public",
        signature="cell_morphology_trigger",
        on_entity="public.cell_morphology",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "cell_morphology"\nFOR EACH ROW EXECUTE PROCEDURE cell_morphology_audit()',
    )
    op.drop_entity(public_cell_morphology_cell_morphology_trigger)

    public_ion_channel_modeling_execution_ion_channel_modeling_execution_trigger = PGTrigger(
        schema="public",
        signature="ion_channel_modeling_execution_trigger",
        on_entity="public.ion_channel_modeling_execution",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "ion_channel_modeling_execution"\nFOR EACH ROW EXECUTE PROCEDURE ion_channel_modeling_execution_audit()',
    )
    op.drop_entity(public_ion_channel_modeling_execution_ion_channel_modeling_execution_trigger)

    public_ion_channel_model__emodel_ion_channel_model__emodel_trigger = PGTrigger(
        schema="public",
        signature="ion_channel_model__emodel_trigger",
        on_entity="public.ion_channel_model__emodel",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "ion_channel_model__emodel"\nFOR EACH ROW EXECUTE PROCEDURE ion_channel_model__emodel_audit()',
    )
    op.drop_entity(public_ion_channel_model__emodel_ion_channel_model__emodel_trigger)

    public_annotation_annotation_trigger = PGTrigger(
        schema="public",
        signature="annotation_trigger",
        on_entity="public.annotation",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "annotation"\nFOR EACH ROW EXECUTE PROCEDURE annotation_audit()',
    )
    op.drop_entity(public_annotation_annotation_trigger)

    public_annotation_body_annotation_body_trigger = PGTrigger(
        schema="public",
        signature="annotation_body_trigger",
        on_entity="public.annotation_body",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "annotation_body"\nFOR EACH ROW EXECUTE PROCEDURE annotation_body_audit()',
    )
    op.drop_entity(public_annotation_body_annotation_body_trigger)

    public_measurement_annotation_measurement_annotation_trigger = PGTrigger(
        schema="public",
        signature="measurement_annotation_trigger",
        on_entity="public.measurement_annotation",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "measurement_annotation"\nFOR EACH ROW EXECUTE PROCEDURE measurement_annotation_audit()',
    )
    op.drop_entity(public_measurement_annotation_measurement_annotation_trigger)

    public_circuit_extraction_config_circuit_extraction_config_trigger = PGTrigger(
        schema="public",
        signature="circuit_extraction_config_trigger",
        on_entity="public.circuit_extraction_config",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "circuit_extraction_config"\nFOR EACH ROW EXECUTE PROCEDURE circuit_extraction_config_audit()',
    )
    op.drop_entity(public_circuit_extraction_config_circuit_extraction_config_trigger)

    public_analysis_notebook_environment_analysis_notebook_environment_trigger = PGTrigger(
        schema="public",
        signature="analysis_notebook_environment_trigger",
        on_entity="public.analysis_notebook_environment",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "analysis_notebook_environment"\nFOR EACH ROW EXECUTE PROCEDURE analysis_notebook_environment_audit()',
    )
    op.drop_entity(public_analysis_notebook_environment_analysis_notebook_environment_trigger)

    public_usage_usage_trigger = PGTrigger(
        schema="public",
        signature="usage_trigger",
        on_entity="public.usage",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "usage"\nFOR EACH ROW EXECUTE PROCEDURE usage_audit()',
    )
    op.drop_entity(public_usage_usage_trigger)

    public_organization_organization_trigger = PGTrigger(
        schema="public",
        signature="organization_trigger",
        on_entity="public.organization",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "organization"\nFOR EACH ROW EXECUTE PROCEDURE organization_audit()',
    )
    op.drop_entity(public_organization_organization_trigger)

    public_em_cell_mesh__skeletonization_campaign_em_cell_mesh__skeletonization_campaign_trigger = PGTrigger(
        schema="public",
        signature="em_cell_mesh__skeletonization_campaign_trigger",
        on_entity="public.em_cell_mesh__skeletonization_campaign",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "em_cell_mesh__skeletonization_campaign"\nFOR EACH ROW EXECUTE PROCEDURE em_cell_mesh__skeletonization_campaign_audit()',
    )
    op.drop_entity(
        public_em_cell_mesh__skeletonization_campaign_em_cell_mesh__skeletonization_campaign_trigger
    )

    public_role_role_trigger = PGTrigger(
        schema="public",
        signature="role_trigger",
        on_entity="public.role",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "role"\nFOR EACH ROW EXECUTE PROCEDURE role_audit()',
    )
    op.drop_entity(public_role_role_trigger)

    public_generation_generation_trigger = PGTrigger(
        schema="public",
        signature="generation_trigger",
        on_entity="public.generation",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "generation"\nFOR EACH ROW EXECUTE PROCEDURE generation_audit()',
    )
    op.drop_entity(public_generation_generation_trigger)

    public_external_url_external_url_trigger = PGTrigger(
        schema="public",
        signature="external_url_trigger",
        on_entity="public.external_url",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "external_url"\nFOR EACH ROW EXECUTE PROCEDURE external_url_audit()',
    )
    op.drop_entity(public_external_url_external_url_trigger)

    public_simulation_simulation_trigger = PGTrigger(
        schema="public",
        signature="simulation_trigger",
        on_entity="public.simulation",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "simulation"\nFOR EACH ROW EXECUTE PROCEDURE simulation_audit()',
    )
    op.drop_entity(public_simulation_simulation_trigger)

    public_license_license_trigger = PGTrigger(
        schema="public",
        signature="license_trigger",
        on_entity="public.license",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "license"\nFOR EACH ROW EXECUTE PROCEDURE license_audit()',
    )
    op.drop_entity(public_license_license_trigger)

    public_agent_agent_trigger = PGTrigger(
        schema="public",
        signature="agent_trigger",
        on_entity="public.agent",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "agent"\nFOR EACH ROW EXECUTE PROCEDURE agent_audit()',
    )
    op.drop_entity(public_agent_agent_trigger)

    public_simulation_generation_simulation_generation_trigger = PGTrigger(
        schema="public",
        signature="simulation_generation_trigger",
        on_entity="public.simulation_generation",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "simulation_generation"\nFOR EACH ROW EXECUTE PROCEDURE simulation_generation_audit()',
    )
    op.drop_entity(public_simulation_generation_simulation_generation_trigger)

    public_asset_asset_trigger = PGTrigger(
        schema="public",
        signature="asset_trigger",
        on_entity="public.asset",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "asset"\nFOR EACH ROW EXECUTE PROCEDURE asset_audit()',
    )
    op.drop_entity(public_asset_asset_trigger)

    public_experimental_neuron_density_experimental_neuron_density_trigger = PGTrigger(
        schema="public",
        signature="experimental_neuron_density_trigger",
        on_entity="public.experimental_neuron_density",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "experimental_neuron_density"\nFOR EACH ROW EXECUTE PROCEDURE experimental_neuron_density_audit()',
    )
    op.drop_entity(public_experimental_neuron_density_experimental_neuron_density_trigger)

    public_skeletonization_execution_skeletonization_execution_trigger = PGTrigger(
        schema="public",
        signature="skeletonization_execution_trigger",
        on_entity="public.skeletonization_execution",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "skeletonization_execution"\nFOR EACH ROW EXECUTE PROCEDURE skeletonization_execution_audit()',
    )
    op.drop_entity(public_skeletonization_execution_skeletonization_execution_trigger)

    public_etype_classification_etype_classification_trigger = PGTrigger(
        schema="public",
        signature="etype_classification_trigger",
        on_entity="public.etype_classification",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "etype_classification"\nFOR EACH ROW EXECUTE PROCEDURE etype_classification_audit()',
    )
    op.drop_entity(public_etype_classification_etype_classification_trigger)

    public_skeletonization_config_generation_skeletonization_config_generation_trigger = PGTrigger(
        schema="public",
        signature="skeletonization_config_generation_trigger",
        on_entity="public.skeletonization_config_generation",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "skeletonization_config_generation"\nFOR EACH ROW EXECUTE PROCEDURE skeletonization_config_generation_audit()',
    )
    op.drop_entity(
        public_skeletonization_config_generation_skeletonization_config_generation_trigger
    )

    public_experimental_synapses_per_connection_experimental_synapses_per_connection_trigger = PGTrigger(
        schema="public",
        signature="experimental_synapses_per_connection_trigger",
        on_entity="public.experimental_synapses_per_connection",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "experimental_synapses_per_connection"\nFOR EACH ROW EXECUTE PROCEDURE experimental_synapses_per_connection_audit()',
    )
    op.drop_entity(
        public_experimental_synapses_per_connection_experimental_synapses_per_connection_trigger
    )

    public_me_type_density_me_type_density_trigger = PGTrigger(
        schema="public",
        signature="me_type_density_trigger",
        on_entity="public.me_type_density",
        is_constraint=False,
        definition='AFTER INSERT OR UPDATE OR DELETE ON "me_type_density"\nFOR EACH ROW EXECUTE PROCEDURE me_type_density_audit()',
    )
    op.drop_entity(public_me_type_density_me_type_density_trigger)

    public_transaction_transaction_trigger = PGTrigger(
        schema="public",
        signature="transaction_trigger",
        on_entity="public.transaction",
        is_constraint=False,
        definition="AFTER INSERT ON transaction\nFOR EACH ROW EXECUTE PROCEDURE transaction_temp_table_generator()",
    )
    op.drop_entity(public_transaction_transaction_trigger)

    public_experimental_bouton_density_audit = PGFunction(
        schema="public",
        signature="experimental_bouton_density_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE experimental_bouton_density_version\n    SET operation_type = 1, "id" = NEW."id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector", "brain_region_id" = NEW."brain_region_id", "license_id" = NEW."license_id", "subject_id" = NEW."subject_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO experimental_bouton_density_version\n(transaction_id, operation_type, "id", "name", "description", "description_vector", "brain_region_id", "license_id", "subject_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."name", NEW."description", NEW."description_vector", NEW."brain_region_id", NEW."license_id", NEW."subject_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE experimental_bouton_density_version\n    SET operation_type = 1, "id" = NEW."id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector", "brain_region_id" = NEW."brain_region_id", "license_id" = NEW."license_id", "subject_id" = NEW."subject_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO experimental_bouton_density_version\n(transaction_id, operation_type, "id", "name", "description", "description_vector", "brain_region_id", "license_id", "subject_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."name", NEW."description", NEW."description_vector", NEW."brain_region_id", NEW."license_id", NEW."subject_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE experimental_bouton_density_version\n    SET "id" = OLD."id", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector", "brain_region_id" = OLD."brain_region_id", "license_id" = OLD."license_id", "subject_id" = OLD."subject_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO experimental_bouton_density_version\n(transaction_id, operation_type, "id", "name", "description", "description_vector", "brain_region_id", "license_id", "subject_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."name", OLD."description", OLD."description_vector", OLD."brain_region_id", OLD."license_id", OLD."subject_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_experimental_bouton_density_audit)

    public_analysis_software_source_code_audit = PGFunction(
        schema="public",
        signature="analysis_software_source_code_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE analysis_software_source_code_version\n    SET operation_type = 1, "id" = NEW."id", "branch" = NEW."branch", "codeRepository" = NEW."codeRepository", "command" = NEW."command", "commit" = NEW."commit", "subdirectory" = NEW."subdirectory", "targetEntity" = NEW."targetEntity", "programmingLanguage" = NEW."programmingLanguage", "runtimePlatform" = NEW."runtimePlatform", "version" = NEW."version", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO analysis_software_source_code_version\n(transaction_id, operation_type, "id", "branch", "codeRepository", "command", "commit", "subdirectory", "targetEntity", "programmingLanguage", "runtimePlatform", "version", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."branch", NEW."codeRepository", NEW."command", NEW."commit", NEW."subdirectory", NEW."targetEntity", NEW."programmingLanguage", NEW."runtimePlatform", NEW."version", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE analysis_software_source_code_version\n    SET operation_type = 1, "id" = NEW."id", "branch" = NEW."branch", "codeRepository" = NEW."codeRepository", "command" = NEW."command", "commit" = NEW."commit", "subdirectory" = NEW."subdirectory", "targetEntity" = NEW."targetEntity", "programmingLanguage" = NEW."programmingLanguage", "runtimePlatform" = NEW."runtimePlatform", "version" = NEW."version", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO analysis_software_source_code_version\n(transaction_id, operation_type, "id", "branch", "codeRepository", "command", "commit", "subdirectory", "targetEntity", "programmingLanguage", "runtimePlatform", "version", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."branch", NEW."codeRepository", NEW."command", NEW."commit", NEW."subdirectory", NEW."targetEntity", NEW."programmingLanguage", NEW."runtimePlatform", NEW."version", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE analysis_software_source_code_version\n    SET "id" = OLD."id", "branch" = OLD."branch", "codeRepository" = OLD."codeRepository", "command" = OLD."command", "commit" = OLD."commit", "subdirectory" = OLD."subdirectory", "targetEntity" = OLD."targetEntity", "programmingLanguage" = OLD."programmingLanguage", "runtimePlatform" = OLD."runtimePlatform", "version" = OLD."version", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO analysis_software_source_code_version\n(transaction_id, operation_type, "id", "branch", "codeRepository", "command", "commit", "subdirectory", "targetEntity", "programmingLanguage", "runtimePlatform", "version", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."branch", OLD."codeRepository", OLD."command", OLD."commit", OLD."subdirectory", OLD."targetEntity", OLD."programmingLanguage", OLD."runtimePlatform", OLD."version", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_analysis_software_source_code_audit)

    public_scientific_artifact_audit = PGFunction(
        schema="public",
        signature="scientific_artifact_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE scientific_artifact_version\n    SET operation_type = 1, "id" = NEW."id", "experiment_date" = NEW."experiment_date", "contact_email" = NEW."contact_email", "published_in" = NEW."published_in", "notice_text" = NEW."notice_text", "subject_id" = NEW."subject_id", "brain_region_id" = NEW."brain_region_id", "license_id" = NEW."license_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO scientific_artifact_version\n(transaction_id, operation_type, "id", "experiment_date", "contact_email", "published_in", "notice_text", "subject_id", "brain_region_id", "license_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."experiment_date", NEW."contact_email", NEW."published_in", NEW."notice_text", NEW."subject_id", NEW."brain_region_id", NEW."license_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE scientific_artifact_version\n    SET operation_type = 1, "id" = NEW."id", "experiment_date" = NEW."experiment_date", "contact_email" = NEW."contact_email", "published_in" = NEW."published_in", "notice_text" = NEW."notice_text", "subject_id" = NEW."subject_id", "brain_region_id" = NEW."brain_region_id", "license_id" = NEW."license_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO scientific_artifact_version\n(transaction_id, operation_type, "id", "experiment_date", "contact_email", "published_in", "notice_text", "subject_id", "brain_region_id", "license_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."experiment_date", NEW."contact_email", NEW."published_in", NEW."notice_text", NEW."subject_id", NEW."brain_region_id", NEW."license_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE scientific_artifact_version\n    SET "id" = OLD."id", "experiment_date" = OLD."experiment_date", "contact_email" = OLD."contact_email", "published_in" = OLD."published_in", "notice_text" = OLD."notice_text", "subject_id" = OLD."subject_id", "brain_region_id" = OLD."brain_region_id", "license_id" = OLD."license_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO scientific_artifact_version\n(transaction_id, operation_type, "id", "experiment_date", "contact_email", "published_in", "notice_text", "subject_id", "brain_region_id", "license_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."experiment_date", OLD."contact_email", OLD."published_in", OLD."notice_text", OLD."subject_id", OLD."brain_region_id", OLD."license_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_scientific_artifact_audit)

    public_simulation_execution_audit = PGFunction(
        schema="public",
        signature="simulation_execution_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE simulation_execution_version\n    SET operation_type = 1, "id" = NEW."id", "status" = NEW."status", "executor" = NEW."executor", "execution_id" = NEW."execution_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO simulation_execution_version\n(transaction_id, operation_type, "id", "status", "executor", "execution_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."status", NEW."executor", NEW."execution_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE simulation_execution_version\n    SET operation_type = 1, "id" = NEW."id", "status" = NEW."status", "executor" = NEW."executor", "execution_id" = NEW."execution_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO simulation_execution_version\n(transaction_id, operation_type, "id", "status", "executor", "execution_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."status", NEW."executor", NEW."execution_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE simulation_execution_version\n    SET "id" = OLD."id", "status" = OLD."status", "executor" = OLD."executor", "execution_id" = OLD."execution_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO simulation_execution_version\n(transaction_id, operation_type, "id", "status", "executor", "execution_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."status", OLD."executor", OLD."execution_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_simulation_execution_audit)

    public_scientific_artifact_publication_link_audit = PGFunction(
        schema="public",
        signature="scientific_artifact_publication_link_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE scientific_artifact_publication_link_version\n    SET operation_type = 1, "publication_id" = NEW."publication_id", "publication_type" = NEW."publication_type", "scientific_artifact_id" = NEW."scientific_artifact_id", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO scientific_artifact_publication_link_version\n(transaction_id, operation_type, "publication_id", "publication_type", "scientific_artifact_id", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."publication_id", NEW."publication_type", NEW."scientific_artifact_id", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE scientific_artifact_publication_link_version\n    SET operation_type = 1, "publication_id" = NEW."publication_id", "publication_type" = NEW."publication_type", "scientific_artifact_id" = NEW."scientific_artifact_id", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO scientific_artifact_publication_link_version\n(transaction_id, operation_type, "publication_id", "publication_type", "scientific_artifact_id", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."publication_id", NEW."publication_type", NEW."scientific_artifact_id", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE scientific_artifact_publication_link_version\n    SET "publication_id" = OLD."publication_id", "publication_type" = OLD."publication_type", "scientific_artifact_id" = OLD."scientific_artifact_id", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO scientific_artifact_publication_link_version\n(transaction_id, operation_type, "publication_id", "publication_type", "scientific_artifact_id", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."publication_id", OLD."publication_type", OLD."scientific_artifact_id", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_scientific_artifact_publication_link_audit)

    public_calibration_audit = PGFunction(
        schema="public",
        signature="calibration_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE calibration_version\n    SET operation_type = 1, "id" = NEW."id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO calibration_version\n(transaction_id, operation_type, "id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE calibration_version\n    SET operation_type = 1, "id" = NEW."id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO calibration_version\n(transaction_id, operation_type, "id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE calibration_version\n    SET "id" = OLD."id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO calibration_version\n(transaction_id, operation_type, "id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_calibration_audit)

    public_etype_class_audit = PGFunction(
        schema="public",
        signature="etype_class_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE etype_class_version\n    SET operation_type = 1, "pref_label" = NEW."pref_label", "definition" = NEW."definition", "alt_label" = NEW."alt_label", "legacy_id" = NEW."legacy_id", "legacy_self" = NEW."legacy_self", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO etype_class_version\n(transaction_id, operation_type, "pref_label", "definition", "alt_label", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."pref_label", NEW."definition", NEW."alt_label", NEW."legacy_id", NEW."legacy_self", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE etype_class_version\n    SET operation_type = 1, "pref_label" = NEW."pref_label", "definition" = NEW."definition", "alt_label" = NEW."alt_label", "legacy_id" = NEW."legacy_id", "legacy_self" = NEW."legacy_self", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO etype_class_version\n(transaction_id, operation_type, "pref_label", "definition", "alt_label", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."pref_label", NEW."definition", NEW."alt_label", NEW."legacy_id", NEW."legacy_self", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE etype_class_version\n    SET "pref_label" = OLD."pref_label", "definition" = OLD."definition", "alt_label" = OLD."alt_label", "legacy_id" = OLD."legacy_id", "legacy_self" = OLD."legacy_self", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO etype_class_version\n(transaction_id, operation_type, "pref_label", "definition", "alt_label", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."pref_label", OLD."definition", OLD."alt_label", OLD."legacy_id", OLD."legacy_self", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_etype_class_audit)

    public_electrical_cell_recording_audit = PGFunction(
        schema="public",
        signature="electrical_cell_recording_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE electrical_cell_recording_version\n    SET operation_type = 1, "id" = NEW."id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO electrical_cell_recording_version\n(transaction_id, operation_type, "id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE electrical_cell_recording_version\n    SET operation_type = 1, "id" = NEW."id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO electrical_cell_recording_version\n(transaction_id, operation_type, "id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE electrical_cell_recording_version\n    SET "id" = OLD."id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO electrical_cell_recording_version\n(transaction_id, operation_type, "id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_electrical_cell_recording_audit)

    public_em_dense_reconstruction_dataset_audit = PGFunction(
        schema="public",
        signature="em_dense_reconstruction_dataset_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE em_dense_reconstruction_dataset_version\n    SET operation_type = 1, "id" = NEW."id", "protocol_document" = NEW."protocol_document", "fixation" = NEW."fixation", "staining_type" = NEW."staining_type", "slicing_thickness" = NEW."slicing_thickness", "tissue_shrinkage" = NEW."tissue_shrinkage", "microscope_type" = NEW."microscope_type", "detector" = NEW."detector", "slicing_direction" = NEW."slicing_direction", "landmarks" = NEW."landmarks", "voltage" = NEW."voltage", "current" = NEW."current", "dose" = NEW."dose", "temperature" = NEW."temperature", "volume_resolution_x_nm" = NEW."volume_resolution_x_nm", "volume_resolution_y_nm" = NEW."volume_resolution_y_nm", "volume_resolution_z_nm" = NEW."volume_resolution_z_nm", "release_url" = NEW."release_url", "cave_client_url" = NEW."cave_client_url", "cave_datastack" = NEW."cave_datastack", "precomputed_mesh_url" = NEW."precomputed_mesh_url", "cell_identifying_property" = NEW."cell_identifying_property", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO em_dense_reconstruction_dataset_version\n(transaction_id, operation_type, "id", "protocol_document", "fixation", "staining_type", "slicing_thickness", "tissue_shrinkage", "microscope_type", "detector", "slicing_direction", "landmarks", "voltage", "current", "dose", "temperature", "volume_resolution_x_nm", "volume_resolution_y_nm", "volume_resolution_z_nm", "release_url", "cave_client_url", "cave_datastack", "precomputed_mesh_url", "cell_identifying_property", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."protocol_document", NEW."fixation", NEW."staining_type", NEW."slicing_thickness", NEW."tissue_shrinkage", NEW."microscope_type", NEW."detector", NEW."slicing_direction", NEW."landmarks", NEW."voltage", NEW."current", NEW."dose", NEW."temperature", NEW."volume_resolution_x_nm", NEW."volume_resolution_y_nm", NEW."volume_resolution_z_nm", NEW."release_url", NEW."cave_client_url", NEW."cave_datastack", NEW."precomputed_mesh_url", NEW."cell_identifying_property", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE em_dense_reconstruction_dataset_version\n    SET operation_type = 1, "id" = NEW."id", "protocol_document" = NEW."protocol_document", "fixation" = NEW."fixation", "staining_type" = NEW."staining_type", "slicing_thickness" = NEW."slicing_thickness", "tissue_shrinkage" = NEW."tissue_shrinkage", "microscope_type" = NEW."microscope_type", "detector" = NEW."detector", "slicing_direction" = NEW."slicing_direction", "landmarks" = NEW."landmarks", "voltage" = NEW."voltage", "current" = NEW."current", "dose" = NEW."dose", "temperature" = NEW."temperature", "volume_resolution_x_nm" = NEW."volume_resolution_x_nm", "volume_resolution_y_nm" = NEW."volume_resolution_y_nm", "volume_resolution_z_nm" = NEW."volume_resolution_z_nm", "release_url" = NEW."release_url", "cave_client_url" = NEW."cave_client_url", "cave_datastack" = NEW."cave_datastack", "precomputed_mesh_url" = NEW."precomputed_mesh_url", "cell_identifying_property" = NEW."cell_identifying_property", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO em_dense_reconstruction_dataset_version\n(transaction_id, operation_type, "id", "protocol_document", "fixation", "staining_type", "slicing_thickness", "tissue_shrinkage", "microscope_type", "detector", "slicing_direction", "landmarks", "voltage", "current", "dose", "temperature", "volume_resolution_x_nm", "volume_resolution_y_nm", "volume_resolution_z_nm", "release_url", "cave_client_url", "cave_datastack", "precomputed_mesh_url", "cell_identifying_property", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."protocol_document", NEW."fixation", NEW."staining_type", NEW."slicing_thickness", NEW."tissue_shrinkage", NEW."microscope_type", NEW."detector", NEW."slicing_direction", NEW."landmarks", NEW."voltage", NEW."current", NEW."dose", NEW."temperature", NEW."volume_resolution_x_nm", NEW."volume_resolution_y_nm", NEW."volume_resolution_z_nm", NEW."release_url", NEW."cave_client_url", NEW."cave_datastack", NEW."precomputed_mesh_url", NEW."cell_identifying_property", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE em_dense_reconstruction_dataset_version\n    SET "id" = OLD."id", "protocol_document" = OLD."protocol_document", "fixation" = OLD."fixation", "staining_type" = OLD."staining_type", "slicing_thickness" = OLD."slicing_thickness", "tissue_shrinkage" = OLD."tissue_shrinkage", "microscope_type" = OLD."microscope_type", "detector" = OLD."detector", "slicing_direction" = OLD."slicing_direction", "landmarks" = OLD."landmarks", "voltage" = OLD."voltage", "current" = OLD."current", "dose" = OLD."dose", "temperature" = OLD."temperature", "volume_resolution_x_nm" = OLD."volume_resolution_x_nm", "volume_resolution_y_nm" = OLD."volume_resolution_y_nm", "volume_resolution_z_nm" = OLD."volume_resolution_z_nm", "release_url" = OLD."release_url", "cave_client_url" = OLD."cave_client_url", "cave_datastack" = OLD."cave_datastack", "precomputed_mesh_url" = OLD."precomputed_mesh_url", "cell_identifying_property" = OLD."cell_identifying_property", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO em_dense_reconstruction_dataset_version\n(transaction_id, operation_type, "id", "protocol_document", "fixation", "staining_type", "slicing_thickness", "tissue_shrinkage", "microscope_type", "detector", "slicing_direction", "landmarks", "voltage", "current", "dose", "temperature", "volume_resolution_x_nm", "volume_resolution_y_nm", "volume_resolution_z_nm", "release_url", "cave_client_url", "cave_datastack", "precomputed_mesh_url", "cell_identifying_property", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."protocol_document", OLD."fixation", OLD."staining_type", OLD."slicing_thickness", OLD."tissue_shrinkage", OLD."microscope_type", OLD."detector", OLD."slicing_direction", OLD."landmarks", OLD."voltage", OLD."current", OLD."dose", OLD."temperature", OLD."volume_resolution_x_nm", OLD."volume_resolution_y_nm", OLD."volume_resolution_z_nm", OLD."release_url", OLD."cave_client_url", OLD."cave_datastack", OLD."precomputed_mesh_url", OLD."cell_identifying_property", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_em_dense_reconstruction_dataset_audit)

    public_ion_channel_modeling_campaign_audit = PGFunction(
        schema="public",
        signature="ion_channel_modeling_campaign_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_modeling_campaign_version\n    SET operation_type = 1, "id" = NEW."id", "scan_parameters" = NEW."scan_parameters", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO ion_channel_modeling_campaign_version\n(transaction_id, operation_type, "id", "scan_parameters", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."scan_parameters", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_modeling_campaign_version\n    SET operation_type = 1, "id" = NEW."id", "scan_parameters" = NEW."scan_parameters", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO ion_channel_modeling_campaign_version\n(transaction_id, operation_type, "id", "scan_parameters", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."scan_parameters", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_modeling_campaign_version\n    SET "id" = OLD."id", "scan_parameters" = OLD."scan_parameters", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO ion_channel_modeling_campaign_version\n(transaction_id, operation_type, "id", "scan_parameters", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."scan_parameters", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_ion_channel_modeling_campaign_audit)

    public_entity_audit = PGFunction(
        schema="public",
        signature="entity_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE entity_version\n    SET operation_type = 1, "type" = NEW."type", "authorized_project_id" = NEW."authorized_project_id", "authorized_public" = NEW."authorized_public", "legacy_id" = NEW."legacy_id", "legacy_self" = NEW."legacy_self", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO entity_version\n(transaction_id, operation_type, "type", "authorized_project_id", "authorized_public", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."type", NEW."authorized_project_id", NEW."authorized_public", NEW."legacy_id", NEW."legacy_self", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE entity_version\n    SET operation_type = 1, "type" = NEW."type", "authorized_project_id" = NEW."authorized_project_id", "authorized_public" = NEW."authorized_public", "legacy_id" = NEW."legacy_id", "legacy_self" = NEW."legacy_self", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO entity_version\n(transaction_id, operation_type, "type", "authorized_project_id", "authorized_public", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."type", NEW."authorized_project_id", NEW."authorized_public", NEW."legacy_id", NEW."legacy_self", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE entity_version\n    SET "type" = OLD."type", "authorized_project_id" = OLD."authorized_project_id", "authorized_public" = OLD."authorized_public", "legacy_id" = OLD."legacy_id", "legacy_self" = OLD."legacy_self", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO entity_version\n(transaction_id, operation_type, "type", "authorized_project_id", "authorized_public", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."type", OLD."authorized_project_id", OLD."authorized_public", OLD."legacy_id", OLD."legacy_self", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_entity_audit)

    public_brain_atlas_audit = PGFunction(
        schema="public",
        signature="brain_atlas_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE brain_atlas_version\n    SET operation_type = 1, "id" = NEW."id", "hierarchy_id" = NEW."hierarchy_id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector", "species_id" = NEW."species_id", "strain_id" = NEW."strain_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO brain_atlas_version\n(transaction_id, operation_type, "id", "hierarchy_id", "name", "description", "description_vector", "species_id", "strain_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."hierarchy_id", NEW."name", NEW."description", NEW."description_vector", NEW."species_id", NEW."strain_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE brain_atlas_version\n    SET operation_type = 1, "id" = NEW."id", "hierarchy_id" = NEW."hierarchy_id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector", "species_id" = NEW."species_id", "strain_id" = NEW."strain_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO brain_atlas_version\n(transaction_id, operation_type, "id", "hierarchy_id", "name", "description", "description_vector", "species_id", "strain_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."hierarchy_id", NEW."name", NEW."description", NEW."description_vector", NEW."species_id", NEW."strain_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE brain_atlas_version\n    SET "id" = OLD."id", "hierarchy_id" = OLD."hierarchy_id", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector", "species_id" = OLD."species_id", "strain_id" = OLD."strain_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO brain_atlas_version\n(transaction_id, operation_type, "id", "hierarchy_id", "name", "description", "description_vector", "species_id", "strain_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."hierarchy_id", OLD."name", OLD."description", OLD."description_vector", OLD."species_id", OLD."strain_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_brain_atlas_audit)

    public_activity_audit = PGFunction(
        schema="public",
        signature="activity_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE activity_version\n    SET operation_type = 1, "authorized_project_id" = NEW."authorized_project_id", "authorized_public" = NEW."authorized_public", "type" = NEW."type", "start_time" = NEW."start_time", "end_time" = NEW."end_time", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO activity_version\n(transaction_id, operation_type, "authorized_project_id", "authorized_public", "type", "start_time", "end_time", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."authorized_project_id", NEW."authorized_public", NEW."type", NEW."start_time", NEW."end_time", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE activity_version\n    SET operation_type = 1, "authorized_project_id" = NEW."authorized_project_id", "authorized_public" = NEW."authorized_public", "type" = NEW."type", "start_time" = NEW."start_time", "end_time" = NEW."end_time", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO activity_version\n(transaction_id, operation_type, "authorized_project_id", "authorized_public", "type", "start_time", "end_time", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."authorized_project_id", NEW."authorized_public", NEW."type", NEW."start_time", NEW."end_time", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE activity_version\n    SET "authorized_project_id" = OLD."authorized_project_id", "authorized_public" = OLD."authorized_public", "type" = OLD."type", "start_time" = OLD."start_time", "end_time" = OLD."end_time", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO activity_version\n(transaction_id, operation_type, "authorized_project_id", "authorized_public", "type", "start_time", "end_time", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."authorized_project_id", OLD."authorized_public", OLD."type", OLD."start_time", OLD."end_time", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_activity_audit)

    public_single_neuron_synaptome_audit = PGFunction(
        schema="public",
        signature="single_neuron_synaptome_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE single_neuron_synaptome_version\n    SET operation_type = 1, "id" = NEW."id", "seed" = NEW."seed", "me_model_id" = NEW."me_model_id", "brain_region_id" = NEW."brain_region_id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO single_neuron_synaptome_version\n(transaction_id, operation_type, "id", "seed", "me_model_id", "brain_region_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."seed", NEW."me_model_id", NEW."brain_region_id", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE single_neuron_synaptome_version\n    SET operation_type = 1, "id" = NEW."id", "seed" = NEW."seed", "me_model_id" = NEW."me_model_id", "brain_region_id" = NEW."brain_region_id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO single_neuron_synaptome_version\n(transaction_id, operation_type, "id", "seed", "me_model_id", "brain_region_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."seed", NEW."me_model_id", NEW."brain_region_id", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE single_neuron_synaptome_version\n    SET "id" = OLD."id", "seed" = OLD."seed", "me_model_id" = OLD."me_model_id", "brain_region_id" = OLD."brain_region_id", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO single_neuron_synaptome_version\n(transaction_id, operation_type, "id", "seed", "me_model_id", "brain_region_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."seed", OLD."me_model_id", OLD."brain_region_id", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_single_neuron_synaptome_audit)

    public_ion_channel_modeling_config_generation_audit = PGFunction(
        schema="public",
        signature="ion_channel_modeling_config_generation_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_modeling_config_generation_version\n    SET operation_type = 1, "id" = NEW."id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO ion_channel_modeling_config_generation_version\n(transaction_id, operation_type, "id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_modeling_config_generation_version\n    SET operation_type = 1, "id" = NEW."id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO ion_channel_modeling_config_generation_version\n(transaction_id, operation_type, "id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_modeling_config_generation_version\n    SET "id" = OLD."id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO ion_channel_modeling_config_generation_version\n(transaction_id, operation_type, "id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_ion_channel_modeling_config_generation_audit)

    public_memodel_audit = PGFunction(
        schema="public",
        signature="memodel_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE memodel_version\n    SET operation_type = 1, "id" = NEW."id", "validation_status" = NEW."validation_status", "morphology_id" = NEW."morphology_id", "emodel_id" = NEW."emodel_id", "species_id" = NEW."species_id", "strain_id" = NEW."strain_id", "brain_region_id" = NEW."brain_region_id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO memodel_version\n(transaction_id, operation_type, "id", "validation_status", "morphology_id", "emodel_id", "species_id", "strain_id", "brain_region_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."validation_status", NEW."morphology_id", NEW."emodel_id", NEW."species_id", NEW."strain_id", NEW."brain_region_id", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE memodel_version\n    SET operation_type = 1, "id" = NEW."id", "validation_status" = NEW."validation_status", "morphology_id" = NEW."morphology_id", "emodel_id" = NEW."emodel_id", "species_id" = NEW."species_id", "strain_id" = NEW."strain_id", "brain_region_id" = NEW."brain_region_id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO memodel_version\n(transaction_id, operation_type, "id", "validation_status", "morphology_id", "emodel_id", "species_id", "strain_id", "brain_region_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."validation_status", NEW."morphology_id", NEW."emodel_id", NEW."species_id", NEW."strain_id", NEW."brain_region_id", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE memodel_version\n    SET "id" = OLD."id", "validation_status" = OLD."validation_status", "morphology_id" = OLD."morphology_id", "emodel_id" = OLD."emodel_id", "species_id" = OLD."species_id", "strain_id" = OLD."strain_id", "brain_region_id" = OLD."brain_region_id", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO memodel_version\n(transaction_id, operation_type, "id", "validation_status", "morphology_id", "emodel_id", "species_id", "strain_id", "brain_region_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."validation_status", OLD."morphology_id", OLD."emodel_id", OLD."species_id", OLD."strain_id", OLD."brain_region_id", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_memodel_audit)

    public_em_cell_mesh_audit = PGFunction(
        schema="public",
        signature="em_cell_mesh_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE em_cell_mesh_version\n    SET operation_type = 1, "id" = NEW."id", "em_dense_reconstruction_dataset_id" = NEW."em_dense_reconstruction_dataset_id", "release_version" = NEW."release_version", "dense_reconstruction_cell_id" = NEW."dense_reconstruction_cell_id", "generation_method" = NEW."generation_method", "level_of_detail" = NEW."level_of_detail", "generation_parameters" = NEW."generation_parameters", "mesh_type" = NEW."mesh_type"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO em_cell_mesh_version\n(transaction_id, operation_type, "id", "em_dense_reconstruction_dataset_id", "release_version", "dense_reconstruction_cell_id", "generation_method", "level_of_detail", "generation_parameters", "mesh_type")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."em_dense_reconstruction_dataset_id", NEW."release_version", NEW."dense_reconstruction_cell_id", NEW."generation_method", NEW."level_of_detail", NEW."generation_parameters", NEW."mesh_type"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE em_cell_mesh_version\n    SET operation_type = 1, "id" = NEW."id", "em_dense_reconstruction_dataset_id" = NEW."em_dense_reconstruction_dataset_id", "release_version" = NEW."release_version", "dense_reconstruction_cell_id" = NEW."dense_reconstruction_cell_id", "generation_method" = NEW."generation_method", "level_of_detail" = NEW."level_of_detail", "generation_parameters" = NEW."generation_parameters", "mesh_type" = NEW."mesh_type"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO em_cell_mesh_version\n(transaction_id, operation_type, "id", "em_dense_reconstruction_dataset_id", "release_version", "dense_reconstruction_cell_id", "generation_method", "level_of_detail", "generation_parameters", "mesh_type")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."em_dense_reconstruction_dataset_id", NEW."release_version", NEW."dense_reconstruction_cell_id", NEW."generation_method", NEW."level_of_detail", NEW."generation_parameters", NEW."mesh_type"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE em_cell_mesh_version\n    SET "id" = OLD."id", "em_dense_reconstruction_dataset_id" = OLD."em_dense_reconstruction_dataset_id", "release_version" = OLD."release_version", "dense_reconstruction_cell_id" = OLD."dense_reconstruction_cell_id", "generation_method" = OLD."generation_method", "level_of_detail" = OLD."level_of_detail", "generation_parameters" = OLD."generation_parameters", "mesh_type" = OLD."mesh_type"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO em_cell_mesh_version\n(transaction_id, operation_type, "id", "em_dense_reconstruction_dataset_id", "release_version", "dense_reconstruction_cell_id", "generation_method", "level_of_detail", "generation_parameters", "mesh_type")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."em_dense_reconstruction_dataset_id", OLD."release_version", OLD."dense_reconstruction_cell_id", OLD."generation_method", OLD."level_of_detail", OLD."generation_parameters", OLD."mesh_type"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_em_cell_mesh_audit)

    public_electrical_recording_audit = PGFunction(
        schema="public",
        signature="electrical_recording_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE electrical_recording_version\n    SET operation_type = 1, "id" = NEW."id", "recording_type" = NEW."recording_type", "recording_origin" = NEW."recording_origin", "recording_location" = NEW."recording_location", "ljp" = NEW."ljp", "temperature" = NEW."temperature", "comment" = NEW."comment", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO electrical_recording_version\n(transaction_id, operation_type, "id", "recording_type", "recording_origin", "recording_location", "ljp", "temperature", "comment", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."recording_type", NEW."recording_origin", NEW."recording_location", NEW."ljp", NEW."temperature", NEW."comment", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE electrical_recording_version\n    SET operation_type = 1, "id" = NEW."id", "recording_type" = NEW."recording_type", "recording_origin" = NEW."recording_origin", "recording_location" = NEW."recording_location", "ljp" = NEW."ljp", "temperature" = NEW."temperature", "comment" = NEW."comment", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO electrical_recording_version\n(transaction_id, operation_type, "id", "recording_type", "recording_origin", "recording_location", "ljp", "temperature", "comment", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."recording_type", NEW."recording_origin", NEW."recording_location", NEW."ljp", NEW."temperature", NEW."comment", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE electrical_recording_version\n    SET "id" = OLD."id", "recording_type" = OLD."recording_type", "recording_origin" = OLD."recording_origin", "recording_location" = OLD."recording_location", "ljp" = OLD."ljp", "temperature" = OLD."temperature", "comment" = OLD."comment", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO electrical_recording_version\n(transaction_id, operation_type, "id", "recording_type", "recording_origin", "recording_location", "ljp", "temperature", "comment", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."recording_type", OLD."recording_origin", OLD."recording_location", OLD."ljp", OLD."temperature", OLD."comment", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_electrical_recording_audit)

    public_circuit_extraction_config_generation_audit = PGFunction(
        schema="public",
        signature="circuit_extraction_config_generation_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE circuit_extraction_config_generation_version\n    SET operation_type = 1, "id" = NEW."id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO circuit_extraction_config_generation_version\n(transaction_id, operation_type, "id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE circuit_extraction_config_generation_version\n    SET operation_type = 1, "id" = NEW."id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO circuit_extraction_config_generation_version\n(transaction_id, operation_type, "id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE circuit_extraction_config_generation_version\n    SET "id" = OLD."id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO circuit_extraction_config_generation_version\n(transaction_id, operation_type, "id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_circuit_extraction_config_generation_audit)

    public_validation_result_audit = PGFunction(
        schema="public",
        signature="validation_result_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE validation_result_version\n    SET operation_type = 1, "id" = NEW."id", "passed" = NEW."passed", "name" = NEW."name", "validated_entity_id" = NEW."validated_entity_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO validation_result_version\n(transaction_id, operation_type, "id", "passed", "name", "validated_entity_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."passed", NEW."name", NEW."validated_entity_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE validation_result_version\n    SET operation_type = 1, "id" = NEW."id", "passed" = NEW."passed", "name" = NEW."name", "validated_entity_id" = NEW."validated_entity_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO validation_result_version\n(transaction_id, operation_type, "id", "passed", "name", "validated_entity_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."passed", NEW."name", NEW."validated_entity_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE validation_result_version\n    SET "id" = OLD."id", "passed" = OLD."passed", "name" = OLD."name", "validated_entity_id" = OLD."validated_entity_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO validation_result_version\n(transaction_id, operation_type, "id", "passed", "name", "validated_entity_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."passed", OLD."name", OLD."validated_entity_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_validation_result_audit)

    public_ion_audit = PGFunction(
        schema="public",
        signature="ion_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE ion_version\n    SET operation_type = 1, "id" = NEW."id", "name" = NEW."name", "ontology_id" = NEW."ontology_id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO ion_version\n(transaction_id, operation_type, "id", "name", "ontology_id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."name", NEW."ontology_id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE ion_version\n    SET operation_type = 1, "id" = NEW."id", "name" = NEW."name", "ontology_id" = NEW."ontology_id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO ion_version\n(transaction_id, operation_type, "id", "name", "ontology_id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."name", NEW."ontology_id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE ion_version\n    SET "id" = OLD."id", "name" = OLD."name", "ontology_id" = OLD."ontology_id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO ion_version\n(transaction_id, operation_type, "id", "name", "ontology_id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."name", OLD."ontology_id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_ion_audit)

    public_strain_audit = PGFunction(
        schema="public",
        signature="strain_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE strain_version\n    SET operation_type = 1, "name" = NEW."name", "taxonomy_id" = NEW."taxonomy_id", "species_id" = NEW."species_id", "embedding" = NEW."embedding", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO strain_version\n(transaction_id, operation_type, "name", "taxonomy_id", "species_id", "embedding", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."name", NEW."taxonomy_id", NEW."species_id", NEW."embedding", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE strain_version\n    SET operation_type = 1, "name" = NEW."name", "taxonomy_id" = NEW."taxonomy_id", "species_id" = NEW."species_id", "embedding" = NEW."embedding", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO strain_version\n(transaction_id, operation_type, "name", "taxonomy_id", "species_id", "embedding", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."name", NEW."taxonomy_id", NEW."species_id", NEW."embedding", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE strain_version\n    SET "name" = OLD."name", "taxonomy_id" = OLD."taxonomy_id", "species_id" = OLD."species_id", "embedding" = OLD."embedding", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO strain_version\n(transaction_id, operation_type, "name", "taxonomy_id", "species_id", "embedding", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."name", OLD."taxonomy_id", OLD."species_id", OLD."embedding", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_strain_audit)

    public_brain_region_hierarchy_audit = PGFunction(
        schema="public",
        signature="brain_region_hierarchy_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE brain_region_hierarchy_version\n    SET operation_type = 1, "name" = NEW."name", "species_id" = NEW."species_id", "strain_id" = NEW."strain_id", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO brain_region_hierarchy_version\n(transaction_id, operation_type, "name", "species_id", "strain_id", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."name", NEW."species_id", NEW."strain_id", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE brain_region_hierarchy_version\n    SET operation_type = 1, "name" = NEW."name", "species_id" = NEW."species_id", "strain_id" = NEW."strain_id", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO brain_region_hierarchy_version\n(transaction_id, operation_type, "name", "species_id", "strain_id", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."name", NEW."species_id", NEW."strain_id", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE brain_region_hierarchy_version\n    SET "name" = OLD."name", "species_id" = OLD."species_id", "strain_id" = OLD."strain_id", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO brain_region_hierarchy_version\n(transaction_id, operation_type, "name", "species_id", "strain_id", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."name", OLD."species_id", OLD."strain_id", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_brain_region_hierarchy_audit)

    public_analysis_notebook_result_audit = PGFunction(
        schema="public",
        signature="analysis_notebook_result_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE analysis_notebook_result_version\n    SET operation_type = 1, "id" = NEW."id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO analysis_notebook_result_version\n(transaction_id, operation_type, "id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE analysis_notebook_result_version\n    SET operation_type = 1, "id" = NEW."id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO analysis_notebook_result_version\n(transaction_id, operation_type, "id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE analysis_notebook_result_version\n    SET "id" = OLD."id", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO analysis_notebook_result_version\n(transaction_id, operation_type, "id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_analysis_notebook_result_audit)

    public_analysis_notebook_template_audit = PGFunction(
        schema="public",
        signature="analysis_notebook_template_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE analysis_notebook_template_version\n    SET operation_type = 1, "id" = NEW."id", "scale" = NEW."scale", "specifications" = NEW."specifications", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO analysis_notebook_template_version\n(transaction_id, operation_type, "id", "scale", "specifications", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."scale", NEW."specifications", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE analysis_notebook_template_version\n    SET operation_type = 1, "id" = NEW."id", "scale" = NEW."scale", "specifications" = NEW."specifications", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO analysis_notebook_template_version\n(transaction_id, operation_type, "id", "scale", "specifications", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."scale", NEW."specifications", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE analysis_notebook_template_version\n    SET "id" = OLD."id", "scale" = OLD."scale", "specifications" = OLD."specifications", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO analysis_notebook_template_version\n(transaction_id, operation_type, "id", "scale", "specifications", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."scale", OLD."specifications", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_analysis_notebook_template_audit)

    public_single_neuron_simulation_audit = PGFunction(
        schema="public",
        signature="single_neuron_simulation_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE single_neuron_simulation_version\n    SET operation_type = 1, "id" = NEW."id", "seed" = NEW."seed", "injection_location" = NEW."injection_location", "recording_location" = NEW."recording_location", "status" = NEW."status", "me_model_id" = NEW."me_model_id", "brain_region_id" = NEW."brain_region_id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO single_neuron_simulation_version\n(transaction_id, operation_type, "id", "seed", "injection_location", "recording_location", "status", "me_model_id", "brain_region_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."seed", NEW."injection_location", NEW."recording_location", NEW."status", NEW."me_model_id", NEW."brain_region_id", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE single_neuron_simulation_version\n    SET operation_type = 1, "id" = NEW."id", "seed" = NEW."seed", "injection_location" = NEW."injection_location", "recording_location" = NEW."recording_location", "status" = NEW."status", "me_model_id" = NEW."me_model_id", "brain_region_id" = NEW."brain_region_id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO single_neuron_simulation_version\n(transaction_id, operation_type, "id", "seed", "injection_location", "recording_location", "status", "me_model_id", "brain_region_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."seed", NEW."injection_location", NEW."recording_location", NEW."status", NEW."me_model_id", NEW."brain_region_id", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE single_neuron_simulation_version\n    SET "id" = OLD."id", "seed" = OLD."seed", "injection_location" = OLD."injection_location", "recording_location" = OLD."recording_location", "status" = OLD."status", "me_model_id" = OLD."me_model_id", "brain_region_id" = OLD."brain_region_id", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO single_neuron_simulation_version\n(transaction_id, operation_type, "id", "seed", "injection_location", "recording_location", "status", "me_model_id", "brain_region_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."seed", OLD."injection_location", OLD."recording_location", OLD."status", OLD."me_model_id", OLD."brain_region_id", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_single_neuron_simulation_audit)

    public_analysis_notebook_execution_audit = PGFunction(
        schema="public",
        signature="analysis_notebook_execution_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE analysis_notebook_execution_version\n    SET operation_type = 1, "id" = NEW."id", "analysis_notebook_template_id" = NEW."analysis_notebook_template_id", "analysis_notebook_environment_id" = NEW."analysis_notebook_environment_id", "executor" = NEW."executor", "execution_id" = NEW."execution_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO analysis_notebook_execution_version\n(transaction_id, operation_type, "id", "analysis_notebook_template_id", "analysis_notebook_environment_id", "executor", "execution_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."analysis_notebook_template_id", NEW."analysis_notebook_environment_id", NEW."executor", NEW."execution_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE analysis_notebook_execution_version\n    SET operation_type = 1, "id" = NEW."id", "analysis_notebook_template_id" = NEW."analysis_notebook_template_id", "analysis_notebook_environment_id" = NEW."analysis_notebook_environment_id", "executor" = NEW."executor", "execution_id" = NEW."execution_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO analysis_notebook_execution_version\n(transaction_id, operation_type, "id", "analysis_notebook_template_id", "analysis_notebook_environment_id", "executor", "execution_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."analysis_notebook_template_id", NEW."analysis_notebook_environment_id", NEW."executor", NEW."execution_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE analysis_notebook_execution_version\n    SET "id" = OLD."id", "analysis_notebook_template_id" = OLD."analysis_notebook_template_id", "analysis_notebook_environment_id" = OLD."analysis_notebook_environment_id", "executor" = OLD."executor", "execution_id" = OLD."execution_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO analysis_notebook_execution_version\n(transaction_id, operation_type, "id", "analysis_notebook_template_id", "analysis_notebook_environment_id", "executor", "execution_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."analysis_notebook_template_id", OLD."analysis_notebook_environment_id", OLD."executor", OLD."execution_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_analysis_notebook_execution_audit)

    public_ion_channel_recording_audit = PGFunction(
        schema="public",
        signature="ion_channel_recording_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_recording_version\n    SET operation_type = 1, "id" = NEW."id", "cell_line" = NEW."cell_line", "ion_channel_id" = NEW."ion_channel_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO ion_channel_recording_version\n(transaction_id, operation_type, "id", "cell_line", "ion_channel_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."cell_line", NEW."ion_channel_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_recording_version\n    SET operation_type = 1, "id" = NEW."id", "cell_line" = NEW."cell_line", "ion_channel_id" = NEW."ion_channel_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO ion_channel_recording_version\n(transaction_id, operation_type, "id", "cell_line", "ion_channel_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."cell_line", NEW."ion_channel_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_recording_version\n    SET "id" = OLD."id", "cell_line" = OLD."cell_line", "ion_channel_id" = OLD."ion_channel_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO ion_channel_recording_version\n(transaction_id, operation_type, "id", "cell_line", "ion_channel_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."cell_line", OLD."ion_channel_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_ion_channel_recording_audit)

    public_consortium_audit = PGFunction(
        schema="public",
        signature="consortium_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE consortium_version\n    SET operation_type = 1, "id" = NEW."id", "alternative_name" = NEW."alternative_name"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO consortium_version\n(transaction_id, operation_type, "id", "alternative_name")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."alternative_name"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE consortium_version\n    SET operation_type = 1, "id" = NEW."id", "alternative_name" = NEW."alternative_name"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO consortium_version\n(transaction_id, operation_type, "id", "alternative_name")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."alternative_name"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE consortium_version\n    SET "id" = OLD."id", "alternative_name" = OLD."alternative_name"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO consortium_version\n(transaction_id, operation_type, "id", "alternative_name")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."alternative_name"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_consortium_audit)

    public_subject_audit = PGFunction(
        schema="public",
        signature="subject_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE subject_version\n    SET operation_type = 1, "id" = NEW."id", "age_value" = NEW."age_value", "age_min" = NEW."age_min", "age_max" = NEW."age_max", "age_period" = NEW."age_period", "sex" = NEW."sex", "weight" = NEW."weight", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector", "species_id" = NEW."species_id", "strain_id" = NEW."strain_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO subject_version\n(transaction_id, operation_type, "id", "age_value", "age_min", "age_max", "age_period", "sex", "weight", "name", "description", "description_vector", "species_id", "strain_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."age_value", NEW."age_min", NEW."age_max", NEW."age_period", NEW."sex", NEW."weight", NEW."name", NEW."description", NEW."description_vector", NEW."species_id", NEW."strain_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE subject_version\n    SET operation_type = 1, "id" = NEW."id", "age_value" = NEW."age_value", "age_min" = NEW."age_min", "age_max" = NEW."age_max", "age_period" = NEW."age_period", "sex" = NEW."sex", "weight" = NEW."weight", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector", "species_id" = NEW."species_id", "strain_id" = NEW."strain_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO subject_version\n(transaction_id, operation_type, "id", "age_value", "age_min", "age_max", "age_period", "sex", "weight", "name", "description", "description_vector", "species_id", "strain_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."age_value", NEW."age_min", NEW."age_max", NEW."age_period", NEW."sex", NEW."weight", NEW."name", NEW."description", NEW."description_vector", NEW."species_id", NEW."strain_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE subject_version\n    SET "id" = OLD."id", "age_value" = OLD."age_value", "age_min" = OLD."age_min", "age_max" = OLD."age_max", "age_period" = OLD."age_period", "sex" = OLD."sex", "weight" = OLD."weight", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector", "species_id" = OLD."species_id", "strain_id" = OLD."strain_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO subject_version\n(transaction_id, operation_type, "id", "age_value", "age_min", "age_max", "age_period", "sex", "weight", "name", "description", "description_vector", "species_id", "strain_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."age_value", OLD."age_min", OLD."age_max", OLD."age_period", OLD."sex", OLD."weight", OLD."name", OLD."description", OLD."description_vector", OLD."species_id", OLD."strain_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_subject_audit)

    public_single_neuron_synaptome_simulation_audit = PGFunction(
        schema="public",
        signature="single_neuron_synaptome_simulation_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE single_neuron_synaptome_simulation_version\n    SET operation_type = 1, "id" = NEW."id", "seed" = NEW."seed", "injection_location" = NEW."injection_location", "recording_location" = NEW."recording_location", "status" = NEW."status", "synaptome_id" = NEW."synaptome_id", "brain_region_id" = NEW."brain_region_id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO single_neuron_synaptome_simulation_version\n(transaction_id, operation_type, "id", "seed", "injection_location", "recording_location", "status", "synaptome_id", "brain_region_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."seed", NEW."injection_location", NEW."recording_location", NEW."status", NEW."synaptome_id", NEW."brain_region_id", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE single_neuron_synaptome_simulation_version\n    SET operation_type = 1, "id" = NEW."id", "seed" = NEW."seed", "injection_location" = NEW."injection_location", "recording_location" = NEW."recording_location", "status" = NEW."status", "synaptome_id" = NEW."synaptome_id", "brain_region_id" = NEW."brain_region_id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO single_neuron_synaptome_simulation_version\n(transaction_id, operation_type, "id", "seed", "injection_location", "recording_location", "status", "synaptome_id", "brain_region_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."seed", NEW."injection_location", NEW."recording_location", NEW."status", NEW."synaptome_id", NEW."brain_region_id", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE single_neuron_synaptome_simulation_version\n    SET "id" = OLD."id", "seed" = OLD."seed", "injection_location" = OLD."injection_location", "recording_location" = OLD."recording_location", "status" = OLD."status", "synaptome_id" = OLD."synaptome_id", "brain_region_id" = OLD."brain_region_id", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO single_neuron_synaptome_simulation_version\n(transaction_id, operation_type, "id", "seed", "injection_location", "recording_location", "status", "synaptome_id", "brain_region_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."seed", OLD."injection_location", OLD."recording_location", OLD."status", OLD."synaptome_id", OLD."brain_region_id", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_single_neuron_synaptome_simulation_audit)

    public_electrical_recording_stimulus_audit = PGFunction(
        schema="public",
        signature="electrical_recording_stimulus_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE electrical_recording_stimulus_version\n    SET operation_type = 1, "id" = NEW."id", "dt" = NEW."dt", "injection_type" = NEW."injection_type", "shape" = NEW."shape", "start_time" = NEW."start_time", "end_time" = NEW."end_time", "recording_id" = NEW."recording_id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO electrical_recording_stimulus_version\n(transaction_id, operation_type, "id", "dt", "injection_type", "shape", "start_time", "end_time", "recording_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."dt", NEW."injection_type", NEW."shape", NEW."start_time", NEW."end_time", NEW."recording_id", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE electrical_recording_stimulus_version\n    SET operation_type = 1, "id" = NEW."id", "dt" = NEW."dt", "injection_type" = NEW."injection_type", "shape" = NEW."shape", "start_time" = NEW."start_time", "end_time" = NEW."end_time", "recording_id" = NEW."recording_id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO electrical_recording_stimulus_version\n(transaction_id, operation_type, "id", "dt", "injection_type", "shape", "start_time", "end_time", "recording_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."dt", NEW."injection_type", NEW."shape", NEW."start_time", NEW."end_time", NEW."recording_id", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE electrical_recording_stimulus_version\n    SET "id" = OLD."id", "dt" = OLD."dt", "injection_type" = OLD."injection_type", "shape" = OLD."shape", "start_time" = OLD."start_time", "end_time" = OLD."end_time", "recording_id" = OLD."recording_id", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO electrical_recording_stimulus_version\n(transaction_id, operation_type, "id", "dt", "injection_type", "shape", "start_time", "end_time", "recording_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."dt", OLD."injection_type", OLD."shape", OLD."start_time", OLD."end_time", OLD."recording_id", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_electrical_recording_stimulus_audit)

    public_publication_audit = PGFunction(
        schema="public",
        signature="publication_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE publication_version\n    SET operation_type = 1, "DOI" = NEW."DOI", "title" = NEW."title", "authors" = NEW."authors", "publication_year" = NEW."publication_year", "abstract" = NEW."abstract", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO publication_version\n(transaction_id, operation_type, "DOI", "title", "authors", "publication_year", "abstract", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."DOI", NEW."title", NEW."authors", NEW."publication_year", NEW."abstract", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE publication_version\n    SET operation_type = 1, "DOI" = NEW."DOI", "title" = NEW."title", "authors" = NEW."authors", "publication_year" = NEW."publication_year", "abstract" = NEW."abstract", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO publication_version\n(transaction_id, operation_type, "DOI", "title", "authors", "publication_year", "abstract", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."DOI", NEW."title", NEW."authors", NEW."publication_year", NEW."abstract", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE publication_version\n    SET "DOI" = OLD."DOI", "title" = OLD."title", "authors" = OLD."authors", "publication_year" = OLD."publication_year", "abstract" = OLD."abstract", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO publication_version\n(transaction_id, operation_type, "DOI", "title", "authors", "publication_year", "abstract", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."DOI", OLD."title", OLD."authors", OLD."publication_year", OLD."abstract", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_publication_audit)

    public_derivation_audit = PGFunction(
        schema="public",
        signature="derivation_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE derivation_version\n    SET operation_type = 1, "used_id" = NEW."used_id", "generated_id" = NEW."generated_id", "derivation_type" = NEW."derivation_type"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "used_id" = NEW."used_id" AND "generated_id" = NEW."generated_id"\n    RETURNING *\n)\nINSERT INTO derivation_version\n(transaction_id, operation_type, "used_id", "generated_id", "derivation_type")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."used_id", NEW."generated_id", NEW."derivation_type"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE derivation_version\n    SET operation_type = 1, "used_id" = NEW."used_id", "generated_id" = NEW."generated_id", "derivation_type" = NEW."derivation_type"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "used_id" = NEW."used_id" AND "generated_id" = NEW."generated_id"\n    RETURNING *\n)\nINSERT INTO derivation_version\n(transaction_id, operation_type, "used_id", "generated_id", "derivation_type")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."used_id", NEW."generated_id", NEW."derivation_type"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE derivation_version\n    SET "used_id" = OLD."used_id", "generated_id" = OLD."generated_id", "derivation_type" = OLD."derivation_type"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "used_id" = OLD."used_id" AND "generated_id" = OLD."generated_id"\n    RETURNING *\n)\nINSERT INTO derivation_version\n(transaction_id, operation_type, "used_id", "generated_id", "derivation_type")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."used_id", OLD."generated_id", OLD."derivation_type"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_derivation_audit)

    public_brain_atlas_region_audit = PGFunction(
        schema="public",
        signature="brain_atlas_region_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE brain_atlas_region_version\n    SET operation_type = 1, "id" = NEW."id", "volume" = NEW."volume", "is_leaf_region" = NEW."is_leaf_region", "brain_atlas_id" = NEW."brain_atlas_id", "brain_region_id" = NEW."brain_region_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO brain_atlas_region_version\n(transaction_id, operation_type, "id", "volume", "is_leaf_region", "brain_atlas_id", "brain_region_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."volume", NEW."is_leaf_region", NEW."brain_atlas_id", NEW."brain_region_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE brain_atlas_region_version\n    SET operation_type = 1, "id" = NEW."id", "volume" = NEW."volume", "is_leaf_region" = NEW."is_leaf_region", "brain_atlas_id" = NEW."brain_atlas_id", "brain_region_id" = NEW."brain_region_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO brain_atlas_region_version\n(transaction_id, operation_type, "id", "volume", "is_leaf_region", "brain_atlas_id", "brain_region_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."volume", NEW."is_leaf_region", NEW."brain_atlas_id", NEW."brain_region_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE brain_atlas_region_version\n    SET "id" = OLD."id", "volume" = OLD."volume", "is_leaf_region" = OLD."is_leaf_region", "brain_atlas_id" = OLD."brain_atlas_id", "brain_region_id" = OLD."brain_region_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO brain_atlas_region_version\n(transaction_id, operation_type, "id", "volume", "is_leaf_region", "brain_atlas_id", "brain_region_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."volume", OLD."is_leaf_region", OLD."brain_atlas_id", OLD."brain_region_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_brain_atlas_region_audit)

    public_emodel_audit = PGFunction(
        schema="public",
        signature="emodel_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE emodel_version\n    SET operation_type = 1, "id" = NEW."id", "eModel" = NEW."eModel", "eType" = NEW."eType", "iteration" = NEW."iteration", "score" = NEW."score", "seed" = NEW."seed", "exemplar_morphology_id" = NEW."exemplar_morphology_id", "species_id" = NEW."species_id", "strain_id" = NEW."strain_id", "brain_region_id" = NEW."brain_region_id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO emodel_version\n(transaction_id, operation_type, "id", "eModel", "eType", "iteration", "score", "seed", "exemplar_morphology_id", "species_id", "strain_id", "brain_region_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."eModel", NEW."eType", NEW."iteration", NEW."score", NEW."seed", NEW."exemplar_morphology_id", NEW."species_id", NEW."strain_id", NEW."brain_region_id", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE emodel_version\n    SET operation_type = 1, "id" = NEW."id", "eModel" = NEW."eModel", "eType" = NEW."eType", "iteration" = NEW."iteration", "score" = NEW."score", "seed" = NEW."seed", "exemplar_morphology_id" = NEW."exemplar_morphology_id", "species_id" = NEW."species_id", "strain_id" = NEW."strain_id", "brain_region_id" = NEW."brain_region_id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO emodel_version\n(transaction_id, operation_type, "id", "eModel", "eType", "iteration", "score", "seed", "exemplar_morphology_id", "species_id", "strain_id", "brain_region_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."eModel", NEW."eType", NEW."iteration", NEW."score", NEW."seed", NEW."exemplar_morphology_id", NEW."species_id", NEW."strain_id", NEW."brain_region_id", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE emodel_version\n    SET "id" = OLD."id", "eModel" = OLD."eModel", "eType" = OLD."eType", "iteration" = OLD."iteration", "score" = OLD."score", "seed" = OLD."seed", "exemplar_morphology_id" = OLD."exemplar_morphology_id", "species_id" = OLD."species_id", "strain_id" = OLD."strain_id", "brain_region_id" = OLD."brain_region_id", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO emodel_version\n(transaction_id, operation_type, "id", "eModel", "eType", "iteration", "score", "seed", "exemplar_morphology_id", "species_id", "strain_id", "brain_region_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."eModel", OLD."eType", OLD."iteration", OLD."score", OLD."seed", OLD."exemplar_morphology_id", OLD."species_id", OLD."strain_id", OLD."brain_region_id", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_emodel_audit)

    public_skeletonization_campaign_audit = PGFunction(
        schema="public",
        signature="skeletonization_campaign_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE skeletonization_campaign_version\n    SET operation_type = 1, "id" = NEW."id", "scan_parameters" = NEW."scan_parameters", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO skeletonization_campaign_version\n(transaction_id, operation_type, "id", "scan_parameters", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."scan_parameters", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE skeletonization_campaign_version\n    SET operation_type = 1, "id" = NEW."id", "scan_parameters" = NEW."scan_parameters", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO skeletonization_campaign_version\n(transaction_id, operation_type, "id", "scan_parameters", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."scan_parameters", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE skeletonization_campaign_version\n    SET "id" = OLD."id", "scan_parameters" = OLD."scan_parameters", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO skeletonization_campaign_version\n(transaction_id, operation_type, "id", "scan_parameters", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."scan_parameters", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_skeletonization_campaign_audit)

    public_contribution_audit = PGFunction(
        schema="public",
        signature="contribution_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE contribution_version\n    SET operation_type = 1, "agent_id" = NEW."agent_id", "role_id" = NEW."role_id", "entity_id" = NEW."entity_id", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO contribution_version\n(transaction_id, operation_type, "agent_id", "role_id", "entity_id", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."agent_id", NEW."role_id", NEW."entity_id", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE contribution_version\n    SET operation_type = 1, "agent_id" = NEW."agent_id", "role_id" = NEW."role_id", "entity_id" = NEW."entity_id", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO contribution_version\n(transaction_id, operation_type, "agent_id", "role_id", "entity_id", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."agent_id", NEW."role_id", NEW."entity_id", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE contribution_version\n    SET "agent_id" = OLD."agent_id", "role_id" = OLD."role_id", "entity_id" = OLD."entity_id", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO contribution_version\n(transaction_id, operation_type, "agent_id", "role_id", "entity_id", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."agent_id", OLD."role_id", OLD."entity_id", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_contribution_audit)

    public_ion_channel_modeling_config_audit = PGFunction(
        schema="public",
        signature="ion_channel_modeling_config_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_modeling_config_version\n    SET operation_type = 1, "id" = NEW."id", "ion_channel_modeling_campaign_id" = NEW."ion_channel_modeling_campaign_id", "scan_parameters" = NEW."scan_parameters", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO ion_channel_modeling_config_version\n(transaction_id, operation_type, "id", "ion_channel_modeling_campaign_id", "scan_parameters", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."ion_channel_modeling_campaign_id", NEW."scan_parameters", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_modeling_config_version\n    SET operation_type = 1, "id" = NEW."id", "ion_channel_modeling_campaign_id" = NEW."ion_channel_modeling_campaign_id", "scan_parameters" = NEW."scan_parameters", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO ion_channel_modeling_config_version\n(transaction_id, operation_type, "id", "ion_channel_modeling_campaign_id", "scan_parameters", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."ion_channel_modeling_campaign_id", NEW."scan_parameters", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_modeling_config_version\n    SET "id" = OLD."id", "ion_channel_modeling_campaign_id" = OLD."ion_channel_modeling_campaign_id", "scan_parameters" = OLD."scan_parameters", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO ion_channel_modeling_config_version\n(transaction_id, operation_type, "id", "ion_channel_modeling_campaign_id", "scan_parameters", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."ion_channel_modeling_campaign_id", OLD."scan_parameters", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_ion_channel_modeling_config_audit)

    public_datamaturity_annotation_body_audit = PGFunction(
        schema="public",
        signature="datamaturity_annotation_body_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE datamaturity_annotation_body_version\n    SET operation_type = 1, "id" = NEW."id", "pref_label" = NEW."pref_label"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO datamaturity_annotation_body_version\n(transaction_id, operation_type, "id", "pref_label")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."pref_label"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE datamaturity_annotation_body_version\n    SET operation_type = 1, "id" = NEW."id", "pref_label" = NEW."pref_label"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO datamaturity_annotation_body_version\n(transaction_id, operation_type, "id", "pref_label")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."pref_label"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE datamaturity_annotation_body_version\n    SET "id" = OLD."id", "pref_label" = OLD."pref_label"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO datamaturity_annotation_body_version\n(transaction_id, operation_type, "id", "pref_label")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."pref_label"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_datamaturity_annotation_body_audit)

    public_person_audit = PGFunction(
        schema="public",
        signature="person_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE person_version\n    SET operation_type = 1, "id" = NEW."id", "given_name" = NEW."given_name", "family_name" = NEW."family_name", "sub_id" = NEW."sub_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO person_version\n(transaction_id, operation_type, "id", "given_name", "family_name", "sub_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."given_name", NEW."family_name", NEW."sub_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE person_version\n    SET operation_type = 1, "id" = NEW."id", "given_name" = NEW."given_name", "family_name" = NEW."family_name", "sub_id" = NEW."sub_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO person_version\n(transaction_id, operation_type, "id", "given_name", "family_name", "sub_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."given_name", NEW."family_name", NEW."sub_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE person_version\n    SET "id" = OLD."id", "given_name" = OLD."given_name", "family_name" = OLD."family_name", "sub_id" = OLD."sub_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO person_version\n(transaction_id, operation_type, "id", "given_name", "family_name", "sub_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."given_name", OLD."family_name", OLD."sub_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_person_audit)

    public_validation_audit = PGFunction(
        schema="public",
        signature="validation_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE validation_version\n    SET operation_type = 1, "id" = NEW."id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO validation_version\n(transaction_id, operation_type, "id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE validation_version\n    SET operation_type = 1, "id" = NEW."id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO validation_version\n(transaction_id, operation_type, "id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE validation_version\n    SET "id" = OLD."id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO validation_version\n(transaction_id, operation_type, "id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_validation_audit)

    public_simulation_result_audit = PGFunction(
        schema="public",
        signature="simulation_result_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE simulation_result_version\n    SET operation_type = 1, "id" = NEW."id", "simulation_id" = NEW."simulation_id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO simulation_result_version\n(transaction_id, operation_type, "id", "simulation_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."simulation_id", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE simulation_result_version\n    SET operation_type = 1, "id" = NEW."id", "simulation_id" = NEW."simulation_id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO simulation_result_version\n(transaction_id, operation_type, "id", "simulation_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."simulation_id", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE simulation_result_version\n    SET "id" = OLD."id", "simulation_id" = OLD."simulation_id", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO simulation_result_version\n(transaction_id, operation_type, "id", "simulation_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."simulation_id", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_simulation_result_audit)

    public_cell_morphology_protocol_audit = PGFunction(
        schema="public",
        signature="cell_morphology_protocol_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE cell_morphology_protocol_version\n    SET operation_type = 1, "id" = NEW."id", "protocol_document" = NEW."protocol_document", "protocol_design" = NEW."protocol_design", "generation_type" = NEW."generation_type", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector", "staining_type" = NEW."staining_type", "slicing_thickness" = NEW."slicing_thickness", "slicing_direction" = NEW."slicing_direction", "magnification" = NEW."magnification", "tissue_shrinkage" = NEW."tissue_shrinkage", "corrected_for_shrinkage" = NEW."corrected_for_shrinkage", "method_type" = NEW."method_type"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO cell_morphology_protocol_version\n(transaction_id, operation_type, "id", "protocol_document", "protocol_design", "generation_type", "name", "description", "description_vector", "staining_type", "slicing_thickness", "slicing_direction", "magnification", "tissue_shrinkage", "corrected_for_shrinkage", "method_type")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."protocol_document", NEW."protocol_design", NEW."generation_type", NEW."name", NEW."description", NEW."description_vector", NEW."staining_type", NEW."slicing_thickness", NEW."slicing_direction", NEW."magnification", NEW."tissue_shrinkage", NEW."corrected_for_shrinkage", NEW."method_type"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE cell_morphology_protocol_version\n    SET operation_type = 1, "id" = NEW."id", "protocol_document" = NEW."protocol_document", "protocol_design" = NEW."protocol_design", "generation_type" = NEW."generation_type", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector", "staining_type" = NEW."staining_type", "slicing_thickness" = NEW."slicing_thickness", "slicing_direction" = NEW."slicing_direction", "magnification" = NEW."magnification", "tissue_shrinkage" = NEW."tissue_shrinkage", "corrected_for_shrinkage" = NEW."corrected_for_shrinkage", "method_type" = NEW."method_type"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO cell_morphology_protocol_version\n(transaction_id, operation_type, "id", "protocol_document", "protocol_design", "generation_type", "name", "description", "description_vector", "staining_type", "slicing_thickness", "slicing_direction", "magnification", "tissue_shrinkage", "corrected_for_shrinkage", "method_type")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."protocol_document", NEW."protocol_design", NEW."generation_type", NEW."name", NEW."description", NEW."description_vector", NEW."staining_type", NEW."slicing_thickness", NEW."slicing_direction", NEW."magnification", NEW."tissue_shrinkage", NEW."corrected_for_shrinkage", NEW."method_type"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE cell_morphology_protocol_version\n    SET "id" = OLD."id", "protocol_document" = OLD."protocol_document", "protocol_design" = OLD."protocol_design", "generation_type" = OLD."generation_type", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector", "staining_type" = OLD."staining_type", "slicing_thickness" = OLD."slicing_thickness", "slicing_direction" = OLD."slicing_direction", "magnification" = OLD."magnification", "tissue_shrinkage" = OLD."tissue_shrinkage", "corrected_for_shrinkage" = OLD."corrected_for_shrinkage", "method_type" = OLD."method_type"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO cell_morphology_protocol_version\n(transaction_id, operation_type, "id", "protocol_document", "protocol_design", "generation_type", "name", "description", "description_vector", "staining_type", "slicing_thickness", "slicing_direction", "magnification", "tissue_shrinkage", "corrected_for_shrinkage", "method_type")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."protocol_document", OLD."protocol_design", OLD."generation_type", OLD."name", OLD."description", OLD."description_vector", OLD."staining_type", OLD."slicing_thickness", OLD."slicing_direction", OLD."magnification", OLD."tissue_shrinkage", OLD."corrected_for_shrinkage", OLD."method_type"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_cell_morphology_protocol_audit)

    public_circuit_extraction_execution_audit = PGFunction(
        schema="public",
        signature="circuit_extraction_execution_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE circuit_extraction_execution_version\n    SET operation_type = 1, "id" = NEW."id", "status" = NEW."status", "executor" = NEW."executor", "execution_id" = NEW."execution_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO circuit_extraction_execution_version\n(transaction_id, operation_type, "id", "status", "executor", "execution_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."status", NEW."executor", NEW."execution_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE circuit_extraction_execution_version\n    SET operation_type = 1, "id" = NEW."id", "status" = NEW."status", "executor" = NEW."executor", "execution_id" = NEW."execution_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO circuit_extraction_execution_version\n(transaction_id, operation_type, "id", "status", "executor", "execution_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."status", NEW."executor", NEW."execution_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE circuit_extraction_execution_version\n    SET "id" = OLD."id", "status" = OLD."status", "executor" = OLD."executor", "execution_id" = OLD."execution_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO circuit_extraction_execution_version\n(transaction_id, operation_type, "id", "status", "executor", "execution_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."status", OLD."executor", OLD."execution_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_circuit_extraction_execution_audit)

    public_ion_channel_model_audit = PGFunction(
        schema="public",
        signature="ion_channel_model_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_model_version\n    SET operation_type = 1, "id" = NEW."id", "is_ljp_corrected" = NEW."is_ljp_corrected", "is_temperature_dependent" = NEW."is_temperature_dependent", "temperature_celsius" = NEW."temperature_celsius", "is_stochastic" = NEW."is_stochastic", "nmodl_suffix" = NEW."nmodl_suffix", "neuron_block" = NEW."neuron_block", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO ion_channel_model_version\n(transaction_id, operation_type, "id", "is_ljp_corrected", "is_temperature_dependent", "temperature_celsius", "is_stochastic", "nmodl_suffix", "neuron_block", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."is_ljp_corrected", NEW."is_temperature_dependent", NEW."temperature_celsius", NEW."is_stochastic", NEW."nmodl_suffix", NEW."neuron_block", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_model_version\n    SET operation_type = 1, "id" = NEW."id", "is_ljp_corrected" = NEW."is_ljp_corrected", "is_temperature_dependent" = NEW."is_temperature_dependent", "temperature_celsius" = NEW."temperature_celsius", "is_stochastic" = NEW."is_stochastic", "nmodl_suffix" = NEW."nmodl_suffix", "neuron_block" = NEW."neuron_block", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO ion_channel_model_version\n(transaction_id, operation_type, "id", "is_ljp_corrected", "is_temperature_dependent", "temperature_celsius", "is_stochastic", "nmodl_suffix", "neuron_block", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."is_ljp_corrected", NEW."is_temperature_dependent", NEW."temperature_celsius", NEW."is_stochastic", NEW."nmodl_suffix", NEW."neuron_block", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_model_version\n    SET "id" = OLD."id", "is_ljp_corrected" = OLD."is_ljp_corrected", "is_temperature_dependent" = OLD."is_temperature_dependent", "temperature_celsius" = OLD."temperature_celsius", "is_stochastic" = OLD."is_stochastic", "nmodl_suffix" = OLD."nmodl_suffix", "neuron_block" = OLD."neuron_block", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO ion_channel_model_version\n(transaction_id, operation_type, "id", "is_ljp_corrected", "is_temperature_dependent", "temperature_celsius", "is_stochastic", "nmodl_suffix", "neuron_block", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."is_ljp_corrected", OLD."is_temperature_dependent", OLD."temperature_celsius", OLD."is_stochastic", OLD."nmodl_suffix", OLD."neuron_block", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_ion_channel_model_audit)

    public_mtype_class_audit = PGFunction(
        schema="public",
        signature="mtype_class_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE mtype_class_version\n    SET operation_type = 1, "pref_label" = NEW."pref_label", "definition" = NEW."definition", "alt_label" = NEW."alt_label", "legacy_id" = NEW."legacy_id", "legacy_self" = NEW."legacy_self", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO mtype_class_version\n(transaction_id, operation_type, "pref_label", "definition", "alt_label", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."pref_label", NEW."definition", NEW."alt_label", NEW."legacy_id", NEW."legacy_self", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE mtype_class_version\n    SET operation_type = 1, "pref_label" = NEW."pref_label", "definition" = NEW."definition", "alt_label" = NEW."alt_label", "legacy_id" = NEW."legacy_id", "legacy_self" = NEW."legacy_self", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO mtype_class_version\n(transaction_id, operation_type, "pref_label", "definition", "alt_label", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."pref_label", NEW."definition", NEW."alt_label", NEW."legacy_id", NEW."legacy_self", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE mtype_class_version\n    SET "pref_label" = OLD."pref_label", "definition" = OLD."definition", "alt_label" = OLD."alt_label", "legacy_id" = OLD."legacy_id", "legacy_self" = OLD."legacy_self", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO mtype_class_version\n(transaction_id, operation_type, "pref_label", "definition", "alt_label", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."pref_label", OLD."definition", OLD."alt_label", OLD."legacy_id", OLD."legacy_self", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_mtype_class_audit)

    public_circuit_extraction_campaign_audit = PGFunction(
        schema="public",
        signature="circuit_extraction_campaign_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE circuit_extraction_campaign_version\n    SET operation_type = 1, "id" = NEW."id", "scan_parameters" = NEW."scan_parameters", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO circuit_extraction_campaign_version\n(transaction_id, operation_type, "id", "scan_parameters", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."scan_parameters", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE circuit_extraction_campaign_version\n    SET operation_type = 1, "id" = NEW."id", "scan_parameters" = NEW."scan_parameters", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO circuit_extraction_campaign_version\n(transaction_id, operation_type, "id", "scan_parameters", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."scan_parameters", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE circuit_extraction_campaign_version\n    SET "id" = OLD."id", "scan_parameters" = OLD."scan_parameters", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO circuit_extraction_campaign_version\n(transaction_id, operation_type, "id", "scan_parameters", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."scan_parameters", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_circuit_extraction_campaign_audit)

    public_cell_composition_audit = PGFunction(
        schema="public",
        signature="cell_composition_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE cell_composition_version\n    SET operation_type = 1, "id" = NEW."id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector", "brain_region_id" = NEW."brain_region_id", "species_id" = NEW."species_id", "strain_id" = NEW."strain_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO cell_composition_version\n(transaction_id, operation_type, "id", "name", "description", "description_vector", "brain_region_id", "species_id", "strain_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."name", NEW."description", NEW."description_vector", NEW."brain_region_id", NEW."species_id", NEW."strain_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE cell_composition_version\n    SET operation_type = 1, "id" = NEW."id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector", "brain_region_id" = NEW."brain_region_id", "species_id" = NEW."species_id", "strain_id" = NEW."strain_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO cell_composition_version\n(transaction_id, operation_type, "id", "name", "description", "description_vector", "brain_region_id", "species_id", "strain_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."name", NEW."description", NEW."description_vector", NEW."brain_region_id", NEW."species_id", NEW."strain_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE cell_composition_version\n    SET "id" = OLD."id", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector", "brain_region_id" = OLD."brain_region_id", "species_id" = OLD."species_id", "strain_id" = OLD."strain_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO cell_composition_version\n(transaction_id, operation_type, "id", "name", "description", "description_vector", "brain_region_id", "species_id", "strain_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."name", OLD."description", OLD."description_vector", OLD."brain_region_id", OLD."species_id", OLD."strain_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_cell_composition_audit)

    public_ion_channel_audit = PGFunction(
        schema="public",
        signature="ion_channel_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_version\n    SET operation_type = 1, "label" = NEW."label", "gene" = NEW."gene", "synonyms" = NEW."synonyms", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO ion_channel_version\n(transaction_id, operation_type, "label", "gene", "synonyms", "name", "description", "description_vector", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."label", NEW."gene", NEW."synonyms", NEW."name", NEW."description", NEW."description_vector", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_version\n    SET operation_type = 1, "label" = NEW."label", "gene" = NEW."gene", "synonyms" = NEW."synonyms", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO ion_channel_version\n(transaction_id, operation_type, "label", "gene", "synonyms", "name", "description", "description_vector", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."label", NEW."gene", NEW."synonyms", NEW."name", NEW."description", NEW."description_vector", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_version\n    SET "label" = OLD."label", "gene" = OLD."gene", "synonyms" = OLD."synonyms", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO ion_channel_version\n(transaction_id, operation_type, "label", "gene", "synonyms", "name", "description", "description_vector", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."label", OLD."gene", OLD."synonyms", OLD."name", OLD."description", OLD."description_vector", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_ion_channel_audit)

    public_mtype_classification_audit = PGFunction(
        schema="public",
        signature="mtype_classification_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE mtype_classification_version\n    SET operation_type = 1, "authorized_project_id" = NEW."authorized_project_id", "authorized_public" = NEW."authorized_public", "mtype_class_id" = NEW."mtype_class_id", "entity_id" = NEW."entity_id", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO mtype_classification_version\n(transaction_id, operation_type, "authorized_project_id", "authorized_public", "mtype_class_id", "entity_id", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."authorized_project_id", NEW."authorized_public", NEW."mtype_class_id", NEW."entity_id", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE mtype_classification_version\n    SET operation_type = 1, "authorized_project_id" = NEW."authorized_project_id", "authorized_public" = NEW."authorized_public", "mtype_class_id" = NEW."mtype_class_id", "entity_id" = NEW."entity_id", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO mtype_classification_version\n(transaction_id, operation_type, "authorized_project_id", "authorized_public", "mtype_class_id", "entity_id", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."authorized_project_id", NEW."authorized_public", NEW."mtype_class_id", NEW."entity_id", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE mtype_classification_version\n    SET "authorized_project_id" = OLD."authorized_project_id", "authorized_public" = OLD."authorized_public", "mtype_class_id" = OLD."mtype_class_id", "entity_id" = OLD."entity_id", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO mtype_classification_version\n(transaction_id, operation_type, "authorized_project_id", "authorized_public", "mtype_class_id", "entity_id", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."authorized_project_id", OLD."authorized_public", OLD."mtype_class_id", OLD."entity_id", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_mtype_classification_audit)

    public_scientific_artifact_external_url_link_audit = PGFunction(
        schema="public",
        signature="scientific_artifact_external_url_link_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE scientific_artifact_external_url_link_version\n    SET operation_type = 1, "external_url_id" = NEW."external_url_id", "scientific_artifact_id" = NEW."scientific_artifact_id", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO scientific_artifact_external_url_link_version\n(transaction_id, operation_type, "external_url_id", "scientific_artifact_id", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."external_url_id", NEW."scientific_artifact_id", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE scientific_artifact_external_url_link_version\n    SET operation_type = 1, "external_url_id" = NEW."external_url_id", "scientific_artifact_id" = NEW."scientific_artifact_id", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO scientific_artifact_external_url_link_version\n(transaction_id, operation_type, "external_url_id", "scientific_artifact_id", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."external_url_id", NEW."scientific_artifact_id", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE scientific_artifact_external_url_link_version\n    SET "external_url_id" = OLD."external_url_id", "scientific_artifact_id" = OLD."scientific_artifact_id", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO scientific_artifact_external_url_link_version\n(transaction_id, operation_type, "external_url_id", "scientific_artifact_id", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."external_url_id", OLD."scientific_artifact_id", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_scientific_artifact_external_url_link_audit)

    public_species_audit = PGFunction(
        schema="public",
        signature="species_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE species_version\n    SET operation_type = 1, "name" = NEW."name", "taxonomy_id" = NEW."taxonomy_id", "embedding" = NEW."embedding", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO species_version\n(transaction_id, operation_type, "name", "taxonomy_id", "embedding", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."name", NEW."taxonomy_id", NEW."embedding", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE species_version\n    SET operation_type = 1, "name" = NEW."name", "taxonomy_id" = NEW."taxonomy_id", "embedding" = NEW."embedding", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO species_version\n(transaction_id, operation_type, "name", "taxonomy_id", "embedding", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."name", NEW."taxonomy_id", NEW."embedding", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE species_version\n    SET "name" = OLD."name", "taxonomy_id" = OLD."taxonomy_id", "embedding" = OLD."embedding", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO species_version\n(transaction_id, operation_type, "name", "taxonomy_id", "embedding", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."name", OLD."taxonomy_id", OLD."embedding", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_species_audit)

    public_skeletonization_config_audit = PGFunction(
        schema="public",
        signature="skeletonization_config_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE skeletonization_config_version\n    SET operation_type = 1, "id" = NEW."id", "scan_parameters" = NEW."scan_parameters", "skeletonization_campaign_id" = NEW."skeletonization_campaign_id", "em_cell_mesh_id" = NEW."em_cell_mesh_id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO skeletonization_config_version\n(transaction_id, operation_type, "id", "scan_parameters", "skeletonization_campaign_id", "em_cell_mesh_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."scan_parameters", NEW."skeletonization_campaign_id", NEW."em_cell_mesh_id", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE skeletonization_config_version\n    SET operation_type = 1, "id" = NEW."id", "scan_parameters" = NEW."scan_parameters", "skeletonization_campaign_id" = NEW."skeletonization_campaign_id", "em_cell_mesh_id" = NEW."em_cell_mesh_id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO skeletonization_config_version\n(transaction_id, operation_type, "id", "scan_parameters", "skeletonization_campaign_id", "em_cell_mesh_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."scan_parameters", NEW."skeletonization_campaign_id", NEW."em_cell_mesh_id", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE skeletonization_config_version\n    SET "id" = OLD."id", "scan_parameters" = OLD."scan_parameters", "skeletonization_campaign_id" = OLD."skeletonization_campaign_id", "em_cell_mesh_id" = OLD."em_cell_mesh_id", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO skeletonization_config_version\n(transaction_id, operation_type, "id", "scan_parameters", "skeletonization_campaign_id", "em_cell_mesh_id", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."scan_parameters", OLD."skeletonization_campaign_id", OLD."em_cell_mesh_id", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_skeletonization_config_audit)

    public_brain_region_audit = PGFunction(
        schema="public",
        signature="brain_region_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE brain_region_version\n    SET operation_type = 1, "annotation_value" = NEW."annotation_value", "name" = NEW."name", "acronym" = NEW."acronym", "color_hex_triplet" = NEW."color_hex_triplet", "parent_structure_id" = NEW."parent_structure_id", "hierarchy_id" = NEW."hierarchy_id", "embedding" = NEW."embedding", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO brain_region_version\n(transaction_id, operation_type, "annotation_value", "name", "acronym", "color_hex_triplet", "parent_structure_id", "hierarchy_id", "embedding", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."annotation_value", NEW."name", NEW."acronym", NEW."color_hex_triplet", NEW."parent_structure_id", NEW."hierarchy_id", NEW."embedding", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE brain_region_version\n    SET operation_type = 1, "annotation_value" = NEW."annotation_value", "name" = NEW."name", "acronym" = NEW."acronym", "color_hex_triplet" = NEW."color_hex_triplet", "parent_structure_id" = NEW."parent_structure_id", "hierarchy_id" = NEW."hierarchy_id", "embedding" = NEW."embedding", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO brain_region_version\n(transaction_id, operation_type, "annotation_value", "name", "acronym", "color_hex_triplet", "parent_structure_id", "hierarchy_id", "embedding", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."annotation_value", NEW."name", NEW."acronym", NEW."color_hex_triplet", NEW."parent_structure_id", NEW."hierarchy_id", NEW."embedding", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE brain_region_version\n    SET "annotation_value" = OLD."annotation_value", "name" = OLD."name", "acronym" = OLD."acronym", "color_hex_triplet" = OLD."color_hex_triplet", "parent_structure_id" = OLD."parent_structure_id", "hierarchy_id" = OLD."hierarchy_id", "embedding" = OLD."embedding", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO brain_region_version\n(transaction_id, operation_type, "annotation_value", "name", "acronym", "color_hex_triplet", "parent_structure_id", "hierarchy_id", "embedding", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."annotation_value", OLD."name", OLD."acronym", OLD."color_hex_triplet", OLD."parent_structure_id", OLD."hierarchy_id", OLD."embedding", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_brain_region_audit)

    public_memodel_calibration_result_audit = PGFunction(
        schema="public",
        signature="memodel_calibration_result_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE memodel_calibration_result_version\n    SET operation_type = 1, "id" = NEW."id", "holding_current" = NEW."holding_current", "threshold_current" = NEW."threshold_current", "rin" = NEW."rin", "calibrated_entity_id" = NEW."calibrated_entity_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO memodel_calibration_result_version\n(transaction_id, operation_type, "id", "holding_current", "threshold_current", "rin", "calibrated_entity_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."holding_current", NEW."threshold_current", NEW."rin", NEW."calibrated_entity_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE memodel_calibration_result_version\n    SET operation_type = 1, "id" = NEW."id", "holding_current" = NEW."holding_current", "threshold_current" = NEW."threshold_current", "rin" = NEW."rin", "calibrated_entity_id" = NEW."calibrated_entity_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO memodel_calibration_result_version\n(transaction_id, operation_type, "id", "holding_current", "threshold_current", "rin", "calibrated_entity_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."holding_current", NEW."threshold_current", NEW."rin", NEW."calibrated_entity_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE memodel_calibration_result_version\n    SET "id" = OLD."id", "holding_current" = OLD."holding_current", "threshold_current" = OLD."threshold_current", "rin" = OLD."rin", "calibrated_entity_id" = OLD."calibrated_entity_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO memodel_calibration_result_version\n(transaction_id, operation_type, "id", "holding_current", "threshold_current", "rin", "calibrated_entity_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."holding_current", OLD."threshold_current", OLD."rin", OLD."calibrated_entity_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_memodel_calibration_result_audit)

    public_ion_channel_recording__ion_channel_modeling_campaign_audit = PGFunction(
        schema="public",
        signature="ion_channel_recording__ion_channel_modeling_campaign_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_recording__ion_channel_modeling_campaign_version\n    SET operation_type = 1, "ion_channel_recording_id" = NEW."ion_channel_recording_id", "ion_channel_modeling_campaign_id" = NEW."ion_channel_modeling_campaign_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "ion_channel_recording_id" = NEW."ion_channel_recording_id" AND "ion_channel_modeling_campaign_id" = NEW."ion_channel_modeling_campaign_id"\n    RETURNING *\n)\nINSERT INTO ion_channel_recording__ion_channel_modeling_campaign_version\n(transaction_id, operation_type, "ion_channel_recording_id", "ion_channel_modeling_campaign_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."ion_channel_recording_id", NEW."ion_channel_modeling_campaign_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_recording__ion_channel_modeling_campaign_version\n    SET operation_type = 1, "ion_channel_recording_id" = NEW."ion_channel_recording_id", "ion_channel_modeling_campaign_id" = NEW."ion_channel_modeling_campaign_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "ion_channel_recording_id" = NEW."ion_channel_recording_id" AND "ion_channel_modeling_campaign_id" = NEW."ion_channel_modeling_campaign_id"\n    RETURNING *\n)\nINSERT INTO ion_channel_recording__ion_channel_modeling_campaign_version\n(transaction_id, operation_type, "ion_channel_recording_id", "ion_channel_modeling_campaign_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."ion_channel_recording_id", NEW."ion_channel_modeling_campaign_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_recording__ion_channel_modeling_campaign_version\n    SET "ion_channel_recording_id" = OLD."ion_channel_recording_id", "ion_channel_modeling_campaign_id" = OLD."ion_channel_modeling_campaign_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "ion_channel_recording_id" = OLD."ion_channel_recording_id" AND "ion_channel_modeling_campaign_id" = OLD."ion_channel_modeling_campaign_id"\n    RETURNING *\n)\nINSERT INTO ion_channel_recording__ion_channel_modeling_campaign_version\n(transaction_id, operation_type, "ion_channel_recording_id", "ion_channel_modeling_campaign_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."ion_channel_recording_id", OLD."ion_channel_modeling_campaign_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_ion_channel_recording__ion_channel_modeling_campaign_audit)

    public_circuit_audit = PGFunction(
        schema="public",
        signature="circuit_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE circuit_version\n    SET operation_type = 1, "id" = NEW."id", "root_circuit_id" = NEW."root_circuit_id", "atlas_id" = NEW."atlas_id", "build_category" = NEW."build_category", "scale" = NEW."scale", "has_morphologies" = NEW."has_morphologies", "has_point_neurons" = NEW."has_point_neurons", "has_electrical_cell_models" = NEW."has_electrical_cell_models", "has_spines" = NEW."has_spines", "number_neurons" = NEW."number_neurons", "number_synapses" = NEW."number_synapses", "number_connections" = NEW."number_connections", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO circuit_version\n(transaction_id, operation_type, "id", "root_circuit_id", "atlas_id", "build_category", "scale", "has_morphologies", "has_point_neurons", "has_electrical_cell_models", "has_spines", "number_neurons", "number_synapses", "number_connections", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."root_circuit_id", NEW."atlas_id", NEW."build_category", NEW."scale", NEW."has_morphologies", NEW."has_point_neurons", NEW."has_electrical_cell_models", NEW."has_spines", NEW."number_neurons", NEW."number_synapses", NEW."number_connections", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE circuit_version\n    SET operation_type = 1, "id" = NEW."id", "root_circuit_id" = NEW."root_circuit_id", "atlas_id" = NEW."atlas_id", "build_category" = NEW."build_category", "scale" = NEW."scale", "has_morphologies" = NEW."has_morphologies", "has_point_neurons" = NEW."has_point_neurons", "has_electrical_cell_models" = NEW."has_electrical_cell_models", "has_spines" = NEW."has_spines", "number_neurons" = NEW."number_neurons", "number_synapses" = NEW."number_synapses", "number_connections" = NEW."number_connections", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO circuit_version\n(transaction_id, operation_type, "id", "root_circuit_id", "atlas_id", "build_category", "scale", "has_morphologies", "has_point_neurons", "has_electrical_cell_models", "has_spines", "number_neurons", "number_synapses", "number_connections", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."root_circuit_id", NEW."atlas_id", NEW."build_category", NEW."scale", NEW."has_morphologies", NEW."has_point_neurons", NEW."has_electrical_cell_models", NEW."has_spines", NEW."number_neurons", NEW."number_synapses", NEW."number_connections", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE circuit_version\n    SET "id" = OLD."id", "root_circuit_id" = OLD."root_circuit_id", "atlas_id" = OLD."atlas_id", "build_category" = OLD."build_category", "scale" = OLD."scale", "has_morphologies" = OLD."has_morphologies", "has_point_neurons" = OLD."has_point_neurons", "has_electrical_cell_models" = OLD."has_electrical_cell_models", "has_spines" = OLD."has_spines", "number_neurons" = OLD."number_neurons", "number_synapses" = OLD."number_synapses", "number_connections" = OLD."number_connections", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO circuit_version\n(transaction_id, operation_type, "id", "root_circuit_id", "atlas_id", "build_category", "scale", "has_morphologies", "has_point_neurons", "has_electrical_cell_models", "has_spines", "number_neurons", "number_synapses", "number_connections", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."root_circuit_id", OLD."atlas_id", OLD."build_category", OLD."scale", OLD."has_morphologies", OLD."has_point_neurons", OLD."has_electrical_cell_models", OLD."has_spines", OLD."number_neurons", OLD."number_synapses", OLD."number_connections", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_circuit_audit)

    public_simulation_campaign_audit = PGFunction(
        schema="public",
        signature="simulation_campaign_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE simulation_campaign_version\n    SET operation_type = 1, "id" = NEW."id", "entity_id" = NEW."entity_id", "scan_parameters" = NEW."scan_parameters", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO simulation_campaign_version\n(transaction_id, operation_type, "id", "entity_id", "scan_parameters", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."entity_id", NEW."scan_parameters", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE simulation_campaign_version\n    SET operation_type = 1, "id" = NEW."id", "entity_id" = NEW."entity_id", "scan_parameters" = NEW."scan_parameters", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO simulation_campaign_version\n(transaction_id, operation_type, "id", "entity_id", "scan_parameters", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."entity_id", NEW."scan_parameters", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE simulation_campaign_version\n    SET "id" = OLD."id", "entity_id" = OLD."entity_id", "scan_parameters" = OLD."scan_parameters", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO simulation_campaign_version\n(transaction_id, operation_type, "id", "entity_id", "scan_parameters", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."entity_id", OLD."scan_parameters", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_simulation_campaign_audit)

    public_cell_morphology_audit = PGFunction(
        schema="public",
        signature="cell_morphology_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE cell_morphology_version\n    SET operation_type = 1, "id" = NEW."id", "location" = NEW."location", "repair_pipeline_state" = NEW."repair_pipeline_state", "cell_morphology_protocol_id" = NEW."cell_morphology_protocol_id", "has_segmented_spines" = NEW."has_segmented_spines", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO cell_morphology_version\n(transaction_id, operation_type, "id", "location", "repair_pipeline_state", "cell_morphology_protocol_id", "has_segmented_spines", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."location", NEW."repair_pipeline_state", NEW."cell_morphology_protocol_id", NEW."has_segmented_spines", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE cell_morphology_version\n    SET operation_type = 1, "id" = NEW."id", "location" = NEW."location", "repair_pipeline_state" = NEW."repair_pipeline_state", "cell_morphology_protocol_id" = NEW."cell_morphology_protocol_id", "has_segmented_spines" = NEW."has_segmented_spines", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO cell_morphology_version\n(transaction_id, operation_type, "id", "location", "repair_pipeline_state", "cell_morphology_protocol_id", "has_segmented_spines", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."location", NEW."repair_pipeline_state", NEW."cell_morphology_protocol_id", NEW."has_segmented_spines", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE cell_morphology_version\n    SET "id" = OLD."id", "location" = OLD."location", "repair_pipeline_state" = OLD."repair_pipeline_state", "cell_morphology_protocol_id" = OLD."cell_morphology_protocol_id", "has_segmented_spines" = OLD."has_segmented_spines", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO cell_morphology_version\n(transaction_id, operation_type, "id", "location", "repair_pipeline_state", "cell_morphology_protocol_id", "has_segmented_spines", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."location", OLD."repair_pipeline_state", OLD."cell_morphology_protocol_id", OLD."has_segmented_spines", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_cell_morphology_audit)

    public_ion_channel_modeling_execution_audit = PGFunction(
        schema="public",
        signature="ion_channel_modeling_execution_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_modeling_execution_version\n    SET operation_type = 1, "id" = NEW."id", "status" = NEW."status", "executor" = NEW."executor", "execution_id" = NEW."execution_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO ion_channel_modeling_execution_version\n(transaction_id, operation_type, "id", "status", "executor", "execution_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."status", NEW."executor", NEW."execution_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_modeling_execution_version\n    SET operation_type = 1, "id" = NEW."id", "status" = NEW."status", "executor" = NEW."executor", "execution_id" = NEW."execution_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO ion_channel_modeling_execution_version\n(transaction_id, operation_type, "id", "status", "executor", "execution_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."status", NEW."executor", NEW."execution_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_modeling_execution_version\n    SET "id" = OLD."id", "status" = OLD."status", "executor" = OLD."executor", "execution_id" = OLD."execution_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO ion_channel_modeling_execution_version\n(transaction_id, operation_type, "id", "status", "executor", "execution_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."status", OLD."executor", OLD."execution_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_ion_channel_modeling_execution_audit)

    public_ion_channel_model__emodel_audit = PGFunction(
        schema="public",
        signature="ion_channel_model__emodel_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_model__emodel_version\n    SET operation_type = 1, "ion_channel_model_id" = NEW."ion_channel_model_id", "emodel_id" = NEW."emodel_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "ion_channel_model_id" = NEW."ion_channel_model_id" AND "emodel_id" = NEW."emodel_id"\n    RETURNING *\n)\nINSERT INTO ion_channel_model__emodel_version\n(transaction_id, operation_type, "ion_channel_model_id", "emodel_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."ion_channel_model_id", NEW."emodel_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_model__emodel_version\n    SET operation_type = 1, "ion_channel_model_id" = NEW."ion_channel_model_id", "emodel_id" = NEW."emodel_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "ion_channel_model_id" = NEW."ion_channel_model_id" AND "emodel_id" = NEW."emodel_id"\n    RETURNING *\n)\nINSERT INTO ion_channel_model__emodel_version\n(transaction_id, operation_type, "ion_channel_model_id", "emodel_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."ion_channel_model_id", NEW."emodel_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE ion_channel_model__emodel_version\n    SET "ion_channel_model_id" = OLD."ion_channel_model_id", "emodel_id" = OLD."emodel_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "ion_channel_model_id" = OLD."ion_channel_model_id" AND "emodel_id" = OLD."emodel_id"\n    RETURNING *\n)\nINSERT INTO ion_channel_model__emodel_version\n(transaction_id, operation_type, "ion_channel_model_id", "emodel_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."ion_channel_model_id", OLD."emodel_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_ion_channel_model__emodel_audit)

    public_annotation_audit = PGFunction(
        schema="public",
        signature="annotation_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE annotation_version\n    SET operation_type = 1, "note" = NEW."note", "entity_id" = NEW."entity_id", "annotation_body_id" = NEW."annotation_body_id", "legacy_id" = NEW."legacy_id", "legacy_self" = NEW."legacy_self", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO annotation_version\n(transaction_id, operation_type, "note", "entity_id", "annotation_body_id", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."note", NEW."entity_id", NEW."annotation_body_id", NEW."legacy_id", NEW."legacy_self", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE annotation_version\n    SET operation_type = 1, "note" = NEW."note", "entity_id" = NEW."entity_id", "annotation_body_id" = NEW."annotation_body_id", "legacy_id" = NEW."legacy_id", "legacy_self" = NEW."legacy_self", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO annotation_version\n(transaction_id, operation_type, "note", "entity_id", "annotation_body_id", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."note", NEW."entity_id", NEW."annotation_body_id", NEW."legacy_id", NEW."legacy_self", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE annotation_version\n    SET "note" = OLD."note", "entity_id" = OLD."entity_id", "annotation_body_id" = OLD."annotation_body_id", "legacy_id" = OLD."legacy_id", "legacy_self" = OLD."legacy_self", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO annotation_version\n(transaction_id, operation_type, "note", "entity_id", "annotation_body_id", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."note", OLD."entity_id", OLD."annotation_body_id", OLD."legacy_id", OLD."legacy_self", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_annotation_audit)

    public_annotation_body_audit = PGFunction(
        schema="public",
        signature="annotation_body_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE annotation_body_version\n    SET operation_type = 1, "type" = NEW."type", "legacy_id" = NEW."legacy_id", "legacy_self" = NEW."legacy_self", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO annotation_body_version\n(transaction_id, operation_type, "type", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."type", NEW."legacy_id", NEW."legacy_self", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE annotation_body_version\n    SET operation_type = 1, "type" = NEW."type", "legacy_id" = NEW."legacy_id", "legacy_self" = NEW."legacy_self", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO annotation_body_version\n(transaction_id, operation_type, "type", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."type", NEW."legacy_id", NEW."legacy_self", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE annotation_body_version\n    SET "type" = OLD."type", "legacy_id" = OLD."legacy_id", "legacy_self" = OLD."legacy_self", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO annotation_body_version\n(transaction_id, operation_type, "type", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."type", OLD."legacy_id", OLD."legacy_self", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_annotation_body_audit)

    public_measurement_annotation_audit = PGFunction(
        schema="public",
        signature="measurement_annotation_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE measurement_annotation_version\n    SET operation_type = 1, "entity_id" = NEW."entity_id", "legacy_id" = NEW."legacy_id", "legacy_self" = NEW."legacy_self", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO measurement_annotation_version\n(transaction_id, operation_type, "entity_id", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."entity_id", NEW."legacy_id", NEW."legacy_self", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE measurement_annotation_version\n    SET operation_type = 1, "entity_id" = NEW."entity_id", "legacy_id" = NEW."legacy_id", "legacy_self" = NEW."legacy_self", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO measurement_annotation_version\n(transaction_id, operation_type, "entity_id", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."entity_id", NEW."legacy_id", NEW."legacy_self", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE measurement_annotation_version\n    SET "entity_id" = OLD."entity_id", "legacy_id" = OLD."legacy_id", "legacy_self" = OLD."legacy_self", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO measurement_annotation_version\n(transaction_id, operation_type, "entity_id", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."entity_id", OLD."legacy_id", OLD."legacy_self", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_measurement_annotation_audit)

    public_circuit_extraction_config_audit = PGFunction(
        schema="public",
        signature="circuit_extraction_config_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE circuit_extraction_config_version\n    SET operation_type = 1, "id" = NEW."id", "circuit_id" = NEW."circuit_id", "scan_parameters" = NEW."scan_parameters", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO circuit_extraction_config_version\n(transaction_id, operation_type, "id", "circuit_id", "scan_parameters", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."circuit_id", NEW."scan_parameters", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE circuit_extraction_config_version\n    SET operation_type = 1, "id" = NEW."id", "circuit_id" = NEW."circuit_id", "scan_parameters" = NEW."scan_parameters", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO circuit_extraction_config_version\n(transaction_id, operation_type, "id", "circuit_id", "scan_parameters", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."circuit_id", NEW."scan_parameters", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE circuit_extraction_config_version\n    SET "id" = OLD."id", "circuit_id" = OLD."circuit_id", "scan_parameters" = OLD."scan_parameters", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO circuit_extraction_config_version\n(transaction_id, operation_type, "id", "circuit_id", "scan_parameters", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."circuit_id", OLD."scan_parameters", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_circuit_extraction_config_audit)

    public_analysis_notebook_environment_audit = PGFunction(
        schema="public",
        signature="analysis_notebook_environment_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE analysis_notebook_environment_version\n    SET operation_type = 1, "id" = NEW."id", "runtime_info" = NEW."runtime_info"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO analysis_notebook_environment_version\n(transaction_id, operation_type, "id", "runtime_info")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."runtime_info"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE analysis_notebook_environment_version\n    SET operation_type = 1, "id" = NEW."id", "runtime_info" = NEW."runtime_info"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO analysis_notebook_environment_version\n(transaction_id, operation_type, "id", "runtime_info")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."runtime_info"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE analysis_notebook_environment_version\n    SET "id" = OLD."id", "runtime_info" = OLD."runtime_info"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO analysis_notebook_environment_version\n(transaction_id, operation_type, "id", "runtime_info")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."runtime_info"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_analysis_notebook_environment_audit)

    public_usage_audit = PGFunction(
        schema="public",
        signature="usage_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE usage_version\n    SET operation_type = 1, "usage_entity_id" = NEW."usage_entity_id", "usage_activity_id" = NEW."usage_activity_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "usage_entity_id" = NEW."usage_entity_id" AND "usage_activity_id" = NEW."usage_activity_id"\n    RETURNING *\n)\nINSERT INTO usage_version\n(transaction_id, operation_type, "usage_entity_id", "usage_activity_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."usage_entity_id", NEW."usage_activity_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE usage_version\n    SET operation_type = 1, "usage_entity_id" = NEW."usage_entity_id", "usage_activity_id" = NEW."usage_activity_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "usage_entity_id" = NEW."usage_entity_id" AND "usage_activity_id" = NEW."usage_activity_id"\n    RETURNING *\n)\nINSERT INTO usage_version\n(transaction_id, operation_type, "usage_entity_id", "usage_activity_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."usage_entity_id", NEW."usage_activity_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE usage_version\n    SET "usage_entity_id" = OLD."usage_entity_id", "usage_activity_id" = OLD."usage_activity_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "usage_entity_id" = OLD."usage_entity_id" AND "usage_activity_id" = OLD."usage_activity_id"\n    RETURNING *\n)\nINSERT INTO usage_version\n(transaction_id, operation_type, "usage_entity_id", "usage_activity_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."usage_entity_id", OLD."usage_activity_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_usage_audit)

    public_organization_audit = PGFunction(
        schema="public",
        signature="organization_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE organization_version\n    SET operation_type = 1, "id" = NEW."id", "alternative_name" = NEW."alternative_name"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO organization_version\n(transaction_id, operation_type, "id", "alternative_name")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."alternative_name"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE organization_version\n    SET operation_type = 1, "id" = NEW."id", "alternative_name" = NEW."alternative_name"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO organization_version\n(transaction_id, operation_type, "id", "alternative_name")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."alternative_name"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE organization_version\n    SET "id" = OLD."id", "alternative_name" = OLD."alternative_name"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO organization_version\n(transaction_id, operation_type, "id", "alternative_name")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."alternative_name"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_organization_audit)

    public_em_cell_mesh__skeletonization_campaign_audit = PGFunction(
        schema="public",
        signature="em_cell_mesh__skeletonization_campaign_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE em_cell_mesh__skeletonization_campaign_version\n    SET operation_type = 1, "em_cell_mesh_id" = NEW."em_cell_mesh_id", "skeletonization_campaign_id" = NEW."skeletonization_campaign_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "em_cell_mesh_id" = NEW."em_cell_mesh_id" AND "skeletonization_campaign_id" = NEW."skeletonization_campaign_id"\n    RETURNING *\n)\nINSERT INTO em_cell_mesh__skeletonization_campaign_version\n(transaction_id, operation_type, "em_cell_mesh_id", "skeletonization_campaign_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."em_cell_mesh_id", NEW."skeletonization_campaign_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE em_cell_mesh__skeletonization_campaign_version\n    SET operation_type = 1, "em_cell_mesh_id" = NEW."em_cell_mesh_id", "skeletonization_campaign_id" = NEW."skeletonization_campaign_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "em_cell_mesh_id" = NEW."em_cell_mesh_id" AND "skeletonization_campaign_id" = NEW."skeletonization_campaign_id"\n    RETURNING *\n)\nINSERT INTO em_cell_mesh__skeletonization_campaign_version\n(transaction_id, operation_type, "em_cell_mesh_id", "skeletonization_campaign_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."em_cell_mesh_id", NEW."skeletonization_campaign_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE em_cell_mesh__skeletonization_campaign_version\n    SET "em_cell_mesh_id" = OLD."em_cell_mesh_id", "skeletonization_campaign_id" = OLD."skeletonization_campaign_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "em_cell_mesh_id" = OLD."em_cell_mesh_id" AND "skeletonization_campaign_id" = OLD."skeletonization_campaign_id"\n    RETURNING *\n)\nINSERT INTO em_cell_mesh__skeletonization_campaign_version\n(transaction_id, operation_type, "em_cell_mesh_id", "skeletonization_campaign_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."em_cell_mesh_id", OLD."skeletonization_campaign_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_em_cell_mesh__skeletonization_campaign_audit)

    public_role_audit = PGFunction(
        schema="public",
        signature="role_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE role_version\n    SET operation_type = 1, "name" = NEW."name", "role_id" = NEW."role_id", "legacy_id" = NEW."legacy_id", "legacy_self" = NEW."legacy_self", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO role_version\n(transaction_id, operation_type, "name", "role_id", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."name", NEW."role_id", NEW."legacy_id", NEW."legacy_self", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE role_version\n    SET operation_type = 1, "name" = NEW."name", "role_id" = NEW."role_id", "legacy_id" = NEW."legacy_id", "legacy_self" = NEW."legacy_self", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO role_version\n(transaction_id, operation_type, "name", "role_id", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."name", NEW."role_id", NEW."legacy_id", NEW."legacy_self", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE role_version\n    SET "name" = OLD."name", "role_id" = OLD."role_id", "legacy_id" = OLD."legacy_id", "legacy_self" = OLD."legacy_self", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO role_version\n(transaction_id, operation_type, "name", "role_id", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."name", OLD."role_id", OLD."legacy_id", OLD."legacy_self", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_role_audit)

    public_generation_audit = PGFunction(
        schema="public",
        signature="generation_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE generation_version\n    SET operation_type = 1, "generation_entity_id" = NEW."generation_entity_id", "generation_activity_id" = NEW."generation_activity_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "generation_entity_id" = NEW."generation_entity_id" AND "generation_activity_id" = NEW."generation_activity_id"\n    RETURNING *\n)\nINSERT INTO generation_version\n(transaction_id, operation_type, "generation_entity_id", "generation_activity_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."generation_entity_id", NEW."generation_activity_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE generation_version\n    SET operation_type = 1, "generation_entity_id" = NEW."generation_entity_id", "generation_activity_id" = NEW."generation_activity_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "generation_entity_id" = NEW."generation_entity_id" AND "generation_activity_id" = NEW."generation_activity_id"\n    RETURNING *\n)\nINSERT INTO generation_version\n(transaction_id, operation_type, "generation_entity_id", "generation_activity_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."generation_entity_id", NEW."generation_activity_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE generation_version\n    SET "generation_entity_id" = OLD."generation_entity_id", "generation_activity_id" = OLD."generation_activity_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "generation_entity_id" = OLD."generation_entity_id" AND "generation_activity_id" = OLD."generation_activity_id"\n    RETURNING *\n)\nINSERT INTO generation_version\n(transaction_id, operation_type, "generation_entity_id", "generation_activity_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."generation_entity_id", OLD."generation_activity_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_generation_audit)

    public_external_url_audit = PGFunction(
        schema="public",
        signature="external_url_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE external_url_version\n    SET operation_type = 1, "source" = NEW."source", "url" = NEW."url", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO external_url_version\n(transaction_id, operation_type, "source", "url", "id", "created_by_id", "updated_by_id", "creation_date", "update_date", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."source", NEW."url", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE external_url_version\n    SET operation_type = 1, "source" = NEW."source", "url" = NEW."url", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO external_url_version\n(transaction_id, operation_type, "source", "url", "id", "created_by_id", "updated_by_id", "creation_date", "update_date", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."source", NEW."url", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE external_url_version\n    SET "source" = OLD."source", "url" = OLD."url", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO external_url_version\n(transaction_id, operation_type, "source", "url", "id", "created_by_id", "updated_by_id", "creation_date", "update_date", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."source", OLD."url", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_external_url_audit)

    public_simulation_audit = PGFunction(
        schema="public",
        signature="simulation_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE simulation_version\n    SET operation_type = 1, "id" = NEW."id", "simulation_campaign_id" = NEW."simulation_campaign_id", "entity_id" = NEW."entity_id", "scan_parameters" = NEW."scan_parameters", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO simulation_version\n(transaction_id, operation_type, "id", "simulation_campaign_id", "entity_id", "scan_parameters", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."simulation_campaign_id", NEW."entity_id", NEW."scan_parameters", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE simulation_version\n    SET operation_type = 1, "id" = NEW."id", "simulation_campaign_id" = NEW."simulation_campaign_id", "entity_id" = NEW."entity_id", "scan_parameters" = NEW."scan_parameters", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO simulation_version\n(transaction_id, operation_type, "id", "simulation_campaign_id", "entity_id", "scan_parameters", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."simulation_campaign_id", NEW."entity_id", NEW."scan_parameters", NEW."name", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE simulation_version\n    SET "id" = OLD."id", "simulation_campaign_id" = OLD."simulation_campaign_id", "entity_id" = OLD."entity_id", "scan_parameters" = OLD."scan_parameters", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO simulation_version\n(transaction_id, operation_type, "id", "simulation_campaign_id", "entity_id", "scan_parameters", "name", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."simulation_campaign_id", OLD."entity_id", OLD."scan_parameters", OLD."name", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_simulation_audit)

    public_license_audit = PGFunction(
        schema="public",
        signature="license_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE license_version\n    SET operation_type = 1, "name" = NEW."name", "label" = NEW."label", "legacy_id" = NEW."legacy_id", "legacy_self" = NEW."legacy_self", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO license_version\n(transaction_id, operation_type, "name", "label", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."name", NEW."label", NEW."legacy_id", NEW."legacy_self", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE license_version\n    SET operation_type = 1, "name" = NEW."name", "label" = NEW."label", "legacy_id" = NEW."legacy_id", "legacy_self" = NEW."legacy_self", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date", "description" = NEW."description", "description_vector" = NEW."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO license_version\n(transaction_id, operation_type, "name", "label", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."name", NEW."label", NEW."legacy_id", NEW."legacy_self", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date", NEW."description", NEW."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE license_version\n    SET "name" = OLD."name", "label" = OLD."label", "legacy_id" = OLD."legacy_id", "legacy_self" = OLD."legacy_self", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date", "description" = OLD."description", "description_vector" = OLD."description_vector"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO license_version\n(transaction_id, operation_type, "name", "label", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date", "description", "description_vector")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."name", OLD."label", OLD."legacy_id", OLD."legacy_self", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date", OLD."description", OLD."description_vector"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_license_audit)

    public_agent_audit = PGFunction(
        schema="public",
        signature="agent_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE agent_version\n    SET operation_type = 1, "type" = NEW."type", "pref_label" = NEW."pref_label", "legacy_id" = NEW."legacy_id", "legacy_self" = NEW."legacy_self", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO agent_version\n(transaction_id, operation_type, "type", "pref_label", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."type", NEW."pref_label", NEW."legacy_id", NEW."legacy_self", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE agent_version\n    SET operation_type = 1, "type" = NEW."type", "pref_label" = NEW."pref_label", "legacy_id" = NEW."legacy_id", "legacy_self" = NEW."legacy_self", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO agent_version\n(transaction_id, operation_type, "type", "pref_label", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."type", NEW."pref_label", NEW."legacy_id", NEW."legacy_self", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE agent_version\n    SET "type" = OLD."type", "pref_label" = OLD."pref_label", "legacy_id" = OLD."legacy_id", "legacy_self" = OLD."legacy_self", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO agent_version\n(transaction_id, operation_type, "type", "pref_label", "legacy_id", "legacy_self", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."type", OLD."pref_label", OLD."legacy_id", OLD."legacy_self", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_agent_audit)

    public_simulation_generation_audit = PGFunction(
        schema="public",
        signature="simulation_generation_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE simulation_generation_version\n    SET operation_type = 1, "id" = NEW."id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO simulation_generation_version\n(transaction_id, operation_type, "id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE simulation_generation_version\n    SET operation_type = 1, "id" = NEW."id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO simulation_generation_version\n(transaction_id, operation_type, "id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE simulation_generation_version\n    SET "id" = OLD."id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO simulation_generation_version\n(transaction_id, operation_type, "id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_simulation_generation_audit)

    public_asset_audit = PGFunction(
        schema="public",
        signature="asset_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE asset_version\n    SET operation_type = 1, "status" = NEW."status", "path" = NEW."path", "full_path" = NEW."full_path", "is_directory" = NEW."is_directory", "content_type" = NEW."content_type", "size" = NEW."size", "sha256_digest" = NEW."sha256_digest", "meta" = NEW."meta", "label" = NEW."label", "entity_id" = NEW."entity_id", "storage_type" = NEW."storage_type", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO asset_version\n(transaction_id, operation_type, "status", "path", "full_path", "is_directory", "content_type", "size", "sha256_digest", "meta", "label", "entity_id", "storage_type", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."status", NEW."path", NEW."full_path", NEW."is_directory", NEW."content_type", NEW."size", NEW."sha256_digest", NEW."meta", NEW."label", NEW."entity_id", NEW."storage_type", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE asset_version\n    SET operation_type = 1, "status" = NEW."status", "path" = NEW."path", "full_path" = NEW."full_path", "is_directory" = NEW."is_directory", "content_type" = NEW."content_type", "size" = NEW."size", "sha256_digest" = NEW."sha256_digest", "meta" = NEW."meta", "label" = NEW."label", "entity_id" = NEW."entity_id", "storage_type" = NEW."storage_type", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO asset_version\n(transaction_id, operation_type, "status", "path", "full_path", "is_directory", "content_type", "size", "sha256_digest", "meta", "label", "entity_id", "storage_type", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."status", NEW."path", NEW."full_path", NEW."is_directory", NEW."content_type", NEW."size", NEW."sha256_digest", NEW."meta", NEW."label", NEW."entity_id", NEW."storage_type", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE asset_version\n    SET "status" = OLD."status", "path" = OLD."path", "full_path" = OLD."full_path", "is_directory" = OLD."is_directory", "content_type" = OLD."content_type", "size" = OLD."size", "sha256_digest" = OLD."sha256_digest", "meta" = OLD."meta", "label" = OLD."label", "entity_id" = OLD."entity_id", "storage_type" = OLD."storage_type", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO asset_version\n(transaction_id, operation_type, "status", "path", "full_path", "is_directory", "content_type", "size", "sha256_digest", "meta", "label", "entity_id", "storage_type", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."status", OLD."path", OLD."full_path", OLD."is_directory", OLD."content_type", OLD."size", OLD."sha256_digest", OLD."meta", OLD."label", OLD."entity_id", OLD."storage_type", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_asset_audit)

    public_experimental_neuron_density_audit = PGFunction(
        schema="public",
        signature="experimental_neuron_density_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE experimental_neuron_density_version\n    SET operation_type = 1, "id" = NEW."id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector", "brain_region_id" = NEW."brain_region_id", "subject_id" = NEW."subject_id", "license_id" = NEW."license_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO experimental_neuron_density_version\n(transaction_id, operation_type, "id", "name", "description", "description_vector", "brain_region_id", "subject_id", "license_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."name", NEW."description", NEW."description_vector", NEW."brain_region_id", NEW."subject_id", NEW."license_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE experimental_neuron_density_version\n    SET operation_type = 1, "id" = NEW."id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector", "brain_region_id" = NEW."brain_region_id", "subject_id" = NEW."subject_id", "license_id" = NEW."license_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO experimental_neuron_density_version\n(transaction_id, operation_type, "id", "name", "description", "description_vector", "brain_region_id", "subject_id", "license_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."name", NEW."description", NEW."description_vector", NEW."brain_region_id", NEW."subject_id", NEW."license_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE experimental_neuron_density_version\n    SET "id" = OLD."id", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector", "brain_region_id" = OLD."brain_region_id", "subject_id" = OLD."subject_id", "license_id" = OLD."license_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO experimental_neuron_density_version\n(transaction_id, operation_type, "id", "name", "description", "description_vector", "brain_region_id", "subject_id", "license_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."name", OLD."description", OLD."description_vector", OLD."brain_region_id", OLD."subject_id", OLD."license_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_experimental_neuron_density_audit)

    public_skeletonization_execution_audit = PGFunction(
        schema="public",
        signature="skeletonization_execution_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE skeletonization_execution_version\n    SET operation_type = 1, "id" = NEW."id", "status" = NEW."status", "executor" = NEW."executor", "execution_id" = NEW."execution_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO skeletonization_execution_version\n(transaction_id, operation_type, "id", "status", "executor", "execution_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."status", NEW."executor", NEW."execution_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE skeletonization_execution_version\n    SET operation_type = 1, "id" = NEW."id", "status" = NEW."status", "executor" = NEW."executor", "execution_id" = NEW."execution_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO skeletonization_execution_version\n(transaction_id, operation_type, "id", "status", "executor", "execution_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."status", NEW."executor", NEW."execution_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE skeletonization_execution_version\n    SET "id" = OLD."id", "status" = OLD."status", "executor" = OLD."executor", "execution_id" = OLD."execution_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO skeletonization_execution_version\n(transaction_id, operation_type, "id", "status", "executor", "execution_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."status", OLD."executor", OLD."execution_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_skeletonization_execution_audit)

    public_etype_classification_audit = PGFunction(
        schema="public",
        signature="etype_classification_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE etype_classification_version\n    SET operation_type = 1, "authorized_project_id" = NEW."authorized_project_id", "authorized_public" = NEW."authorized_public", "etype_class_id" = NEW."etype_class_id", "entity_id" = NEW."entity_id", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO etype_classification_version\n(transaction_id, operation_type, "authorized_project_id", "authorized_public", "etype_class_id", "entity_id", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."authorized_project_id", NEW."authorized_public", NEW."etype_class_id", NEW."entity_id", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE etype_classification_version\n    SET operation_type = 1, "authorized_project_id" = NEW."authorized_project_id", "authorized_public" = NEW."authorized_public", "etype_class_id" = NEW."etype_class_id", "entity_id" = NEW."entity_id", "id" = NEW."id", "created_by_id" = NEW."created_by_id", "updated_by_id" = NEW."updated_by_id", "creation_date" = NEW."creation_date", "update_date" = NEW."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO etype_classification_version\n(transaction_id, operation_type, "authorized_project_id", "authorized_public", "etype_class_id", "entity_id", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."authorized_project_id", NEW."authorized_public", NEW."etype_class_id", NEW."entity_id", NEW."id", NEW."created_by_id", NEW."updated_by_id", NEW."creation_date", NEW."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE etype_classification_version\n    SET "authorized_project_id" = OLD."authorized_project_id", "authorized_public" = OLD."authorized_public", "etype_class_id" = OLD."etype_class_id", "entity_id" = OLD."entity_id", "id" = OLD."id", "created_by_id" = OLD."created_by_id", "updated_by_id" = OLD."updated_by_id", "creation_date" = OLD."creation_date", "update_date" = OLD."update_date"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO etype_classification_version\n(transaction_id, operation_type, "authorized_project_id", "authorized_public", "etype_class_id", "entity_id", "id", "created_by_id", "updated_by_id", "creation_date", "update_date")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."authorized_project_id", OLD."authorized_public", OLD."etype_class_id", OLD."entity_id", OLD."id", OLD."created_by_id", OLD."updated_by_id", OLD."creation_date", OLD."update_date"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_etype_classification_audit)

    public_skeletonization_config_generation_audit = PGFunction(
        schema="public",
        signature="skeletonization_config_generation_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE skeletonization_config_generation_version\n    SET operation_type = 1, "id" = NEW."id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO skeletonization_config_generation_version\n(transaction_id, operation_type, "id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE skeletonization_config_generation_version\n    SET operation_type = 1, "id" = NEW."id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO skeletonization_config_generation_version\n(transaction_id, operation_type, "id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE skeletonization_config_generation_version\n    SET "id" = OLD."id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO skeletonization_config_generation_version\n(transaction_id, operation_type, "id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_skeletonization_config_generation_audit)

    public_experimental_synapses_per_connection_audit = PGFunction(
        schema="public",
        signature="experimental_synapses_per_connection_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE experimental_synapses_per_connection_version\n    SET operation_type = 1, "id" = NEW."id", "pre_mtype_id" = NEW."pre_mtype_id", "post_mtype_id" = NEW."post_mtype_id", "pre_region_id" = NEW."pre_region_id", "post_region_id" = NEW."post_region_id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector", "subject_id" = NEW."subject_id", "brain_region_id" = NEW."brain_region_id", "license_id" = NEW."license_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO experimental_synapses_per_connection_version\n(transaction_id, operation_type, "id", "pre_mtype_id", "post_mtype_id", "pre_region_id", "post_region_id", "name", "description", "description_vector", "subject_id", "brain_region_id", "license_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."pre_mtype_id", NEW."post_mtype_id", NEW."pre_region_id", NEW."post_region_id", NEW."name", NEW."description", NEW."description_vector", NEW."subject_id", NEW."brain_region_id", NEW."license_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE experimental_synapses_per_connection_version\n    SET operation_type = 1, "id" = NEW."id", "pre_mtype_id" = NEW."pre_mtype_id", "post_mtype_id" = NEW."post_mtype_id", "pre_region_id" = NEW."pre_region_id", "post_region_id" = NEW."post_region_id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector", "subject_id" = NEW."subject_id", "brain_region_id" = NEW."brain_region_id", "license_id" = NEW."license_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO experimental_synapses_per_connection_version\n(transaction_id, operation_type, "id", "pre_mtype_id", "post_mtype_id", "pre_region_id", "post_region_id", "name", "description", "description_vector", "subject_id", "brain_region_id", "license_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."pre_mtype_id", NEW."post_mtype_id", NEW."pre_region_id", NEW."post_region_id", NEW."name", NEW."description", NEW."description_vector", NEW."subject_id", NEW."brain_region_id", NEW."license_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE experimental_synapses_per_connection_version\n    SET "id" = OLD."id", "pre_mtype_id" = OLD."pre_mtype_id", "post_mtype_id" = OLD."post_mtype_id", "pre_region_id" = OLD."pre_region_id", "post_region_id" = OLD."post_region_id", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector", "subject_id" = OLD."subject_id", "brain_region_id" = OLD."brain_region_id", "license_id" = OLD."license_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO experimental_synapses_per_connection_version\n(transaction_id, operation_type, "id", "pre_mtype_id", "post_mtype_id", "pre_region_id", "post_region_id", "name", "description", "description_vector", "subject_id", "brain_region_id", "license_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."pre_mtype_id", OLD."post_mtype_id", OLD."pre_region_id", OLD."post_region_id", OLD."name", OLD."description", OLD."description_vector", OLD."subject_id", OLD."brain_region_id", OLD."license_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_experimental_synapses_per_connection_audit)

    public_me_type_density_audit = PGFunction(
        schema="public",
        signature="me_type_density_audit()",
        definition='RETURNS TRIGGER AS $$\nDECLARE transaction_id_value INT;\nBEGIN\n    BEGIN\n        transaction_id_value = (SELECT id FROM temporary_transaction);\n    EXCEPTION WHEN others THEN\n        RETURN NEW;\n    END;\n    IF transaction_id_value IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    IF (TG_OP = \'INSERT\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE me_type_density_version\n    SET operation_type = 1, "id" = NEW."id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector", "brain_region_id" = NEW."brain_region_id", "species_id" = NEW."species_id", "strain_id" = NEW."strain_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO me_type_density_version\n(transaction_id, operation_type, "id", "name", "description", "description_vector", "brain_region_id", "species_id", "strain_id")\nSELECT\n    transaction_id_value,\n    0,\n    NEW."id", NEW."name", NEW."description", NEW."description_vector", NEW."brain_region_id", NEW."species_id", NEW."strain_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'UPDATE\') THEN\n        IF (hstore(NEW.*) - hstore(OLD.*) - ARRAY[]::text[])\n            = hstore(\'\')\n        THEN\n            RETURN NULL;\n        END IF;\n        \n        \nWITH upsert as\n(\n    UPDATE me_type_density_version\n    SET operation_type = 1, "id" = NEW."id", "name" = NEW."name", "description" = NEW."description", "description_vector" = NEW."description_vector", "brain_region_id" = NEW."brain_region_id", "species_id" = NEW."species_id", "strain_id" = NEW."strain_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = NEW."id"\n    RETURNING *\n)\nINSERT INTO me_type_density_version\n(transaction_id, operation_type, "id", "name", "description", "description_vector", "brain_region_id", "species_id", "strain_id")\nSELECT\n    transaction_id_value,\n    1,\n    NEW."id", NEW."name", NEW."description", NEW."description_vector", NEW."brain_region_id", NEW."species_id", NEW."strain_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    ELSIF (TG_OP = \'DELETE\') THEN\n        \n        \nWITH upsert as\n(\n    UPDATE me_type_density_version\n    SET "id" = OLD."id", "name" = OLD."name", "description" = OLD."description", "description_vector" = OLD."description_vector", "brain_region_id" = OLD."brain_region_id", "species_id" = OLD."species_id", "strain_id" = OLD."strain_id"\n    WHERE\n        transaction_id = transaction_id_value\n        AND\n        "id" = OLD."id"\n    RETURNING *\n)\nINSERT INTO me_type_density_version\n(transaction_id, operation_type, "id", "name", "description", "description_vector", "brain_region_id", "species_id", "strain_id")\nSELECT\n    transaction_id_value,\n    2,\n    OLD."id", OLD."name", OLD."description", OLD."description_vector", OLD."brain_region_id", OLD."species_id", OLD."strain_id"\nWHERE NOT EXISTS (SELECT 1 FROM upsert);\n\n    END IF;\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql',
    )
    op.drop_entity(public_me_type_density_audit)

    public_transaction_temp_table_generator = PGFunction(
        schema="public",
        signature="transaction_temp_table_generator()",
        definition="RETURNS TRIGGER AS $$\nBEGIN\n    \nCREATE TEMP TABLE IF NOT EXISTS temporary_transaction\n(id BIGINT, PRIMARY KEY(id))\nON COMMIT DELETE ROWS;\n\n    INSERT INTO temporary_transaction (id) VALUES (NEW.id);\n    RETURN NEW;\nEND;\n$$\nLANGUAGE plpgsql",
    )
    op.drop_entity(public_transaction_temp_table_generator)

    public_hstore = PGExtension(schema="public", signature="hstore")
    op.drop_entity(public_hstore)

    # ### end Alembic commands ###
